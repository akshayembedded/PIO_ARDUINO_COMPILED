{
    "name": "LuatOS",
    "prefix": "luatos_",
    "bleServiceId": "0xae06",
    "apiDocsKey": "docs_luatos_",
    "autocomplete": {
        "functions": [
            {
                "name": "_G",
                "snippet": "_G(${0:...})",
                "description": "_G"
            },
            {
                "name": "_VERSION",
                "snippet": "_VERSION(${0:...})",
                "description": "_VERSION"
            },
            {
                "name": "assert",
                "snippet": "assert(${1:v}${2:[, message]})",
                "description": "assert()"
            },
            {
                "name": "collectgarbage",
                "snippet": "collectgarbage(${1:[opt]}${2:[, arg]})",
                "description": "collectgarbage()"
            },
            {
                "name": "coroutine.create",
                "snippet": "coroutine.create( ${1:function} )",
                "description": "coroutine.create",
                "category": "Coroutines"
            },
            {
                "name": "coroutine.isyieldable",
                "snippet": "coroutine.isyieldable( )",
                "description": "coroutine.isyieldable",
                "category": "Coroutines"
            },
            {
                "name": "coroutine.resume",
                "snippet": "coroutine.resume( ${1:co}${2:[, val1, ···]} )",
                "description": "coroutine.resume",
                "category": "Coroutines"
            },
            {
                "name": "coroutine.running",
                "snippet": "coroutine.running( )",
                "description": "coroutine.running",
                "category": "Coroutines"
            },
            {
                "name": "coroutine.status",
                "snippet": "coroutine.status( ${1:co} )",
                "description": "coroutine.status",
                "category": "Coroutines"
            },
            {
                "name": "coroutine.wrap",
                "snippet": "coroutine.wrap( ${1:function} )",
                "description": "coroutine.wrap",
                "category": "Coroutines"
            },
            {
                "name": "coroutine.yield",
                "snippet": "coroutine.yield( ${1:...} )",
                "description": "coroutine.yield",
                "category": "Coroutines"
            },
            {
                "name": "debug.debug",
                "snippet": "debug.debug()",
                "description": "debug.debug ()",
                "category": "Debugging"
            },
            {
                "name": "debug.getfenv",
                "snippet": "debug.getfenv(${0:...})",
                "description": "debug.getfenv (o)",
                "category": "Debugging"
            },
            {
                "name": "debug.gethook",
                "snippet": "debug.gethook( ${1:[thread]} )",
                "description": "debug.gethook ([thread])",
                "category": "Debugging"
            },
            {
                "name": "debug.getinfo",
                "snippet": "debug.getinfo( ${1:[thread],}${2:f}${3:[, what]} )",
                "description": "debug.getinfo ([thread,] f [, what])",
                "category": "Debugging"
            },
            {
                "name": "debug.getlocal",
                "snippet": "debug.getlocal( ${1:[thread],}${2:f}${3:[, local]} )",
                "description": "debug.getlocal ([thread,] f, local)",
                "category": "Debugging"
            },
            {
                "name": "debug.getmetatable",
                "snippet": "debug.getmetatable( ${1:value} )",
                "description": "debug.getmetatable (value)",
                "category": "Debugging"
            },
            {
                "name": "debug.getregistry",
                "snippet": "debug.getregistry()",
                "description": "debug.getregistry ()",
                "category": "Debugging"
            },
            {
                "name": "debug.getupvalue",
                "snippet": "debug.getupvalue( ${1:f}, ${2:up} )",
                "description": "debug.getupvalue (f, up)",
                "category": "Debugging"
            },
            {
                "name": "debug.getuservalue",
                "snippet": "debug.getuservalue(${0:...})",
                "description": "debug.getuservalue (u)",
                "category": "Debugging"
            },
            {
                "name": "debug.getuservalue ",
                "snippet": "debug.getuservalue ( ${1:u} )",
                "description": "debug.getuservalue (u)",
                "category": "Debugging"
            },
            {
                "name": "debug.setfenv",
                "snippet": "debug.setfenv(${0:...})",
                "description": "debug.setfenv (object, table)",
                "category": "Debugging"
            },
            {
                "name": "debug.sethook",
                "snippet": "debug.sethook( ${1:[thead,]}${2:hook}, ${3:mask}${4:[, count]} )",
                "description": "debug.sethook ([thread,] hook, mask [, count])",
                "category": "Debugging"
            },
            {
                "name": "debug.setlocal",
                "snippet": "debug.setlocal( ${1:[thead,]}${2:level}, ${3:local}, ${4:value} )",
                "description": "debug.setlocal ([thread,] level, local, value)",
                "category": "Debugging"
            },
            {
                "name": "debug.setmetatable",
                "snippet": "debug.setmetatable( ${1:value}, ${2:table} )",
                "description": "debug.setmetatable (value, table)",
                "category": "Debugging"
            },
            {
                "name": "debug.setupvalue",
                "snippet": "debug.setupvalue( ${1:f}, ${2:up}, ${3:value} )",
                "description": "debug.setupvalue (f, up, value)",
                "category": "Debugging"
            },
            {
                "name": "debug.setuservalue",
                "snippet": "debug.setuservalue( ${1:udata}, ${2:value} )",
                "description": "debug.setuservalue (udata, value)",
                "category": "Debugging"
            },
            {
                "name": "debug.traceback",
                "snippet": "debug.traceback( ${1:[thread,]}${2:[message]}${3:[, level]} )",
                "description": "debug.traceback ([thread,] [message [, level]])",
                "category": "Debugging"
            },
            {
                "name": "debug.upvalueid",
                "snippet": "debug.upvalueid( ${1:f}, ${2:n})",
                "description": "debug.upvalueid (f, n)",
                "category": "Debugging"
            },
            {
                "name": "debug.upvaluejoin",
                "snippet": "debug.upvaluejoin( ${1:f1}, ${2:n1}, ${3:f2}, ${4:n2} )",
                "description": "debug.upvaluejoin (f1, n1, f2, n2)",
                "category": "Debugging"
            },
            {
                "name": "dofile",
                "snippet": "dofile(${1:[filename]})",
                "description": "dofile ([filename])"
            },
            {
                "name": "elif",
                "snippet": "else if ${1:condition} then\n\t${0:-- body}\n",
                "description": "elif"
            },
            {
                "name": "error",
                "snippet": "error(${0:...})",
                "description": "error (message [, level])"
            },
            {
                "name": "file:close",
                "snippet": "file:close(${0:...})",
                "description": "file:close ()"
            },
            {
                "name": "file:flush",
                "snippet": "file:flush(${0:...})",
                "description": "file:flush ()"
            },
            {
                "name": "file:lines",
                "snippet": "file:lines(${0:...})",
                "description": "file:lines ()"
            },
            {
                "name": "file:read",
                "snippet": "file:read(${0:...})",
                "description": "file:read (...)"
            },
            {
                "name": "file:seek",
                "snippet": "file:seek(${0:...})",
                "description": "file:seek ([whence] [, offset])"
            },
            {
                "name": "file:setvbuf",
                "snippet": "file:setvbuf(${0:...})",
                "description": "file:setvbuf (mode [, size])"
            },
            {
                "name": "file:write",
                "snippet": "file:write(${0:...})",
                "description": "file:write (...)"
            },
            {
                "name": "for",
                "snippet": "for ${1:i}=${2:1},${3:10} do\n\t${0:print(i)}\nend",
                "description": "for i=1,10"
            },
            {
                "name": "fori",
                "snippet": "for ${1:i},${2:v} in ipairs(${3:table_name}) do\n\t${0:print(i,v)}\nend",
                "description": "for i,v in ipairs()"
            },
            {
                "name": "forp",
                "snippet": "for ${1:k},${2:v} in pairs(${3:table_name}) do\n\t${0:print(k,v)}\nend",
                "description": "for k,v in pairs()"
            },
            {
                "name": "fun",
                "snippet": "function ${1:function_name}( ${2:...} )\n\t${0:-- body}\nend",
                "description": "function"
            },
            {
                "name": "function",
                "snippet": "function ${1:function_name}( ${2:...} )\n\t${0:-- body}\nend",
                "description": "function"
            },
            {
                "name": "getfenv",
                "snippet": "getfenv(${0:...})",
                "description": "getfenv ([f])"
            },
            {
                "name": "getmetatable",
                "snippet": "getmetatable(${1:object})",
                "description": "getmetatable (object)"
            },
            {
                "name": "if",
                "snippet": "if ${1:condition} then\n\t${0:-- body}\nend",
                "description": "if"
            },
            {
                "name": "ifel",
                "snippet": "if ${1:condition} then\n\t${2:-- body}\nelse\n\t${0:-- body}\nend",
                "description": "ifel"
            },
            {
                "name": "io.close",
                "snippet": "io.close(${0:...})",
                "description": "io.close ([file])",
                "category": "Input/Output"
            },
            {
                "name": "io.flush",
                "snippet": "io.flush(${0:...})",
                "description": "io.flush ()",
                "category": "Input/Output"
            },
            {
                "name": "io.input",
                "snippet": "io.input(${0:...})",
                "description": "io.input ([file])",
                "category": "Input/Output"
            },
            {
                "name": "io.lines",
                "snippet": "io.lines(${0:...})",
                "description": "io.lines ([filename])",
                "category": "Input/Output"
            },
            {
                "name": "io.open",
                "snippet": "io.open(${0:...})",
                "description": "io.open (filename [, mode])",
                "category": "Input/Output"
            },
            {
                "name": "io.output",
                "snippet": "io.output(${0:...})",
                "description": "io.output ([file])",
                "category": "Input/Output"
            },
            {
                "name": "io.popen",
                "snippet": "io.popen(${0:...})",
                "description": "io.popen (prog [, mode])",
                "category": "Input/Output"
            },
            {
                "name": "io.read",
                "snippet": "io.read(${0:...})",
                "description": "io.read (...)",
                "category": "Input/Output"
            },
            {
                "name": "io.tmpfile",
                "snippet": "io.tmpfile(${0:...})",
                "description": "io.tmpfile ()",
                "category": "Input/Output"
            },
            {
                "name": "io.type",
                "snippet": "io.type(${0:...})",
                "description": "io.type (obj)",
                "category": "Input/Output"
            },
            {
                "name": "io.write",
                "snippet": "io.write(${0:...})",
                "description": "io.write (...)",
                "category": "Input/Output"
            },
            {
                "name": "ipairs",
                "snippet": "ipairs(${0:...})",
                "description": "ipairs (t)"
            },
            {
                "name": "load",
                "snippet": "load(${0:...})",
                "description": "load (func [, chunkname])"
            },
            {
                "name": "loadfile",
                "snippet": "loadfile(${0:...})",
                "description": "loadfile ([filename])"
            },
            {
                "name": "loadstring",
                "snippet": "loadstring(${0:...})",
                "description": "loadstring (string [, chunkname])"
            },
            {
                "name": "local",
                "snippet": "local ${1:x} = ${0:1}",
                "description": "local x = 1"
            },
            {
                "name": "math.abs",
                "snippet": "math.abs( ${1:x} )",
                "description": "math.abs"
            },
            {
                "name": "math.acos",
                "snippet": "math.acos( ${1:x} )",
                "description": "math.acos"
            },
            {
                "name": "math.asin",
                "snippet": "math.asin( ${1:x} )",
                "description": "math.asin"
            },
            {
                "name": "math.atan",
                "snippet": "math.atan( ${1:y}${2:[, x]} )",
                "description": "math.atan"
            },
            {
                "name": "math.atan2",
                "snippet": "math.atan2(${0:...})",
                "description": "math.atan2 (y, x)"
            },
            {
                "name": "math.ceil",
                "snippet": "math.ceil( ${1:x} )",
                "description": "math.ceil"
            },
            {
                "name": "math.cos",
                "snippet": "math.cos( ${1:x} )",
                "description": "math.cos"
            },
            {
                "name": "math.cosh",
                "snippet": "math.cosh(${0:...})",
                "description": "math.cosh (x)"
            },
            {
                "name": "math.deg",
                "snippet": "math.deg( ${1:x} )",
                "description": "math.deg"
            },
            {
                "name": "math.exp",
                "snippet": "math.exp( ${1:x} )",
                "description": "math.exp"
            },
            {
                "name": "math.floor",
                "snippet": "math.floor( ${1:x} )",
                "description": "math.floor"
            },
            {
                "name": "math.fmod",
                "snippet": "math.fmod( ${1:x},${2:y} )",
                "description": "math.fmod"
            },
            {
                "name": "math.frexp",
                "snippet": "math.frexp(${0:...})",
                "description": "math.frexp (x)"
            },
            {
                "name": "math.huge",
                "snippet": "math.huge(${0:...})",
                "description": "math.huge"
            },
            {
                "name": "math.ldexp",
                "snippet": "math.ldexp(${0:...})",
                "description": "math.ldexp (m, e)"
            },
            {
                "name": "math.log",
                "snippet": "math.log( ${1:x}${2:[, base]} )",
                "description": "math.log"
            },
            {
                "name": "math.log10",
                "snippet": "math.log10(${0:...})",
                "description": "math.log10 (x)"
            },
            {
                "name": "math.math.randomseed",
                "snippet": "math.math.randomseed( ${1:x} )",
                "description": "math.math.randomseed"
            },
            {
                "name": "math.max",
                "snippet": "math.max( ${1:x},${2:...} )",
                "description": "math.max"
            },
            {
                "name": "math.maxinteger",
                "snippet": "math.maxinteger(${0:...})",
                "description": "math.maxinteger"
            },
            {
                "name": "math.min",
                "snippet": "math.min( ${1:x},${2:...} )",
                "description": "math.min"
            },
            {
                "name": "math.mininteger",
                "snippet": "math.mininteger(${0:...})",
                "description": "math.mininteger"
            },
            {
                "name": "math.modf",
                "snippet": "math.modf( ${1:x} )",
                "description": "math.modf"
            },
            {
                "name": "math.pi",
                "snippet": "math.pi(${0:...})",
                "description": "math.pi"
            },
            {
                "name": "math.pow",
                "snippet": "math.pow(${0:...})",
                "description": "math.pow (x, y)"
            },
            {
                "name": "math.rad",
                "snippet": "math.rad(${0:...})",
                "description": "math.rad (x)"
            },
            {
                "name": "math.random",
                "snippet": "math.random( ${1:[m]}${2:[, n]} )",
                "description": "math.random"
            },
            {
                "name": "math.randomseed",
                "snippet": "math.randomseed(${0:...})",
                "description": "math.randomseed (x)"
            },
            {
                "name": "math.sin",
                "snippet": "math.sin( ${1:x} )",
                "description": "math.sin"
            },
            {
                "name": "math.sinh",
                "snippet": "math.sinh(${0:...})",
                "description": "math.sinh (x)"
            },
            {
                "name": "math.sqrt",
                "snippet": "math.sqrt( ${1:x} )",
                "description": "math.sqrt"
            },
            {
                "name": "math.tan",
                "snippet": "math.tan( ${1:x} )",
                "description": "math.tan"
            },
            {
                "name": "math.tanh",
                "snippet": "math.tanh(${0:...})",
                "description": "math.tanh (x)"
            },
            {
                "name": "math.tointeger",
                "snippet": "math.tointeger( ${1:x} )",
                "description": "math.tointeger"
            },
            {
                "name": "math.type",
                "snippet": "math.type( ${1:x} )",
                "description": "math.type"
            },
            {
                "name": "math.ult",
                "snippet": "math.ult(${0:...})",
                "description": "math.ult (m, n)"
            },
            {
                "name": "module",
                "snippet": "module(${0:...})",
                "description": "module (name [, ...])"
            },
            {
                "name": "next",
                "snippet": "next(${1:table}${2:[, index]})",
                "description": "next (table [, index])"
            },
            {
                "name": "os.clock",
                "snippet": "os.clock()",
                "description": "os.clock() - 返回程序使用的按秒计 CPU 时间的近似值\n传入值：\nreturn 时间戳\n例子：\n-- 不推荐使用本API\n-- 如需要获取 时间戳, 请使用 os.time()\n-- 如需获取系统运行时长, 请使用 mcu.ticks()\n"
            },
            {
                "name": "os.date",
                "snippet": "os.date(${1:fmt},${2:time})",
                "description": "os.date(fmt, time) - 日期函数\n传入值：\nstring 格式化字符串,可以是nil\ntable 日期时间的table\n返回值：\ntable/string 根据fmt的不同,返回值不同\n例子：\n\n-- 值得注意的几点:\n-- 1. 若需要UTC时间, fmt的第一个字符写\"!\"\n-- 2. fmt的格式化遵循 C 函数 strftime, 可以查阅 https://developer.aliyun.com/article/320480\n\n-- 获取本地时间字符串\nlog.info(\"本地时间字符串\", os.date())\n-- 获取UTC时间字符串\nlog.info(\"UTC时间字符串\", os.date(\"!%c\"))\n-- 格式化本地时间字符串\nlog.info(\"本地时间字符串\", os.date(\"%Y-%m-%d %H:%M:%S\"))\n-- 格式化UTC时间字符串\nlog.info(\"UTC时间字符串\", os.date(\"!%Y-%m-%d %H:%M:%S\"))\n-- 格式化时间字符串\nlog.info(\"自定义时间的字符串\", os.date(\"!%Y-%m-%d %H:%M:%S\", os.time({year=2000, mon=1, day=1, hour=0, min=0, sec=0})))\n\n-- 获取本地时间的table\nlog.info(\"本地时间字符串\", json.encode(os.date(\"*t\")))\n-- 获取UTC时间的table\nlog.info(\"UTC时间字符串\",  json.encode(os.date(\"!*t\")))\n"
            },
            {
                "name": "os.difftime",
                "snippet": "os.difftime(${1:timeA},${2:timeB})",
                "description": "os.difftime(timeA, timeB) - 时间差值\n传入值：\nint 时间A,数值类型\nint 时间B,数值类型\n返回值：\nint 时间差值\n"
            },
            {
                "name": "os.execute",
                "snippet": "os.execute(${0:...})",
                "description": "os.execute ([command])"
            },
            {
                "name": "os.exit",
                "snippet": "os.exit(${0:...})",
                "description": "os.exit ([code])"
            },
            {
                "name": "os.getenv",
                "snippet": "os.getenv(${0:...})",
                "description": "os.getenv (varname)"
            },
            {
                "name": "os.remove",
                "snippet": "os.remove(${1:path})",
                "description": "os.remove(path) - 移除文件\n传入值：\nstring 待移除的文件完整路径\n返回值：\nbool 成功返回true,其他情况返回nil\nstring 失败时返回原因字符串\n例子：\n-- 删除根目录下的某个文件\nos.remove(\"/1.txt\")\n-- 注意, 线刷时的文件, 一般在 /luadb 目录, 这个目录下的文件是只读的\n-- 也就是无法执行 os.remove(\"/luadb/xxx.bin\")\n"
            },
            {
                "name": "os.rename",
                "snippet": "os.rename(${1:old_path},${2:new_path})",
                "description": "os.rename(old_path, new_path) - 文件重命名\n传入值：\nstring 源文件完整路径\nstring 目标文件完整路径\n返回值：\nbool 成功返回true,其他情况返回nil\nstring 失败时返回原因字符串\n例子：\n-- 注意, 只有在相同文件系统下的文件可以重命名\n-- 例如:\nos.rename(\"/1.txt\", \"/2.txt\")\n-- 不同文件系统, 或者源文件系统是只读的, 则无法执行\n--os.rename(\"/luadb/1.txt\", \"/luadb/2.txt\")\n--os.rename(\"/luadb/1.txt\", \"/2.txt\")\n"
            },
            {
                "name": "os.setlocale",
                "snippet": "os.setlocale(${0:...})",
                "description": "os.setlocale (locale [, category])"
            },
            {
                "name": "os.time",
                "snippet": "os.time(${1:mytime})",
                "description": "os.time(mytime) - 时间戳函数\n传入值：\ntable 日期时间的table\nreturn 时间戳\n例子：\n-- 注意注意, 这个函数返回的是UTC时间戳\n-- 时间戳, 但lua下的精度只能到秒\nlog.info(\"UTC时间戳\", os.time())\nlog.info(\"自定义时间戳\", os.time({year=2000, mon=1, day=1, hour=0, min=0, sec=0}))\n"
            },
            {
                "name": "os.tmpname",
                "snippet": "os.tmpname(${0:...})",
                "description": "os.tmpname ()"
            },
            {
                "name": "package.config",
                "snippet": "package.config(${0:...})",
                "description": "package.config"
            },
            {
                "name": "package.cpath",
                "snippet": "package.cpath(${0:...})",
                "description": "package.cpath"
            },
            {
                "name": "package.loaded",
                "snippet": "package.loaded(${0:...})",
                "description": "package.loaded"
            },
            {
                "name": "package.loaders",
                "snippet": "package.loaders(${0:...})",
                "description": "package.loaders"
            },
            {
                "name": "package.loadlib",
                "snippet": "package.loadlib(${0:...})",
                "description": "package.loadlib (libname, funcname)"
            },
            {
                "name": "package.path",
                "snippet": "package.path(${0:...})",
                "description": "package.path"
            },
            {
                "name": "package.preload",
                "snippet": "package.preload(${0:...})",
                "description": "package.preload"
            },
            {
                "name": "package.searchers",
                "snippet": "package.searchers(${0:...})",
                "description": "package.searchers"
            },
            {
                "name": "package.searchpath",
                "snippet": "package.searchpath(${0:...})",
                "description": "package.searchpath (name, path [, sep [, rep]])"
            },
            {
                "name": "package.seeall",
                "snippet": "package.seeall(${0:...})",
                "description": "package.seeall (module)"
            },
            {
                "name": "pairs",
                "snippet": "pairs(${0:...})",
                "description": "pairs (t)"
            },
            {
                "name": "pcall",
                "snippet": "pcall(${0:...})",
                "description": "pcall (f, arg1, ...)"
            },
            {
                "name": "print",
                "snippet": "print(${1:...})",
                "description": "print(...)"
            },
            {
                "name": "require",
                "snippet": "require\"${1:module}\"",
                "description": "require()"
            },
            {
                "name": "ret",
                "snippet": "return ${1:...}",
                "description": "return ..."
            },
            {
                "name": "select",
                "snippet": "select(${1:index}, ${2:...})",
                "description": "select (index, ···)"
            },
            {
                "name": "setfenv",
                "snippet": "setfenv(${0:...})",
                "description": "setfenv (f, table)"
            },
            {
                "name": "setmetatable",
                "snippet": "setmetatable(${1:table}, ${2:metatable})",
                "description": "setmetatable (table, metatable)"
            },
            {
                "name": "tonumber",
                "snippet": "tonumber(${1:e}${2:[, base]})",
                "description": "tonumber (e [, base])"
            },
            {
                "name": "tostring",
                "snippet": "tostring(${1:v})",
                "description": "tostring (v)"
            },
            {
                "name": "type",
                "snippet": "type(${1:v})",
                "description": "type (v)"
            },
            {
                "name": "unpack",
                "snippet": "unpack(${0:...})",
                "description": "unpack (list [, i [, j]])"
            },
            {
                "name": "xpcall",
                "snippet": "xpcall(${0:...})",
                "description": "xpcall (f, err)"
            },
            {
                "name": "sys.publish(...)",
                "snippet": "sys.publish(${1:...})",
                "description": "发布内部消息，存储在内部消息队列中\r\n返回值：\r\n无\r\n例子：\r\npublish(\"NET_STATUS_IND\")\r\n"
            },
            {
                "name": "sys.restart(r)",
                "snippet": "sys.restart(${1:r})",
                "description": "软件重启\r\n返回值：\r\n无\r\n例子：\r\nsys.restart('程序超时软件重启')\r\n"
            },
            {
                "name": "sys.run()",
                "snippet": "sys.run()",
                "description": "run()从底层获取core消息并及时处理相关消息，查询定时器并调度各注册成功的任务线程运行和挂起\r\n返回值：\r\n无\r\n例子：\r\nsys.run()\r\n"
            },
            {
                "name": "sys.setRollBack(flag, secs)",
                "snippet": "sys.setRollBack(${1:flag},${2: secs})",
                "description": "设置“lua脚本运行出错时，是否回退原始烧写版本”的功能开关。如果没有调用此接口设置，默认回滚\r\n返回值：\r\nnil\r\n例子：\r\nsys.setRollBack(true)\r\nsys.setRollBack(false)\r\n"
            },
            {
                "name": "sys.subscribe(id, callback)",
                "snippet": "sys.subscribe(${1:id},${2: callback})",
                "description": "订阅消息\r\n返回值：\r\n无\r\n例子：\r\nsubscribe(\"NET_STATUS_IND\", callback)\r\n"
            },
            {
                "name": "sys.taskInit(fun, ...)",
                "snippet": "sys.taskInit(${1:fun},${2: ...})",
                "description": "创建一个任务线程,在模块最末行调用该函数并注册模块中的任务函数，main.lua导入该模块即可\r\n返回值：\r\nco  返回该任务的线程号\r\n例子：\r\nsys.taskInit(task1,'a','b')\r\n"
            },
            {
                "name": "sys.timerIsActive(val, ...)",
                "snippet": "sys.timerIsActive(${1:val},${2: ...})",
                "description": "判断某个定时器是否处于开启状态\r\n返回值：\r\nnumber 开启状态返回true，否则nil"
            },
            {
                "name": "sys.timerLoopStart(fnc, ms, ...)",
                "snippet": "sys.timerLoopStart(${1:fnc},${2: ms},${3: ...})",
                "description": "开启一个循环定时器\r\n返回值：\r\nnumber 定时器ID，如果失败，返回nil"
            },
            {
                "name": "sys.timerStart(fnc, ms, ...)",
                "snippet": "sys.timerStart(${1:fnc},${2: ms},${3: ...})",
                "description": "开启一个定时器\r\n返回值：\r\nnumber 定时器ID，如果失败，返回nil"
            },
            {
                "name": "sys.timerStop(val, ...)",
                "snippet": "sys.timerStop(${1:val},${2: ...})",
                "description": "关闭定时器\r\n返回值：\r\n无\r\n例子：\r\ntimerStop(1)\r\n"
            },
            {
                "name": "sys.timerStopAll(fnc)",
                "snippet": "sys.timerStopAll(${1:fnc})",
                "description": "关闭同一回调函数的所有定时器\r\n返回值：\r\n无\r\n例子：\r\ntimerStopAll(cbFnc)\r\n"
            },
            {
                "name": "sys.unsubscribe(id, callback)",
                "snippet": "sys.unsubscribe(${1:id},${2: callback})",
                "description": "取消订阅消息\r\n返回值：\r\n无\r\n例子：\r\nunsubscribe(\"NET_STATUS_IND\", callback)\r\n"
            },
            {
                "name": "sys.wait(ms)",
                "snippet": "sys.wait(${1:ms})",
                "description": "Task任务延时函数，只能用于任务函数中\r\n返回值：\r\n定时结束返回nil,被其他线程唤起返回调用线程传入的参数\r\n例子：\r\nsys.wait(30)\r\n"
            },
            {
                "name": "sys.waitUntil(id, ms)",
                "snippet": "sys.waitUntil(${1:id},${2: ms})",
                "description": "Task任务的条件等待函数（包括事件消息和定时器消息等条件），只能用于任务函数中。\r\n返回值：\r\nresult 接收到消息返回true，超时返回false\r\n例子：\r\nresult, data = sys.waitUntil(\"SIM_IND\", 120000)\r\n"
            },
            {
                "name": "sys.waitUntilExt(id, ms)",
                "snippet": "sys.waitUntilExt(${1:id},${2: ms})",
                "description": "Task任务的条件等待函数扩展（包括事件消息和定时器消息等条件），只能用于任务函数中。\r\n返回值：\r\nmessage 接收到消息返回message，超时返回false\r\n例子：\r\nresult, data = sys.waitUntilExt(\"SIM_IND\", 120000)\r\n"
            },
            {
                "name": "table.concat(t,s)",
                "snippet": "table.concat(${1:t},${2: s})",
                "description": "表连接\r\n返回值：\r\n  字符串\r\n例子：\r\nfruits = {\"banana\",\"orange\",\"apple\"}\r\n-- 返回 table 连接后的字符串\r\nprint(\"连接后的字符串 \",table.concat(fruits))\r\n--连接后的字符串     bananaorangeapple\r\n\r\n-- 指定连接字符\r\nprint(\"连接后的字符串 \",table.concat(fruits,\", \"))\r\n--连接后的字符串     banana, orange, apple\r\n\r\n-- 指定索引来连接 table\r\nprint(\"连接后的字符串 \",table.concat(fruits,\", \", 2,3))\r\n--连接后的字符串     orange, apple\r\n"
            },
            {
                "name": "table.gsort(t, f)",
                "snippet": "table.gsort(${1:t},${2: f})",
                "description": "返回一个迭代器函数,每次调用函数都会返回hash表的排序后的键值对\r\n返回值：\r\nfunction.\r\n例子：\r\ntest = {a=1,f=9,d=2,c=8,b=5}\r\nfor name,line in pairsByKeys(test) do print(name,line) end\r\n"
            },
            {
                "name": "table.insert(t,d)",
                "snippet": "table.insert(${1:t},${2: d})",
                "description": "添加table参数\r\n返回值：\r\n  table\r\n例子：\r\nfruits = {\"banana\",\"orange\",\"apple\"}\r\n\r\n-- 在末尾插入\r\ntable.insert(fruits,\"mango\")\r\nprint(\"索引为 4 的元素为 \",fruits[4])\r\n--索引为 4 的元素为     mango\r\n\r\n-- 在索引为 2 的键处插入\r\ntable.insert(fruits,2,\"grapes\")\r\nprint(\"索引为 2 的元素为 \",fruits[2])\r\n--索引为 2 的元素为     grapes\r\n\r\nprint(\"最后一个元素为 \",fruits[5])\r\n--最后一个元素为     mango\r\n"
            },
            {
                "name": "table.remove(t,i)",
                "snippet": "table.remove(${1:t},${2: i})",
                "description": "移除table参数\r\n返回值：\r\n  table"
            },
            {
                "name": "string.byte()",
                "snippet": "string.byte()",
                "description": "接收控制字符，返回ASCII码\r\n返回值：\r\n  ASCII码\r\n例子：\r\nstring.byte(\"ABCD\")  --65\r\nstring.byte(\"ABCD\",4) --68\r\n"
            },
            {
                "name": "string.char()",
                "snippet": "string.char()",
                "description": "接收ASCII码，返回对应的控制字符\r\n返回值：\r\n  字符\r\n例子：\r\nstring.char(97,98,99,100)   --abcd\r\n"
            },
            {
                "name": "string.find()",
                "snippet": "string.find()",
                "description": "查找第一个字符串 s 中匹配到的 pattern\r\n返回值：\r\n  返回匹配字符具体位置。不存在则返回 nil\r\n例子：\r\nstring.find(\"Hello Lua user\", \"Lua\", 1)   --7   9\r\n"
            },
            {
                "name": "string.format()",
                "snippet": "string.format()",
                "description": "格式化字符串\r\n返回值：\r\n  字符串\r\n例子：\r\nstring.format(\"the value is:%d\",4)   --the value is:4\r\n"
            },
            {
                "name": "string.gsub()",
                "snippet": "string.gsub()",
                "description": "字符串替换"
            },
            {
                "name": "string.len()",
                "snippet": "string.len()",
                "description": "计算字符串长度\r\n返回值：\r\n  字符串长度\r\n例子：\r\nstring.len(\"abc\")  --3\r\n"
            },
            {
                "name": "string.lower()",
                "snippet": "string.lower()",
                "description": "字符串全部转为小写字母\r\n返回值：\r\n  小写字母字符串"
            },
            {
                "name": "string.rep()",
                "snippet": "string.rep()",
                "description": "字符串拷贝\r\n返回值：\r\n  字符串\r\n例子：\r\nstring.rep(\"abcd\",2)   --abcdabcd\r\n"
            },
            {
                "name": "string.reverse()",
                "snippet": "string.reverse()",
                "description": "字符串反转\r\n返回值：\r\n  反转后的字符串\r\n例子：\r\nstring.reverse(\"Luat\")  --tauL\r\n"
            },
            {
                "name": "string.split(str, delimiter)",
                "snippet": "string.split(${1:str},${2: delimiter})",
                "description": "按照指定分隔符分割字符串\r\n返回值：\r\n分割后的字符串列表\r\n例子：\r\n\"123,456,789\":split(',') -> {'123','456','789'}\r\n"
            },
            {
                "name": "string.upper()",
                "snippet": "string.upper()",
                "description": "字符串全部转为大写字母\r\n返回值：\r\n  大写字母字符串"
            },
            {
                "name": "adc.open",
                "snippet": "adc.open(${1:id})",
                "description": "adc.open(id) - 打开adc通道\n传入值：\nint 通道id,与具体设备有关,通常从0开始\n返回值：\nboolean 打开结果\n例子：\n-- 打开adc通道4,并读取\nif adc.open(4) then\n    log.info(\"adc\", adc.read(4)) -- 返回值有2个, 原始值和计算值,通常只需要后者\n    log.info(\"adc\", adc.get(4))  -- 返回值有1个, 仅计算值\nend\nadc.close(4) -- 若需要持续读取, 则不需要close, 功耗会高一点.\n"
            },
            {
                "name": "adc.setRange",
                "snippet": "adc.setRange(${1:range})",
                "description": "adc.setRange(range) - 设置ADC的测量范围，注意这个和具体芯片有关，目前只支持air105/Air780E系列\n传入值：\nint range参数,与具体设备有关,比如air105填adc.ADC_RANGE_1_8和adc.ADC_RANGE_3_6\nreturn nil\n例子：\n-- 本函数要在调用adc.open之前就调用, 之后调用无效!!!\n\n-- 关闭air105内部分压\nadc.setRange(adc.ADC_RANGE_1_8)\n-- 打开air105内部分压\nadc.setRange(adc.ADC_RANGE_3_6)\n\n\n-- EC618系列(Air780E等)/EC718E系列(Air780EP/Air780EPV等)支持以下2种\nadc.setRange(adc.ADC_RANGE_1_2) -- 关闭分压\nadc.setRange(adc.ADC_RANGE_3_8) -- 启用分压\n"
            },
            {
                "name": "adc.read",
                "snippet": "adc.read(${1:id})",
                "description": "adc.read(id) - 读取adc通道\n传入值：\nint 通道id,与具体设备有关,通常从0开始\n返回值：\nint 原始值,一般没用,可以直接抛弃\nint 从原始值换算得出的实际值，通常单位是mV\n例子：\n-- 打开adc通道2,并读取\nif adc.open(2) then\n    -- 这里使用的是adc.read会返回2个值, 推荐走adc.get函数,直接取实际值\n    log.info(\"adc\", adc.read(2))\nend\nadc.close(2)\n"
            },
            {
                "name": "adc.get",
                "snippet": "adc.get(${1:id})",
                "description": "adc.get(id) - 获取adc计算值\n传入值：\nint 通道id,与具体设备有关,通常从0开始\n返回值：\nint 单位通常是mV, 部分通道会返回温度值,单位千分之一摄氏度. 若读取失败,会返回-1\n例子：\n-- 本API 在 2022.10.01后编译的固件可用\n-- 打开adc通道2,并读取\nif adc.open(2) then\n    log.info(\"adc\", adc.get(2))\nend\nadc.close(2) -- 按需关闭\n"
            },
            {
                "name": "adc.close",
                "snippet": "adc.close(${1:id})",
                "description": "adc.close(id) - 关闭adc通道\n传入值：\nint 通道id,与具体设备有关,通常从0开始\n例子：\n-- 打开adc通道2,并读取\nif adc.open(2) then\n    log.info(\"adc\", adc.read(2))\nend\nadc.close(2)\n"
            },
            {
                "name": "antbot.init",
                "snippet": "antbot.init()",
                "description": "antbot.init() - 初始化\n返回值：\nint 0:成功 其他值为失败\n例子：\n\n-- 初始化蚂蚁链的底层适配\nantbot.init()\n"
            },
            {
                "name": "antbot.app_sta_get",
                "snippet": "antbot.app_sta_get()",
                "description": "antbot.app_sta_get() - 获取客户端状态\n返回值：\nint 状态码\n"
            },
            {
                "name": "antbot.version_get",
                "snippet": "antbot.version_get()",
                "description": "antbot.version_get() - 获取SDK版本号\n返回值：\nstring 版本号,如果获取失败返回nil\n"
            },
            {
                "name": "antbot.asset_register",
                "snippet": "antbot.asset_register(${1:asset_id},${2:asset_type},${3:asset_dataver})",
                "description": "antbot.asset_register(asset_id, asset_type, asset_dataver) - asset资源注册\n传入值：\nstring asset_id 资源ID\nstring asset_type 资源类型\nstring asset_dataver 资源数据版本\n返回值：\nint 0:成功 其他值为失败\n"
            },
            {
                "name": "antbot.asset_data_publish",
                "snippet": "antbot.asset_data_publish(${1:data})",
                "description": "antbot.asset_data_publish(data) - asset资源发布\n传入值：\nstring data 资源数据\n返回值：\nint 0:成功 其他值为失败\n"
            },
            {
                "name": "antbot.device_status_get",
                "snippet": "antbot.device_status_get()",
                "description": "antbot.device_status_get() - 获取设备状态\n返回值：\nint 设备状态\n"
            },
            {
                "name": "antbot.asset_status_get",
                "snippet": "antbot.asset_status_get(${1:asset_id})",
                "description": "antbot.asset_status_get(asset_id) - 获取assset状态\n传入值：\nstring asset_id 资源ID\n返回值：\nint 资源状态\n"
            },
            {
                "name": "antbot.channel_switch",
                "snippet": "antbot.channel_switch(${1:cmd})",
                "description": "antbot.channel_switch(cmd) - 切换channel\n传入值：\nint 0 - 关闭, 1 - 开启\n返回值：\nint 0:成功 其他值为失败\n"
            },
            {
                "name": "antbot.config_set",
                "snippet": "antbot.config_set(${1:config})",
                "description": "antbot.config_set(config) - 配置设备\n传入值：\nstring config 配置内容\n返回值：\nint 0:成功 其他值为失败\n"
            },
            {
                "name": "antbot.config_get",
                "snippet": "antbot.config_get()",
                "description": "antbot.config_get() - 获取设备配置\n返回值：\nstring 配置内容\n"
            },
            {
                "name": "audio.start",
                "snippet": "audio.start(${1:id},${2:audio_format},${3:num_channels},${4:sample_rate},${5:bits_per_sample},${6:is_signed})",
                "description": "audio.start(id, audio_format, num_channels, sample_rate, bits_per_sample, is_signed) - 启动一个多媒体通道准备播放音频\n传入值：\nint 多媒体播放通道号\nint 音频格式\nint 声音通道数\nint 采样频率\nint 采样位数\nboolean 是否有符号，默认true\n返回值：\nboolean 成功true, 失败false\n例子：\naudio.start(0, audio.PCM, 1, 16000, 16)\n"
            },
            {
                "name": "audio.record",
                "snippet": "audio.record(${1:id},${2:record_type},${3:record_time},${4:amr_quailty},${5:path})",
                "description": "audio.record(id, record_type, record_time, amr_quailty, path) - 录音\n传入值：\nint id             多媒体播放通道号\nint record_type    录音音频格式,支持 audio.AMR audio.PCM (部分平台支持audio.AMR_WB)\nint record_time    录制时长 单位秒,可选，默认0即表示一直录制\nint amr_quailty    质量,audio.AMR下有效\nstring path        录音文件路径,可选,不指定则不保存,可在audio.on回调函数中处理原始PCM数据\nint record_callback_time    不指定录音文件路径时，单次录音回调时长，单位是100ms。默认1，既100ms\n返回值：\nboolean 成功返回true,否则返回false\n例子：\nerr,info = audio.record(id, type, record_time, quailty, path)\n"
            },
            {
                "name": "audio.recordStop",
                "snippet": "audio.recordStop(${1:id})",
                "description": "audio.recordStop(id) - 录音停止\n传入值：\nint id         多媒体播放通道号\n返回值：\nboolean 成功返回true,否则返回false\n例子：\naudio.recordStop(0)\n"
            },
            {
                "name": "audio.write",
                "snippet": "audio.write(${1:id},${2:data})",
                "description": "audio.write(id, data) - 往一个多媒体通道写入音频数据\n传入值：\nstring or zbuff 音频数据\n返回值：\nboolean 成功返回true,否则返回false\n例子：\naudio.write(0, \"xxxxxx\")\n"
            },
            {
                "name": "audio.stop",
                "snippet": "audio.stop(${1:id})",
                "description": "audio.stop(id) - 停止指定的多媒体通道\n传入值：\nint audio id,例如0\n返回值：\nboolean 成功返回true,否则返回false\n例子：\naudio.stop(0)\n"
            },
            {
                "name": "audio.pause",
                "snippet": "audio.pause(${1:id},${2:pause})",
                "description": "audio.pause(id, pause) - 暂停/恢复指定的多媒体通道\n传入值：\nint audio id,例如0\nboolean onoff true 暂停，false 恢复\n返回值：\nboolean 成功返回true,否则返回false\n例子：\naudio.pause(0, true) --暂停通道0\naudio.pause(0, false) --恢复通道0\n"
            },
            {
                "name": "audio.on",
                "snippet": "audio.on(${1:audio_id},${2:func})",
                "description": "audio.on(audio_id, func) - 注册audio播放事件回调\n传入值：\nint audio id, audio 0写0, audio 1写1\nfunction 回调方法，回调时传入参数为1、int 通道ID 2、int 消息值，只有audio.MORE_DATA和audio.DONE\n返回值：\nnil 无返回值\n例子：\naudio.on(0, function(audio_id, msg)\n    log.info(\"msg\", audio_id, msg)\nend)\n"
            },
            {
                "name": "audio.play",
                "snippet": "audio.play(${1:id},${2:path},${3:errStop})",
                "description": "audio.play(id, path, errStop) - 播放或者停止播放一个文件，播放完成后，会回调一个audio.DONE消息，可以用pause来暂停或者恢复，其他API不可用。考虑到读SD卡速度比较慢而拖累luavm进程的速度，所以尽量使用本API\n传入值：\nint 音频通道\nstring/table 文件名，如果为空，则表示停止播放，如果是table，则表示连续播放多个文件，主要应用于云喇叭，目前只有EC618支持，并且会用到errStop参数\nboolean 是否在文件解码失败后停止解码，只有在连续播放多个文件时才有用，默认true，遇到解码错误自动停止\n返回值：\nboolean 成功返回true,否则返回false\n例子：\naudio.play(0, \"xxxxxx\")        --开始播放某个文件\naudio.play(0)                --停止播放某个文件\n"
            },
            {
                "name": "audio.tts",
                "snippet": "audio.tts(${1:id},${2:data})",
                "description": "audio.tts(id, data) - TTS播放或者停止\n传入值：\nint 音频通道\nstring/zbuff 需要播放的内容\n返回值：\nboolean 成功返回true,否则返回false\n"
            },
            {
                "name": "audio.playStop",
                "snippet": "audio.playStop(${1:id})",
                "description": "audio.playStop(id) - 停止播放文件，和audio.play(id)是一样的作用\n传入值：\nint audio id,例如0\n返回值：\nboolean 成功返回true,否则返回false\n例子：\naudio.playStop(0)\n"
            },
            {
                "name": "audio.isEnd",
                "snippet": "audio.isEnd(${1:id})",
                "description": "audio.isEnd(id) - 检查当前文件是否已经播放结束\n传入值：\nint 音频通道\n返回值：\nboolean 成功返回true,否则返回false\n例子：\naudio.isEnd(0)\n\n"
            },
            {
                "name": "audio.getError",
                "snippet": "audio.getError(${1:id})",
                "description": "audio.getError(id) - 获取最近一次播放结果，不是所有平台都支持的，目前只有EC618支持\n传入值：\nint 音频通道\n返回值：\nboolean 是否全部播放成功，true成功，false有文件播放失败\nboolean 如果播放失败，是否是用户停止，true是，false不是\nint 第几个文件失败了，从1开始\n例子：\nlocal result, user_stop, file_no = audio.getError(0)\n"
            },
            {
                "name": "audio.config",
                "snippet": "audio.config(${1:id},${2:paPin},${3:onLevel},${4:dacDelay},${5:paDelay},${6:dacPin},${7:dacLevel},${8:dacTimeDelay})",
                "description": "audio.config(id, paPin, onLevel, dacDelay, paDelay, dacPin, dacLevel, dacTimeDelay) - 配置一个音频通道的特性，比如实现自动控制PA开关。注意这个不是必须的，一般在调用play的时候才需要自动控制，其他情况比如你手动控制播放时，就可以自己控制PA开关\n传入值：\nint 音频通道\nint PA控制IO\nint PA打开时的电平\nint 在DAC启动前插入的冗余时间，单位100ms，一般用于外部DAC\nint 在DAC启动后，延迟多长时间打开PA，单位1ms\nint 外部dac电源控制IO，如果不填，则表示使用平台默认IO，比如Air780E使用DACEN脚，air105则不启用\nint 外部dac打开时，电源控制IO的电平，默认拉高\nint 音频播放完毕时，PA与DAC关闭的时间间隔，单位1ms，默认0ms\n例子：\naudio.config(0, pin.PC0, 1)    --PA控制脚是PC0，高电平打开，air105用这个配置就可以用了\naudio.config(0, 25, 1, 6, 200)    --PA控制脚是GPIO25，高电平打开，Air780E云喇叭板用这个配置就可以用了\n"
            },
            {
                "name": "audio.vol",
                "snippet": "audio.vol(${1:id},${2:value})",
                "description": "audio.vol(id, value) - 配置一个音频通道的音量调节，直接将原始数据放大或者缩小，不是所有平台都支持，建议尽量用硬件方法去缩放\n传入值：\nint 音频通道\nint 音量，百分比，1%~1000%，默认100%，就是不调节\n返回值：\nint 当前音量\n例子：\nlocal result = audio.vol(0, 90)    --通道0的音量调节到90%，result存放了调节后的音量水平，有可能仍然是100\n"
            },
            {
                "name": "audio.micVol",
                "snippet": "audio.micVol(${1:id},${2:value})",
                "description": "audio.micVol(id, value) - 配置一个音频通道的mic音量调节\n传入值：\nint 音频通道\nint mic音量，百分比，1%~100%，默认100%，就是不调节\n返回值：\nint 当前mic音量\n例子：\nlocal result = audio.vol(0, 90)    --通道0的音量调节到90%，result存放了调节后的音量水平，有可能仍然是100\n"
            },
            {
                "name": "audio.setBus",
                "snippet": "audio.setBus(${1:id},${2:bus_type})",
                "description": "audio.setBus(id, bus_type) - 配置一个音频通道的硬件输出总线，只有对应soc软硬件平台支持才设置对应类型\n传入值：\nint 音频通道,例如0\nint 总线类型, 例如 audio.BUS_SOFT_DAC\nint 硬件id, 例如 总线类型为audio.BUS_I2S时,硬件id即为i2s codec的i2c id\n返回值：\nnil 无返回值\n例子：\naudio.setBus(0, audio.BUS_SOFT_DAC)    --通道0的硬件输出通道设置为软件DAC\naudio.setBus(0, audio.BUS_I2S)    --通道0的硬件输出通道设置为I2S\n"
            },
            {
                "name": "audio.debug",
                "snippet": "audio.debug(${1:on_off})",
                "description": "audio.debug(on_off) - 配置调试信息输出\n传入值：\nboolean true开 false关\n"
            },
            {
                "name": "audio.pm",
                "snippet": "audio.pm(${1:id},${2:pm_mode})",
                "description": "audio.pm(id,pm_mode) - audio 休眠控制(一般会自动调用不需要手动执行)\n传入值：\nint 音频通道\nint 休眠模式 \n返回值：\nboolean true成功\n例子：\naudio.pm(multimedia_id,audio.RESUME)\n"
            },
            {
                "name": "bit64.to32",
                "snippet": "bit64.to32(${1:data64bit})",
                "description": "bit64.to32(data64bit) - 64bit数据转成32bit输出\n传入值：\nstring 9字节数据\n返回值：\nany 根据64bit数据输出int或者number\n"
            },
            {
                "name": "bit64.to64",
                "snippet": "bit64.to64(${1:data32bit})",
                "description": "bit64.to64(data32bit) - 32bit数据转成64bit数据\n传入值：\nint/number 32bit数据\n返回值：\nstring 9字节数据\n"
            },
            {
                "name": "bit64.show",
                "snippet": "bit64.show(${1:a},${2:type},${3:flag})",
                "description": "bit64.show(a,type,flag) - 64bit数据格式化打印成字符串，用于显示值\n传入值：\nstring 需要打印的64bit数据\nint 进制，10=10进制，16=16进制，默认10，只支持10或者16\nboolean 整形是否按照无符号方式打印，true是，false不是，默认false，浮点忽略\n返回值：\nstring 可以打印的值\n"
            },
            {
                "name": "bit64.plus",
                "snippet": "bit64.plus(${1:a},${2:b},${3:flag1},${4:flag2})",
                "description": "bit64.plus(a,b,flag1,flag2) - 64bit数据加,a+b,a和b中有一个为浮点，则按照浮点运算\n传入值：\nstring a\nstring/int/number b\nboolean 整形运算时是否按照无符号方式，true是，false不是，默认false，浮点运算忽略\nboolean 浮点运算结果是否要强制转成整数，true是，false不是，默认false，整形运算忽略\n返回值：\nstring 9字节数据\n"
            },
            {
                "name": "bit64.minus",
                "snippet": "bit64.minus(${1:a},${2:b},${3:flag1},${4:flag2})",
                "description": "bit64.minus(a,b,flag1,flag2) - 64bit数据减,a-b,a和b中有一个为浮点，则按照浮点运算\n传入值：\nstring a\nstring/int/number b\nboolean 整形运算时是否按照无符号方式，true是，false不是，默认false，浮点运算忽略\nboolean 浮点运算结果是否要强制转成整数，true是，false不是，默认false，整形运算忽略\n返回值：\nstring 9字节数据\n"
            },
            {
                "name": "bit64.multi",
                "snippet": "bit64.multi(${1:a},${2:b},${3:flag1},${4:flag2})",
                "description": "bit64.multi(a,b,flag1,flag2) - 64bit数据乘,a*b,a和b中有一个为浮点，则按照浮点运算\n传入值：\nstring a\nstring/int/number b\nboolean 整形运算时是否按照无符号方式，true是，false不是，默认false，浮点运算忽略\nboolean 浮点运算结果是否要强制转成整数，true是，false不是，默认false，整形运算忽略\n返回值：\nstring 9字节数据\n"
            },
            {
                "name": "bit64.pide",
                "snippet": "bit64.pide(${1:a},${2:b},${3:flag1},${4:flag2})",
                "description": "bit64.pide(a,b,flag1,flag2) - 64bit数据除,a/b,a和b中有一个为浮点，则按照浮点运算\n传入值：\nstring a\nstring/int/number b\nboolean 整形运算时是否按照无符号方式，true是，false不是，默认false，浮点运算忽略\nboolean 浮点运算结果是否要强制转成整数，true是，false不是，默认false，整形运算忽略\n返回值：\nstring 9字节数据\n"
            },
            {
                "name": "bit64.shift",
                "snippet": "bit64.shift(${1:a},${2:b},${3:flag})",
                "description": "bit64.shift(a,b,flag) - 64bit数据位移 a>>b 或者 a<<b\n传入值：\nstring a\nint b\nboolean 位移方向，true左移<<，false右移>>，默认false\n返回值：\nstring 9字节数据\n"
            },
            {
                "name": "bit64.strtoll",
                "snippet": "bit64.strtoll(${1:data},${2:base})",
                "description": "bit64.strtoll(data, base) - 将字符串转为LongLong数据\n传入值：\nstring 待转换的数据,必须存在\nint 转换进制, 默认10, 可选16或8\n返回值：\nstring 9字节数据\n例子：\n-- 本API于 2023.10.27 添加\n-- 提醒, 如果转换失败, 是返回9个字节的0x00\nlocal data = bit64.strtoll(\"864040064024194\", 10)\nlog.info(\"data\", data:toHex())\nlog.info(\"data\", bit64.show(data))\n"
            },
            {
                "name": "camera.init",
                "snippet": "camera.init(${1:InitReg_or_cspi_id},${2:cspi_speed},${3:mode},${4:is_msb},${5:rx_bit},${6:seq_type},${7:is_ddr},${8:only_y},${9:scan_mode},${10:w},${11:h})",
                "description": "camera.init(InitReg_or_cspi_id, cspi_speed, mode, is_msb, rx_bit, seq_type, is_ddr, only_y, scan_mode, w, h) - 初始化摄像头\n传入值：\ntable/integer 如果是table,则是DVP摄像头的配置见demo/camera/AIR105,同时忽略后续参数;如果是数字,则是camera spi总线序号\nint camera spi总线速度\nint camera spi模式,0~3\nint 字节的bit顺序是否是msb,0否1是\nint 同时接收bit数,1,2,4\nint byte序列,0~1\nint 双边沿采样配置,0不启用,其他值根据实际SOC决定\nint 只接收Y分量，0不启用，1启用，扫码必须启用，否则会失败\nint 工作模式，camera.AUTO自动,camera.SCAN扫码\nint 摄像头宽度\nint 摄像头高度\n返回值：\nint/false 成功返回camera_id，失败返回false\n例子：\ncamera_id = camera.init(GC032A_InitReg)--屏幕输出rgb图像\n--初始化后需要start才开始输出/扫码\ncamera.start(camera_id)--开始指定的camera\n"
            },
            {
                "name": "camera.on",
                "snippet": "camera.on(${1:id},${2:event},${3:func})",
                "description": "camera.on(id, event, func) - 注册摄像头事件回调\n传入值：\nint camera id, camera 0写0, camera 1写1\nstring 事件名称\nfunction 回调方法\n返回值：\nnil 无返回值\n例子：\ncamera.on(0, \"scanned\", function(id, str)\n--id int camera id\n--str 多种类型 false 摄像头没有正常工作，true 拍照模式下拍照成功并保存完成， int 原始数据模式下本次返回的数据大小， string 扫码模式下扫码成功后的解码值\n    print(id, str)\nend)\n"
            },
            {
                "name": "camera.start",
                "snippet": "camera.start(${1:id})",
                "description": "camera.start(id) - 开始指定的camera\n传入值：\nint camera id,例如0\n返回值：\nboolean 成功返回true,否则返回false\n例子：\ncamera.start(0)\n"
            },
            {
                "name": "camera.stop",
                "snippet": "camera.stop(${1:id})",
                "description": "camera.stop(id) - 停止指定的camera\n传入值：\nint camera id,例如0\n返回值：\nboolean 成功返回true,否则返回false\n例子：\ncamera.stop(0)\n"
            },
            {
                "name": "camera.close",
                "snippet": "camera.close(${1:id})",
                "description": "camera.close(id) - 关闭指定的camera，释放相应的IO资源\n传入值：\nint camera id,例如0\n返回值：\nboolean 成功返回true,否则返回false\n例子：\ncamera.close(0)\n"
            },
            {
                "name": "camera.capture",
                "snippet": "camera.capture(${1:id},${2:save_path},${3:quality})",
                "description": "camera.capture(id, save_path, quality) - camera拍照\n传入值：\nint camera id,例如0\nstring/zbuff/nil save_path,文件保存路径，空则写在上次路径里，默认是/capture.jpg，如果是zbuff，则将图片保存在buff内不写入文件系统\nint quality, jpeg压缩质量，1最差，占用空间小，3最高，占用空间最大而且费时间，默认1\n返回值：\nboolean 成功返回true,否则返回false,真正完成后通过camera.on设置的回调函数回调接收到的长度\n例子：\ncamera.capture(0)\n"
            },
            {
                "name": "camera.video",
                "snippet": "camera.video(${1:id},${2:w},${3:h},${4:out_path})",
                "description": "camera.video(id, w, h, out_path) - camera输出视频流到USB\n传入值：\nint camera id,例如0\nint 宽度\nint 高度\nint 输出路径，目前只能用虚拟串口0\n返回值：\nboolean 成功返回true,否则返回false\n例子：\ncamera.video(0, 320, 240, uart.VUART_0)\n"
            },
            {
                "name": "camera.startRaw",
                "snippet": "camera.startRaw(${1:id},${2:w},${3:h},${4:buff})",
                "description": "camera.startRaw(id, w, h, buff) - 启动camera输出原始数据到用户的zbuff缓存区，输出1fps后会停止，并通过camera.on设置的回调函数回调接收到的长度，如果需要再次输出，请调用camera.getRaw\n传入值：\nint camera id,例如0\nint 宽度\nint 高度\nzbuff 用于存放数据的缓存区，大小必须不小于w X h X 2 byte\n返回值：\nboolean 成功返回true,否则返回false\n例子：\ncamera.startRaw(0, 320, 240, buff)\n"
            },
            {
                "name": "camera.getRaw",
                "snippet": "camera.getRaw(${1:id})",
                "description": "camera.getRaw(id) - 再次启动camera输出原始数据到用户的zbuff缓存区，输出1fps后会停止，并通过camera.on设置的回调函数回调接收到的长度，如果需要再次输出，请继续调用本API\n传入值：\nint camera id,例如0\n返回值：\nboolean 成功返回true,否则返回false\n例子：\ncamera.getRaw(0)\n"
            },
            {
                "name": "camera.preview",
                "snippet": "camera.preview(${1:id},${2:onoff})",
                "description": "camera.preview(id, onoff) - 启停camera预览功能，直接输出到LCD上，只有硬件支持的SOC可以运行\n传入值：\nint camera id,例如0\nboolean true开启，false停止\n返回值：\nboolean 成功返回true,否则返回false\n例子：\ncamera.preview(1, true)\n"
            },
            {
                "name": "cc.lastNum",
                "snippet": "cc.lastNum()",
                "description": "cc.lastNum() - 获取最后一次通话的号码\n返回值：\nstring 获取最后一次通话的号码\n"
            },
            {
                "name": "cc.dial",
                "snippet": "cc.dial(${1:sim_id},${2:number})",
                "description": "cc.dial(sim_id, number) - 拨打电话\n传入值：\nnumber sim_id\nstring 电话号码\n返回值：\nbool 拨打电话成功与否\n"
            },
            {
                "name": "cc.hangUp",
                "snippet": "cc.hangUp(${1:sim_id})",
                "description": "cc.hangUp(sim_id) - 挂断电话\n传入值：\nnumber sim_id\n"
            },
            {
                "name": "cc.accept",
                "snippet": "cc.accept(${1:sim_id})",
                "description": "cc.accept(sim_id) - 接听电话\n传入值：\nnumber sim_id\n返回值：\nbool 接听电话成功与否\n"
            },
            {
                "name": "cc.init",
                "snippet": "cc.init(${1:multimedia_id})",
                "description": "cc.init(multimedia_id) - 初始化电话功能\n传入值：\nnumber multimedia_id 多媒体id\n返回值：\nbool 成功与否\n"
            },
            {
                "name": "cc.record",
                "snippet": "cc.record(${1:on_off},${2:upload_zbuff1},${3:upload_zbuff2},${4:download_zbuff1},${5:download_zbuff2})",
                "description": "cc.record(on_off,upload_zbuff1, upload_zbuff2, download_zbuff1, download_zbuff2) - 录音通话\n传入值：\nboolean 开启关闭通话录音功能，false或者nil关闭，其他开启\nzbuff 上行数据保存区1,zbuff创建时的空间容量必须是640的倍数,下同\nzbuff 上行数据保存区2,和上行数据保存区1组成双缓冲区\nzbuff 下行数据保存区1\nzbuff 下行数据保存区2,和下行数据保存区1组成双缓冲区\n返回值：\nbool 成功与否，如果处于通话状态，会失败\n例子：\nbuff1 = zbuff.create(6400,0,zbuff.HEAP_AUTO)\nbuff2 = zbuff.create(6400,0,zbuff.HEAP_AUTO)\nbuff3 = zbuff.create(6400,0,zbuff.HEAP_AUTO)\nbuff4 = zbuff.create(6400,0,zbuff.HEAP_AUTO)\ncc.on(\"record\", function(type, buff_point)\n log.info(type, buff_point) -- type==true是下行数据，false是上行数据 buff_point指示双缓存中返回了哪一个\nend)\ncc.record(true, buff1, buff2, buff3, buff4)\n"
            },
            {
                "name": "cc.quality",
                "snippet": "cc.quality()",
                "description": "cc.quality() - 获取当前通话质量\n返回值：\nint 1为低音质(8K)，2为高音质(16k)，0没有在通话\n"
            },
            {
                "name": "cc.on",
                "snippet": "cc.on(${1:event},${2:func})",
                "description": "cc.on(event, func) - 注册通话回调\n传入值：\nstring 事件名称 音频录音数据为\"record\"\nfunction 回调方法\n返回值：\nnil 无返回值\n例子：\ncc.on(\"record\", function(type, buff_point)\n log.info(type, buff_point) -- type==true是下行数据，false是上行数据 buff_point指示双缓存中返回了哪一个\nend)\n"
            },
            {
                "name": "codec.create",
                "snippet": "codec.create(${1:type},${2:isDecoder},${3:quality})",
                "description": "codec.create(type, isDecoder, quality) - 创建编解码用的codec\n传入值：\nint 多媒体类型，目前支持codec.MP3 codec.AMR\nboolean 是否是解码器，true解码器，false编码器，默认true，是解码器\nint 编码等级，部分bsp有内部编码器，可能需要提前输入编码等级，比如air780ep的内部amr编码器\n返回值：\nuserdata 成功返回一个数据结构,否则返回nil\n例子：\n-- 创建解码器\nlocal decoder = codec.create(codec.MP3)--创建一个mp3的decoder\n-- 创建编码器\nlocal encoder = codec.create(codec.AMR, false)--创建一个amr的encoder\n-- 创建编码器\nlocal encoder = codec.create(codec.AMR_WB, false, 8)--创建一个amr-wb的encoder，编码等级默认8\n"
            },
            {
                "name": "codec.info",
                "snippet": "codec.info(${1:decoder},${2:file_path})",
                "description": "codec.info(decoder, file_path) - decoder从文件中解析出音频信息\n传入值：\nuserdata 解码用的decoder\nstring 文件路径\n返回值：\nboolean 是否成功解析\nint 音频格式\nint 声音通道数\nint 采样频率\nint 采样位数\nboolean 是否有符号\n例子：\nlocal result, audio_format, num_channels, sample_rate, bits_per_sample, is_signed= codec.info(coder, \"xxx\")\n"
            },
            {
                "name": "codec.data",
                "snippet": "codec.data(${1:decoder},${2:out_buff})",
                "description": "codec.data(decoder, out_buff) - decoder从文件中解析出原始音频数据，比如从MP3文件里解析出PCM数据，这里的文件路径已经在codec.info传入，不需要再次传入\n传入值：\nuserdata 解码用的decoder\nzbuff 存放输出数据的zbuff，空间必须不少于16KB\nint 最少解码出多少字节的音频数据,默认16384\n返回值：\nboolean 是否成功解析\n例子：\n-- 大内存设备\nlocal buff = zbuff.create(16*1024)\nlocal result = codec.data(coder, buff)\n-- 小内存设备\nlocal buff = zbuff.create(8*1024)\nlocal result = codec.data(coder, buff, 4096)\n"
            },
            {
                "name": "codec.encode",
                "snippet": "codec.encode(${1:coder},${2:in_buffer},${3:out_buffer},${4:mode})",
                "description": "codec.encode(coder, in_buffer, out_buffer, mode) - 编码音频数据，由于flash和ram空间一般比较有限，除了部分bsp有内部amr编码功能，目前只支持amr-nb编码\n传入值：\nuserdata codec.create创建的编解码用的coder\nzbuff 输入的数据,zbuff形式,从0到used\nzbuff 输出的数据,zbuff形式,自动添加到buff的尾部,如果空间大小不足,会自动扩展,但是会额外消耗时间,甚至会失败,所以尽量一开始就给足空间\nint amr_nb的编码等级 0~7(即 MR475~MR122)值越大消耗的空间越多,音质越高,默认0 amr_wb的编码等级 0~8,值越大消耗的空间越多,音质越高,默认0\n返回值：\nboolean 成功返回true,失败返回false\n例子：\ncodec.encode(amr_coder, inbuf, outbuf, codec.AMR_)\n"
            },
            {
                "name": "codec.release",
                "snippet": "codec.release(${1:coder})",
                "description": "codec.release(coder) - 释放编解码用的coder\n传入值：\ncoder codec.create创建的编解码用的coder\n例子：\ncodec.release(coder)\n"
            },
            {
                "name": "coremark.run",
                "snippet": "coremark.run()",
                "description": "coremark.run() - 开始跑分\n返回值：\nnil 无返回值,结果直接打印在日志中\n例子：\n-- 大部分情况下, 这个库都不会包含在正式版固件里\n-- 若需使用,可以参考wiki文档自行编译或使用云编译\n-- https://wiki.luatos.com/develop/compile.html\n\n-- 跑分的main.lua 应移除硬狗代码, 防止重启\n-- 若设备支持自动休眠, 应关闭休眠功能\n-- 若设备支持更多的频率运行, 建议设置到最高频率\n-- 使用 -O3 比 -O2 -Os 的分数更高, 通常情况下\n\n-- 会一直独占线程到执行完毕, 然后在控制台输出结果\ncoremark.run()\n\n-- 跑分图一乐^_^\n\n"
            },
            {
                "name": "crypto.md5",
                "snippet": "crypto.md5(${1:str})",
                "description": "crypto.md5(str) - 计算md5值\n传入值：\nstring 需要计算的字符串\n返回值：\nstring 计算得出的md5值的hex字符串\n例子：\n-- 计算字符串\"abc\"的md5\nlog.info(\"md5\", crypto.md5(\"abc\"))\n"
            },
            {
                "name": "crypto.hmac_md5",
                "snippet": "crypto.hmac_md5(${1:str},${2:key})",
                "description": "crypto.hmac_md5(str, key) - 计算hmac_md5值\n传入值：\nstring 需要计算的字符串\nstring 密钥\n返回值：\nstring 计算得出的hmac_md5值的hex字符串\n例子：\n-- 计算字符串\"abc\"的hmac_md5\nlog.info(\"hmac_md5\", crypto.hmac_md5(\"abc\", \"1234567890\"))\n"
            },
            {
                "name": "crypto.sha1",
                "snippet": "crypto.sha1(${1:str})",
                "description": "crypto.sha1(str) - 计算sha1值\n传入值：\nstring 需要计算的字符串\n返回值：\nstring 计算得出的sha1值的hex字符串\n例子：\n-- 计算字符串\"abc\"的sha1\nlog.info(\"sha1\", crypto.sha1(\"abc\"))\n"
            },
            {
                "name": "crypto.hmac_sha1",
                "snippet": "crypto.hmac_sha1(${1:str},${2:key})",
                "description": "crypto.hmac_sha1(str, key) - 计算hmac_sha1值\n传入值：\nstring 需要计算的字符串\nstring 密钥\n返回值：\nstring 计算得出的hmac_sha1值的hex字符串\n例子：\n-- 计算字符串\"abc\"的hmac_sha1\nlog.info(\"hmac_sha1\", crypto.hmac_sha1(\"abc\", \"1234567890\"))\n"
            },
            {
                "name": "crypto.sha256",
                "snippet": "crypto.sha256(${1:str})",
                "description": "crypto.sha256(str) - 计算sha256值\n传入值：\nstring 需要计算的字符串\n返回值：\nstring 计算得出的sha256值的hex字符串\n例子：\n-- 计算字符串\"abc\"的sha256\nlog.info(\"sha256\", crypto.sha256(\"abc\"))\n"
            },
            {
                "name": "crypto.hmac_sha256",
                "snippet": "crypto.hmac_sha256(${1:str},${2:key})",
                "description": "crypto.hmac_sha256(str, key) - 计算hmac_sha256值\n传入值：\nstring 需要计算的字符串\nstring 密钥\n返回值：\nstring 计算得出的hmac_sha256值的hex字符串\n例子：\n-- 计算字符串\"abc\"的hmac_sha256\nlog.info(\"hmac_sha256\", crypto.hmac_sha256(\"abc\", \"1234567890\"))\n"
            },
            {
                "name": "crypto.sha512",
                "snippet": "crypto.sha512(${1:str})",
                "description": "crypto.sha512(str) - 计算sha512值\n传入值：\nstring 需要计算的字符串\n返回值：\nstring 计算得出的sha512值的hex字符串\n例子：\n-- 计算字符串\"abc\"的sha512\nlog.info(\"sha512\", crypto.sha512(\"abc\"))\n"
            },
            {
                "name": "crypto.hmac_sha512",
                "snippet": "crypto.hmac_sha512(${1:str},${2:key})",
                "description": "crypto.hmac_sha512(str, key) - 计算hmac_sha512值\n传入值：\nstring 需要计算的字符串\nstring 密钥\n返回值：\nstring 计算得出的hmac_sha512值的hex字符串\n例子：\n-- 计算字符串\"abc\"的hmac_sha512\nlog.info(\"hmac_sha512\", crypto.hmac_sha512(\"abc\", \"1234567890\"))\n"
            },
            {
                "name": "crypto.cipher_encrypt",
                "snippet": "crypto.cipher_encrypt(${1:type},${2:padding},${3:str},${4:key},${5:iv})",
                "description": "crypto.cipher_encrypt(type, padding, str, key, iv) - 对称加密\n传入值：\nstring 算法名称, 例如 AES-128-ECB/AES-128-CBC, 可查阅crypto.cipher_list()\nstring 对齐方式, 支持PKCS7/ZERO/ONE_AND_ZEROS/ZEROS_AND_LEN/NONE\nstring 需要加密的数据\nstring 密钥,需要对应算法的密钥长度\nstring IV值, 非ECB算法需要\n返回值：\nstring 加密后的字符串\n例子：\n-- 计算AES\nlocal data = crypto.cipher_encrypt(\"AES-128-ECB\", \"PKCS7\", \"1234567890123456\", \"1234567890123456\")\nlocal data2 = crypto.cipher_encrypt(\"AES-128-CBC\", \"PKCS7\", \"1234567890123456\", \"1234567890123456\", \"1234567890666666\")\n"
            },
            {
                "name": "crypto.cipher_decrypt",
                "snippet": "crypto.cipher_decrypt(${1:type},${2:padding},${3:str},${4:key},${5:iv})",
                "description": "crypto.cipher_decrypt(type, padding, str, key, iv) - 对称解密\n传入值：\nstring 算法名称, 例如 AES-128-ECB/AES-128-CBC, 可查阅crypto.cipher_list()\nstring 对齐方式, 支持PKCS7/ZERO/ONE_AND_ZEROS/ZEROS_AND_LEN/NONE\nstring 需要解密的数据\nstring 密钥,需要对应算法的密钥长度\nstring IV值, 非ECB算法需要\n返回值：\nstring 解密后的字符串\n例子：\n-- 用AES加密,然后用AES解密\nlocal data = crypto.cipher_encrypt(\"AES-128-ECB\", \"PKCS7\", \"1234567890123456\", \"1234567890123456\")\nlocal data2 = crypto.cipher_decrypt(\"AES-128-ECB\", \"PKCS7\", data, \"1234567890123456\")\n-- data的hex为 757CCD0CDC5C90EADBEEECF638DD0000\n-- data2的值为 1234567890123456\n"
            },
            {
                "name": "crypto.crc16",
                "snippet": "crypto.crc16(${1:method},${2:data},${3:poly},${4:initial},${5:finally},${6:inReversemoutReverse})",
                "description": "crypto.crc16(method, data, poly, initial, finally, inReversem outReverse) - 计算CRC16\n传入值：\nstring CRC16模式（\"IBM\",\"MAXIM\",\"USB\",\"MODBUS\",\"CCITT\",\"CCITT-FALSE\",\"X25\",\"XMODEM\",\"DNP\",\"USER-DEFINED\"）\nstring 字符串\nint poly值\nint initial值\nint finally值\nint 输入反转,1反转,默认0不反转\nint 输入反转,1反转,默认0不反转\n返回值：\nint 对应的CRC16值\n例子：\n-- 计算CRC16\nlocal crc = crypto.crc16(\"\")\n"
            },
            {
                "name": "crypto.crc16_modbus",
                "snippet": "crypto.crc16_modbus(${1:data},${2:start})",
                "description": "crypto.crc16_modbus(data, start) - 直接计算modbus的crc16值\n传入值：\nstring 数据\nint 初始化值,默认0xFFFF\n返回值：\nint 对应的CRC16值\n例子：\n-- 计算CRC16 modbus\nlocal crc = crypto.crc16_modbus(data)\n-- 2023.11.06 新增初始值设置\ncrc = crypto.crc16_modbus(data, 0xFFFF)\n"
            },
            {
                "name": "crypto.crc32",
                "snippet": "crypto.crc32(${1:data})",
                "description": "crypto.crc32(data) - 计算crc32值\n传入值：\nstring 数据\n返回值：\nint 对应的CRC32值\n例子：\n-- 计算CRC32\nlocal crc = crypto.crc32(data)\n"
            },
            {
                "name": "crypto.crc8",
                "snippet": "crypto.crc8(${1:data},${2:poly},${3:start},${4:revert})",
                "description": "crypto.crc8(data, poly, start, revert) - 计算crc8值\n传入值：\nstring 数据\nint crc多项式，可选，如果不写，将忽略除了数据外所有参数\nint crc初始值，可选，默认0\nboolean 是否需要逆序处理，默认否\n返回值：\nint 对应的CRC8值\n例子：\n-- 计算CRC8\nlocal crc = crypto.crc8(data)\nlocal crc = crypto.crc8(data, 0x31, 0xff, false)\n"
            },
            {
                "name": "crypto.crc7",
                "snippet": "crypto.crc7(${1:data},${2:poly},${3:start})",
                "description": "crypto.crc7(data, poly, start) - 计算crc7值\n传入值：\nstring 数据\nint crc多项式，可选，默认0xE5\nint crc初始值，可选，默认0x00\n返回值：\nint 对应的CRC7值\n例子：\n-- 计算CRC7, 本API于2023.10.07新增\nlocal crc = crypto.crc7(data)\nlocal crc = crypto.crc7(data, 0x31, 0xff)\n"
            },
            {
                "name": "crypto.trng",
                "snippet": "crypto.trng(${1:len})",
                "description": "crypto.trng(len) - 生成真随机数\n传入值：\nint 数据长度\n返回值：\nstring 指定随机数字符串\n例子：\n-- 生成32位随机数ir\nlocal r = crypto.trng(4)\nlocal _, ir = pack.unpack(r, \"I\")\n"
            },
            {
                "name": "crypto.totp",
                "snippet": "crypto.totp(${1:secret},${2:time})",
                "description": "crypto.totp(secret,time) - 计算TOTP动态密码的结果\n传入值：\nstring 网站提供的密钥（就是BASE32编码后的结果）\nint 可选，时间戳，默认当前时间\n返回值：\nint 计算得出的六位数结果 计算失败返回nil\n例子：\n--使用当前系统时间计算\nlocal otp = crypto.totp(\"asdfassdfasdfass\")\n"
            },
            {
                "name": "crypto.base64_encode",
                "snippet": "crypto.base64_encode(${1:data})",
                "description": "crypto.base64_encode(data) - 将数据进行base64编码\n传入值：\nstring 待编码的数据\n返回值：\nstring 编码后的数据\n例子：\n-- 本函数与 string.toBase64 是同一个\nlocal data = \"123\"\nlocal bdata = crypto.base64_encode(data)\nlog.info(\"base64\", \"encode\", data, bdata)\ndata = crypto.base64_decode(data)\nlog.info(\"base64\", \"decode\", data, bdata)\n"
            },
            {
                "name": "crypto.base64_decode",
                "snippet": "crypto.base64_decode(${1:data})",
                "description": "crypto.base64_decode(data) - 将数据进行base64解码\n传入值：\nstring 待解码的数据\n返回值：\nstring 解码后的数据\n例子：\n-- 本函数与 string.fromBase64 是同一个\nlocal data = \"123\"\nlocal bdata = crypto.base64_encode(data)\nlog.info(\"base64\", \"encode\", data, bdata)\ndata = crypto.base64_decode(data)\nlog.info(\"base64\", \"decode\", data, bdata)\n"
            },
            {
                "name": "crypto.cipher_list",
                "snippet": "crypto.cipher_list()",
                "description": "crypto.cipher_list() - 获取当前固件支持的cipher列表\n返回值：\ntable 本固件支持的cipher列表,字符串数组\n例子：\n-- 本API于2022.07.27添加\nlocal ciphers = crypto.cipher_list()\nif ciphers then\n    log.info(\"crypto\", \"ciphers list\", json.encode(ciphers))\nend\n"
            },
            {
                "name": "crypto.cipher_suites",
                "snippet": "crypto.cipher_suites()",
                "description": "crypto.cipher_suites() - 获取当前固件支持的cipher suites列表\n返回值：\ntable 本固件支持的cipher suites列表,字符串数组\n例子：\n-- 本API于2022.11.16添加\nlocal suites = crypto.cipher_suites()\nif suites then\n    log.info(\"crypto\", \"ciphers suites\", json.encode(suites))\nend\n"
            },
            {
                "name": "crypto.md_file",
                "snippet": "crypto.md_file(${1:tp},${2:path},${3:hmac})",
                "description": "crypto.md_file(tp, path, hmac) - 计算文件的hash值(md5/sha1/sha256及hmac形式)\n传入值：\nstring hash类型, 大小字母, 例如 \"MD5\" \"SHA1\" \"SHA256\"\nstring 文件路径, 例如 /luadb/logo.jpg\nstring hmac值,可选\n返回值：\nstring HEX过的hash值,若失败会无返回值\n例子：\n\n-- 无hmac的hash值\nlog.info(\"md5\", crypto.md_file(\"MD5\", \"/luadb/logo.jpg\"))\nlog.info(\"sha1\", crypto.md_file(\"SHA1\", \"/luadb/logo.jpg\"))\nlog.info(\"sha256\", crypto.md_file(\"SHA256\", \"/luadb/logo.jpg\"))\n\n-- 带hmac的hash值\nlog.info(\"hmac_md5\", crypto.md_file(\"MD5\", \"/luadb/logo.jpg\", \"123456\"))\nlog.info(\"hmac_sha1\", crypto.md_file(\"SHA1\", \"/luadb/logo.jpg\", \"123456\"))\nlog.info(\"hmac_sha256\", crypto.md_file(\"SHA256\", \"/luadb/logo.jpg\", \"123456\"))\n"
            },
            {
                "name": "crypto.md",
                "snippet": "crypto.md(${1:tp},${2:data},${3:hmac})",
                "description": "crypto.md(tp, data, hmac) - 计算数据的hash值(md5/sha1/sha256及hmac形式)\n传入值：\nstring hash类型, 大小字母, 例如 \"MD5\" \"SHA1\" \"SHA256\"\nstring 待处理的数据\nstring hmac值,可选\n返回值：\nstring HEX过的hash值,若失败会无返回值\n例子：\n\n-- 无hmac的hash值\nlog.info(\"md5\", crypto.md(\"MD5\", \"1234567890\"))\nlog.info(\"sha1\", crypto.md(\"SHA1\", \"1234567890\"))\nlog.info(\"sha256\", crypto.md(\"SHA256\", \"1234567890\"))\n\n-- 带hmac的hash值\nlog.info(\"hmac_md5\", crypto.md(\"MD5\", \"1234567890\", \"123456\"))\nlog.info(\"hmac_sha1\", crypto.md(\"SHA1\", \"1234567890\", \"123456\"))\nlog.info(\"hmac_sha256\", crypto.md(\"SHA256\", \"1234567890\", \"123456\"))\n"
            },
            {
                "name": "crypto.hash_init",
                "snippet": "crypto.hash_init(${1:tp})",
                "description": "crypto.hash_init(tp) - 创建流式hash用的stream\n传入值：\nstring hash类型, 大写字母, 例如 \"MD5\" \"SHA1\" \"SHA256\"\nstring hmac值，可选\n返回值：\nuserdata 成功返回一个数据结构,否则返回nil\n例子：\n-- 无hmac的hash stream\nlocal md5_stream = crypto.hash_init(\"MD5\")\nlocal sha1_stream = crypto.hash_init(\"SHA1\")\nlocal sha256_stream = crypto.hash_init(\"SHA256\")\n\n-- 带hmac的hash stream\nlocal md5_stream = crypto.hash_init(\"MD5\", \"123456\")\nlocal sha1_stream = crypto.hash_init(\"SHA1\", \"123456\")\nlocal sha256_stream = crypto.hash_init(\"SHA256\", \"123456\")\n"
            },
            {
                "name": "crypto.hash_update",
                "snippet": "crypto.hash_update(${1:stream},${2:data})",
                "description": "crypto.hash_update(stream, data) - 流式hash更新数据\n传入值：\nuserdata crypto.hash_init()创建的stream, 必选\nstring 待计算的数据,必选\nreturn 无\n例子：\ncrypto.hash_update(stream, \"OK\")\n"
            },
            {
                "name": "crypto.hash_finish",
                "snippet": "crypto.hash_finish(${1:stream})",
                "description": "crypto.hash_finish(stream) - 获取流式hash校验值并释放创建的stream\n传入值：\nuserdata crypto.hash_init()创建的stream,必选\n返回值：\nstring 成功返回计算得出的流式hash值的hex字符串，失败无返回\n例子：\nlocal hashResult = crypto.hash_finish(stream)\n"
            },
            {
                "name": "crypto.checksum",
                "snippet": "crypto.checksum(${1:data},${2:mode})",
                "description": "crypto.checksum(data, mode) - 计算checksum校验和\n传入值：\nstring 待计算的数据,必选\nint 模式,累加模式, 0 - 异或, 1 - 累加, 默认为0\n返回值：\nint checksum值,校验和\n例子：\n-- 本函数在 2022.12.28 添加\n-- 单纯计算checksum值\nlocal ck = crypto.checksum(\"OK\")\nlog.info(\"checksum\", \"ok\", string.format(\"%02X\", ck))\n-- 第二个参数mode在2023.5.23日添加\n"
            },
            {
                "name": "dac.open",
                "snippet": "dac.open(${1:ch},${2:freq},${3:mode})",
                "description": "dac.open(ch, freq, mode) - 打开DAC通道,并配置参数\n传入值：\nint 通道编号,例如0\nint 输出频率,单位hz\nint 模式,默认为0,预留\n返回值：\ntrue 成功返回true,否则返回false\nint 底层返回值,调试用\n例子：\nif dac.open(0, 44000) then\n    log.info(\"dac\", \"dac ch0 is opened\")\nend\n\n"
            },
            {
                "name": "dac.write",
                "snippet": "dac.write(${1:ch},${2:data})",
                "description": "dac.write(ch, data) - 从指定DAC通道输出一段波形,或者单个值\n传入值：\nint 通道编号,例如0\nstring 若输出固定值,可以填数值, 若输出波形,填string\n返回值：\ntrue 成功返回true,否则返回false\nint 底层返回值,调试用\n例子：\nif dac.open(0, 44000) then\n    log.info(\"dac\", \"dac ch0 is opened\")\n    dac.write(0, string.fromHex(\"ABCDABCD\"))\nend\ndac.close(0)\n"
            },
            {
                "name": "dac.close",
                "snippet": "dac.close(${1:ch})",
                "description": "dac.close(ch) - 关闭DAC通道\n传入值：\nint 通道编号,例如0\n返回值：\ntrue 成功返回true,否则返回false\nint 底层返回值,调试用\n例子：\nif dac.open(0, 44000) then\n    log.info(\"dac\", \"dac ch0 is opened\")\n    dac.write(0, string.fromHex(\"ABCDABCD\"))\nend\ndac.close(0)\n"
            },
            {
                "name": "disp.init",
                "snippet": "disp.init(${1:conf})",
                "description": "disp.init(conf) - 显示屏初始化,请使用u8g2库\n传入值：\ntable conf 配置信息\n返回值：\nint 正常初始化1,已经初始化过2,内存不够3,初始化失败返回4\n例子：\n-- disp库的所有API均已合并到u8g2库\n-- disp库已经映射为u8g2库,所有API均代理到u8g2,请查阅u8g2库的API\n"
            },
            {
                "name": "eink.init",
                "snippet": "eink.init(${1:tp},${2:args},${3:spi_device})",
                "description": "eink.init(tp, args,spi_device) - eink显示屏初始化\n传入值：\nnumber eink类型，当前支持：https://wiki.luatos.com/api/eink.html#id1\ntable 附加参数,与具体设备有关：<br>pin_busy（busy）<br>port：spi端口,例如0,1,2...如果为device方式则为\"device\"<br>pin_dc：eink数据/命令选择引脚<br>pin_rst：eink复位引脚\nuserdata spi设备,当port = \"device\"时有效\n例子：\n-- 初始化spi0的eink.MODEL_4in2bc) 注意:eink初始化之前需要先初始化spi\nspi_eink = spi.deviceSetup(0,20,0,0,8,20000000,spi.MSB,1,1)\nlog.info(\"eink.init\",\neink.init(eink.MODEL_4in2bc,{port = \"device\",pin_dc = 17, pin_pwr = 7,pin_rst = 19,direction = 2,w = 160,h = 80,xoffset = 1,yoffset = 26},spi_eink))\n"
            },
            {
                "name": "eink.setup",
                "snippet": "eink.setup(${1:full},${2:spiid},${3:pin_busy},${4:pin_reset},${5:pin_dc},${6:pin_cs})",
                "description": "eink.setup(full, spiid, pin_busy, pin_reset, pin_dc, pin_cs) - 初始化eink\n传入值：\nint 全屏刷新0,局部刷新1,默认是全屏刷新\nint 所在的spi,默认是0\nint Busy 忙信号管脚\nint Reset 复位管脚\nint DC 数据命令选择管脚\nint CS 使能管脚\n返回值：\nboolean 成功返回true,否则返回false\n"
            },
            {
                "name": "eink.sleep",
                "snippet": "eink.sleep()",
                "description": "eink.sleep() - 进入休眠模式，再次使用时需要重新初始化\n"
            },
            {
                "name": "eink.clear",
                "snippet": "eink.clear(${1:color},${2:force})",
                "description": "eink.clear(color, force) - 清除绘图缓冲区，默认不会马上刷新到设备\n传入值：\nnumber color 可选，默认1。刷屏颜色\nbool force 可选，默认false。如果为true则马上清屏\n返回值：\nnil 无返回值\n"
            },
            {
                "name": "eink.setWin",
                "snippet": "eink.setWin(${1:width},${2:height},${3:rotate})",
                "description": "eink.setWin(width, height, rotate) - 设置窗口\n传入值：\nint width  宽度\nint height 高度\nint rotate 显示方向,0/1/2/3, 相当于旋转0度/90度/180度/270度\n返回值：\nnil 无返回值\n"
            },
            {
                "name": "eink.getWin",
                "snippet": "eink.getWin()",
                "description": "eink.getWin() - 获取窗口信息\n返回值：\nint width  宽\nint height 高\nint rotate 旋转方向\n"
            },
            {
                "name": "eink.setFont",
                "snippet": "eink.setFont(${1:font})",
                "description": "eink.setFont(font) - 设置字体\n传入值：\nuserdata 字体\n例子：\n-- 设置为字体,对之后的print有效\neink.setFont(eink.font_opposansm12_chinese)\n"
            },
            {
                "name": "eink.print",
                "snippet": "eink.print(${1:x},${2:y},${3:str},${4:colored})",
                "description": "eink.print(x, y, str, colored) - 绘制字符串\n传入值：\nint x坐标\nint y坐标\nstring 字符串\nint 颜色, 可以是0或者1, 默认是0\n返回值：\nnil 无返回值\n例子：\n-- 先设置字体, 然后写字\n-- 可用字体取决于具体的固件, 如果没有你想要的大小,可以云编译一份自定义固件\n-- font_opposansm8_chinese\n-- font_opposansm10_chinese\n-- font_opposansm12_chinese\n-- font_opposansm14_chinese\n-- font_opposansm16_chinese\neink.setFont(eink.font_opposansm12_chinese)\neink.print(10, 20, \"LuatOS\")\n"
            },
            {
                "name": "eink.show",
                "snippet": "eink.show(${1:x},${2:y},${3:noClear})",
                "description": "eink.show(x, y, noClear) - 将缓冲区图像输出到屏幕\n传入值：\nint x 输出的x坐标,默认0\nint y 输出的y坐标,默认0\nbool 可选，默认false。如果为true则不进行清屏，直接刷上新内容\n返回值：\nnil 无返回值\n"
            },
            {
                "name": "eink.draw",
                "snippet": "eink.draw(${1:buff},${2:buff2},${3:noclear})",
                "description": "eink.draw(buff, buff2, noclear) - 直接输出数据到屏幕,支持双色数据\n传入值：\nuserdata zbuff指针\nuserdata zbuff指针\nbool 可选，默认false。如果为true则不进行清屏，直接刷上新内容\n返回值：\nnil 无返回值\n"
            },
            {
                "name": "eink.line",
                "snippet": "eink.line(${1:x},${2:y},${3:x2},${4:y2},${5:colored})",
                "description": "eink.line(x, y, x2, y2, colored) - 缓冲区绘制线\n传入值：\nint 起点x坐标\nint 起点y坐标\nint 终点x坐标\nint 终点y坐标\n返回值：\nnil 无返回值\n例子：\neink.line(0, 0, 10, 20, 0)\n"
            },
            {
                "name": "eink.rect",
                "snippet": "eink.rect(${1:x},${2:y},${3:x2},${4:y2},${5:colored},${6:fill})",
                "description": "eink.rect(x, y, x2, y2, colored, fill) - 缓冲区绘制矩形\n传入值：\nint 左上顶点x坐标\nint 左上顶点y坐标\nint 右下顶点x坐标\nint 右下顶点y坐标\nint 默认是0\nint 是否填充,默认是0,不填充\n返回值：\nnil 无返回值\n例子：\neink.rect(0, 0, 10, 20)\neink.rect(0, 0, 10, 20,0, 1) -- Filled\n"
            },
            {
                "name": "eink.circle",
                "snippet": "eink.circle(${1:x},${2:y},${3:radius},${4:colored},${5:fill})",
                "description": "eink.circle(x, y, radius, colored, fill) - 缓冲区绘制圆形\n传入值：\nint 圆心x坐标\nint 圆心y坐标\nint 半径\nint 默认是0\nint 是否填充,默认是0,不填充\n返回值：\nnil 无返回值\n例子：\neink.circle(0, 0, 10)\neink.circle(0, 0, 10, 1, 1) -- Filled\n"
            },
            {
                "name": "eink.qrcode",
                "snippet": "eink.qrcode(${1:x},${2:y},${3:str},${4:size})",
                "description": "eink.qrcode(x, y, str, size) - 缓冲区绘制QRCode\n传入值：\nint x坐标\nint y坐标\nstring 二维码的内容\nint 显示大小 (注意:二维码生成大小与要显示内容和纠错等级有关,生成版本为1-40(对应 21x21 - 177x177)的不定大小,如果和设置大小不同会自动在指定的区域中间显示二维码,如二维码未显示请查看日志提示)\n返回值：\nnil 无返回值\n"
            },
            {
                "name": "eink.bat",
                "snippet": "eink.bat(${1:x},${2:y},${3:bat})",
                "description": "eink.bat(x, y, bat) - 缓冲区绘制电池\n传入值：\nint x坐标\nint y坐标\nint 电池电压,单位毫伏\n返回值：\nnil 无返回值\n"
            },
            {
                "name": "eink.weather_icon",
                "snippet": "eink.weather_icon(${1:x},${2:y},${3:code})",
                "description": "eink.weather_icon(x, y, code) - 缓冲区绘制天气图标\n传入值：\nint x坐标\nint y坐标\nint 天气代号\n返回值：\nnil 无返回值\n"
            },
            {
                "name": "eink.model",
                "snippet": "eink.model(${1:m})",
                "description": "eink.model(m) - 设置墨水屏驱动型号\n传入值：\nint 型号名称, 例如 eink.model(eink.MODEL_1in54_V2)\n返回值：\nnil 无返回值\n"
            },
            {
                "name": "eink.drawXbm",
                "snippet": "eink.drawXbm(${1:x},${2:y},${3:w},${4:h},${5:data})",
                "description": "eink.drawXbm(x, y, w, h, data) - 绘制位图\n传入值：\nint X坐标\nint y坐标\nint 位图宽\nint 位图高\nint 位图数据,每一位代表一个像素\n例子：\n-- 取模使用PCtoLCD2002软件即可\n-- 在(0,0)为左上角,绘制 16x16 \"今\" 的位图\neink.drawXbm(0, 0, 16,16, string.char(\n    0x80,0x00,0x80,0x00,0x40,0x01,0x20,0x02,0x10,0x04,0x48,0x08,0x84,0x10,0x83,0x60,\n    0x00,0x00,0xF8,0x0F,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0x02,0x00,0x01,0x80,0x00\n))\n"
            },
            {
                "name": "eink.setCtx",
                "snippet": "eink.setCtx(${1:index})",
                "description": "eink.setCtx(index) - 切换颜色画板, 适合多色墨水屏\n传入值：\nint 颜色索引, 黑色为0, 红色为1\n例子：\n-- 仅适合多色墨水屏, 对单色墨水屏(只有黑白)的无效\neink.setCtx(1)\n-- 切换后, 所有drawXXX都会操作在指定颜色的画板\n"
            },
            {
                "name": "eink.async",
                "snippet": "eink.async(${1:index})",
                "description": "eink.async(index) - 异步方式，使用此方式需要先 require(\"sysplus\") 之后 eink.clear().wait() eink.show().wait()进行刷屏\n传入值：\nint 1 使用异步\n例子：\n    eink.async(1)\n    spi_eink = spi.deviceSetup(spi_id,pin_cs,0,0,8,20*1000*1000,spi.MSB,1,1)\n    eink.init(eink.MODEL_1in54,\n            {port = \"device\",pin_dc = pin_dc, pin_busy = pin_busy,pin_rst = pin_reset},\n            spi_eink)\n    eink.setWin(200, 200, 0)\n    sys.wait(100)\n    log.info(\"e-paper 1.54\", \"Testing Go\")\n    eink.print(30, 20, \"LuatOS-AIR780E\",0x00)\n    eink.show().wait()\n    log.info(\"e-paper 1.54\", \"Testing End\")\n"
            },
            {
                "name": "ercoap.parse",
                "snippet": "ercoap.parse(${1:data})",
                "description": "ercoap.parse(data) - 解析coap数据包\n传入值：\nstring coap数据包\n返回值：\ntable 成功返回table,否则返回nil\n例子：\n-- 本函数是解析coap数据包\nlocal rcoap = ercoap.parse(data)\nif rcoap then\n    log.info(\"coap\", rcoap.type, rcoap.code, rcoap.payload)\n    -- rcoap的属性\n    -- type 消息类型, 0 - CON 需要答复, 1 - NON 无需答复, 2 - ACK 已收到, 3 - RST 出错了\n    -- msgid 消息id\n    -- payload 携带的数据\n    -- code 类似于http的statue code, 通过有 2xx 正常, 4xx 出错了\nelse\n    log.info(\"ercoap\", \"数据包解析失败\")\nend\n"
            },
            {
                "name": "ercoap.print",
                "snippet": "ercoap.print(${1:data})",
                "description": "ercoap.print(data) - 打印coap数据包\n传入值：\nstring coap数据包\n返回值：\nboolean 解析成功返回true\n例子：\n-- 本函数单纯就打印一下coap数据包\n"
            },
            {
                "name": "ercoap.onenet",
                "snippet": "ercoap.onenet(${1:tp},${2:product_id},${3:device_name},${4:token},${5:payload})",
                "description": "ercoap.onenet(tp, product_id, device_name, token, payload) - 快速生成onenet数据包\n传入值：\nstring 请求类型,作为reply时可选,其他情况必选\nstring 项目id,必须填写\nstring 设备名称,必须填写\nstring token,必须填写\nstring 物模型json字符串,可选\n返回值：\nstring 合成好的数据包,可通过UDP上行\n例子：\n-- 参考文档: coap接入 https://open.iot.10086.cn/doc/v5/fuse/detail/924\n-- 参考文档: 物模型 https://open.iot.10086.cn/doc/v5/fuse/detail/902\n\n-- 类型 tp值 token来源 payload\n-- 登陆 login iotauth.onenet函数生成 无\n-- 心跳 keep_live iotauth.onenet函数生成 无\n-- 登出 logout iotauth.onenet函数生成 无\n-- 属性上报 thing/property/post login时获取 必须有\n-- 属性回复 thing/property/reply login时获取 必须有\n-- 事件上报 thing/event/post login时获取 必须有\n-- 远程调用答复 无 login时获取 必须有\n"
            },
            {
                "name": "errDump.dump",
                "snippet": "errDump.dump(${1:zbuff},${2:type},${3:isDelete})",
                "description": "errDump.dump(zbuff, type, isDelete) - 手动读取异常日志，主要用于用户将日志发送给自己的服务器而不是IOT平台，如果在errDump.config配置了周期上传，则不能使用本函数\n传入值：\nzbuff 日志信息缓存，如果为nil就不会读出，一般当\nint 日志类型，目前只有errDump.TYPE_SYS和errDump.TYPE_USR\nboolean 是否删除日志\n返回值：\nboolean true表示本次读取前并没有写入数据，false反之，在删除日志前，最好再读一下确保没有新的数据写入了\n例子：\nlocal result = errDump.dump(buff, errDump.TYPE_SYS, false) --读出系统记录的异常日志\nlocal result = errDump.dump(nil, errDump.TYPE_SYS, true) --清除系统记录的异常日志\n"
            },
            {
                "name": "errDump.record",
                "snippet": "errDump.record(${1:string})",
                "description": "errDump.record(string) - 写入用户的异常日志，注意最大只有4KB，超过部分新的覆盖旧的，开启自动上传后会上传到合宙IOT平台\n传入值：\nstring 日志\n返回值：\nnil 无返回值\n例子：\nerrDump.record(\"socket long time no connect\") --记录下\"socket long time no connect\"\n"
            },
            {
                "name": "errDump.config",
                "snippet": "errDump.config(${1:enable},${2:period},${3:user_flag},${4:custom_id},${5:host},${6:port})",
                "description": "errDump.config(enable, period, user_flag, custom_id, host, port) - 配置关键日志上传IOT平台，这里的日志包括引起luavm异常退出的日志和用户通过record写入的日志，类似于air的errDump\n传入值：\nboolean 是否启用记录功能，false的话将不会记录任何日志\nint 定时上传周期，单位秒，默认600秒，这个是自动上传时候后的重试时间时间，在开机后或者有record操作后会很快尝试上传到合宙IOT平台一次，如果为0，则不会上传，由用户dump后自己上传自己的平台\nstring 用户的特殊标识，可以为空\nstring 设备识别号, 4G设备默认是imei,其他设备默认是mcu.unique_id\nstring 服务器域名,默认dev_msg1.openluat.com\nint 服务器端口,默认\n返回值：\nnil 无返回值\n例子：\nerrDump.config(true, 3600, \"12345678\")    --一个小时尝试上次一次，上传时会在imei后附加上12345678\nerrDump.config(false)    --关闭记录功能，不再上传\nerrDump.config(true, 0)    --记录，但是不会主动上传，由用户实现上传功能\n\n-- 2023.09.22新增custom_id参数\nerrDump.config(true, 3600, nil, \"ABC\")    --一个小时尝试上次一次，上传时使用自定义的设备识别号ABC\n\n-- 2023.12.8 新增host和port参数\nerrDump.config(true, 3600, nil, nil, \"dev_msg1.openluat.com\", 12425)\n"
            },
            {
                "name": "fastlz.compress",
                "snippet": "fastlz.compress(${1:data},${2:level})",
                "description": "fastlz.compress(data, level) - 快速压缩\n传入值：\nstring 待压缩的数据, 少于400字节的数据不建议压缩, 且压缩后的数据不能大于32k\nint 压缩级别,默认1, 可选1或者2, 2的压缩比更高(有时候)\n返回值：\nstring 若压缩成功,返回数据字符串, 否则返回nil\n例子：\n-- 注意, 压缩过程的内存消耗如下\n-- 系统内存, 固定32k\n-- lua内存, 原始数据的大小的1.05倍,最小占用1024字节.\n"
            },
            {
                "name": "fastlz.uncompress",
                "snippet": "fastlz.uncompress(${1:data},${2:maxout})",
                "description": "fastlz.uncompress(data, maxout) - 快速解压\n传入值：\nstring 待解压的数据\nint 解压后的最大大小, 默认是4k, 可按需调整\n返回值：\nstring 若解压成功,返回数据字符串, 否则返回nil\n"
            },
            {
                "name": "fatfs.mount",
                "snippet": "fatfs.mount(${1:mode},${2:mount_point},${3:spiid_or_spidevice},${4:spi_cs},${5:spi_speed},${6:power_pin},${7:power_on_delay},${8:auto_format})",
                "description": "fatfs.mount(mode,mount_point, spiid_or_spidevice, spi_cs, spi_speed, power_pin, power_on_delay, auto_format) - 挂载fatfs\n传入值：\nint fatfs模式,可选fatfs.SPI,fatfs.SDIO,fatfs.RAM,fatfs.USB\nstring 虚拟文件系统的挂载点, 默认是 /fatfs\nint 传入spi device指针,或者spi的id,或者sdio的id\nint 片选脚的GPIO 号, spi模式有效,若前一个参数传的是spi device,这个参数就不需要传\nint SPI最高速度,默认10M, 若前2个参数传的是spi device,这个参数就不需要传\nint TF卡电源控制脚,TF卡初始前先拉低复位再拉高,如果没有,或者是内置电源控制方式,这个参数就不需要传\nint TF卡电源复位过程时间,单位ms,默认值是1\nbool 挂载失败是否尝试格式化,默认是true,即自动格式化. 本参数在2023.8.16添加\n返回值：\nbool 成功返回true, 否则返回nil或者false\nstring 失败的原因\n例子：\n-- 方法1, 使用SPI模式\n    local spiId = 2\n    local result = spi.setup(\n        spiId,--串口id\n        255, -- 不使用默认CS脚\n        0,--CPHA\n        0,--CPOL\n        8,--数据宽度\n        400*1000  -- 初始化时使用较低的频率\n    )\n    local TF_CS = pin.PB3\n    gpio.setup(TF_CS, 1)\n    --fatfs.debug(1) -- 若挂载失败,可以尝试打开调试信息,查找原因\n    -- 提醒, 若TF/SD模块带电平转换, 通常不支持10M以上的波特率!!\n    fatfs.mount(fatfs.SPI,\"SD\", spiId, TF_CS, 24000000)\n    local data, err = fatfs.getfree(\"SD\")\n    if data then\n        log.info(\"fatfs\", \"getfree\", json.encode(data))\n    else\n        log.info(\"fatfs\", \"err\", err)\n    end\n    -- 往下的操作, 使用 io.open(\"/sd/xxx\", \"w+\") 等io库的API就可以了\n"
            },
            {
                "name": "fatfs.unmount",
                "snippet": "fatfs.unmount(${1:mount_point})",
                "description": "fatfs.unmount(mount_point) - 取消挂载fatfs\n传入值：\nstring 虚拟文件系统的挂载点, 默认是 fatfs,必须与fatfs.mount一致\n返回值：\nint 成功返回0, 否则返回失败码\n例子：\nfatfs.mount(\"SD\")\n"
            },
            {
                "name": "fatfs.getfree",
                "snippet": "fatfs.getfree(${1:mount_point})",
                "description": "fatfs.getfree(mount_point) - 获取可用空间信息\n传入值：\nstring 挂载点, 需要跟fatfs.mount传入的值一致\n返回值：\ntable 若成功会返回table,否则返回nil\nint 导致失败的底层返回值\n例子：\n-- table包含的内容有\n-- total_sectors 总扇区数量\n-- free_sectors 空闲扇区数量\n-- total_kb 总字节数,单位kb\n-- free_kb 空闲字节数, 单位kb\n-- 注意,当前扇区大小固定在512字节\n\n    local data, err = fatfs.getfree(\"SD\")\n    if data then\n        log.info(\"fatfs\", \"getfree\", json.encode(data))\n    else\n        log.info(\"fatfs\", \"err\", err)\n    end\n"
            },
            {
                "name": "fatfs.debug",
                "snippet": "fatfs.debug(${1:value})",
                "description": "fatfs.debug(value) - 设置调试模式\n传入值：\nbool 是否进入调试模式,true代表进入调试模式,增加调试日志\n返回值：\nnil 无返回值\n"
            },
            {
                "name": "fdb.kvdb_init",
                "snippet": "fdb.kvdb_init(${1:name},${2:partition})",
                "description": "fdb.kvdb_init(name, partition) - 初始化kv数据库\n传入值：\nstring 数据库名,当前仅支持env\nstring FAL分区名,当前仅支持onchip_fdb\n返回值：\nboolean 成功返回true,否则返回false\n例子：\n-- fdb库基于 flashdb , 再次表示感谢.\nif fdb.kvdb_init(\"env\", \"onchip_fdb\") then\n    log.info(\"fdb\", \"kv数据库初始化成功\")\nend\n\n-- 关于清空fdb库\n-- 下载工具是没有提供直接清除fdb数据的途径的, 但有有办法解决\n-- 写一个main.lua, 执行 fdb.kvdb_init 后 执行 fdb.clear() 即可全清fdb数据.\n"
            },
            {
                "name": "fdb.kv_set",
                "snippet": "fdb.kv_set(${1:key},${2:value})",
                "description": "fdb.kv_set(key, value) - 设置一对kv数据\n传入值：\nstring key的名称,必填,不能空字符串\nstring 用户数据,必填,不能nil, 支持字符串/数值/table/布尔值, 数据长度最大255字节\n返回值：\nboolean 成功返回true,否则返回false\nnumber 第二个为返回为flashdb的fdb_kv_set_blob返回详细状态,0：无错误 1:擦除错误 2:读错误 3:写错误 4:未找到 5:kv名字错误 6:kv名字存在 7:已保存 8:初始化错误\n例子：\nif fdb.kvdb_init(\"env\", \"onchip_fdb\") then\n    log.info(\"fdb\", fdb.kv_set(\"wendal\", \"goodgoodstudy\"))\nend\n"
            },
            {
                "name": "fdb.kv_get",
                "snippet": "fdb.kv_get(${1:key},${2:skey})",
                "description": "fdb.kv_get(key, skey) - 根据key获取对应的数据\n传入值：\nstring key的名称,必填,不能空字符串\nstring 可选的次级key,仅当原始值为table时有效,相当于 fdb.kv_get(key)[skey]\n返回值：\nany 存在则返回数据,否则返回nil\n例子：\nif fdb.kvdb_init(\"env\", \"onchip_fdb\") then\n    log.info(\"fdb\", fdb.kv_get(\"wendal\"))\nend\n"
            },
            {
                "name": "fdb.kv_del",
                "snippet": "fdb.kv_del(${1:key})",
                "description": "fdb.kv_del(key) - 根据key删除数据\n传入值：\nstring key的名称,必填,不能空字符串\n返回值：\nbool 成功返回true,否则返回false\n例子：\nif fdb.kvdb_init(\"env\", \"onchip_fdb\") then\n    log.info(\"fdb\", fdb.kv_del(\"wendal\"))\nend\n"
            },
            {
                "name": "fdb.kv_clr",
                "snippet": "fdb.kv_clr()",
                "description": "fdb.kv_clr() - 清空整个kv数据库\n返回值：\nbool 成功返回true,否则返回false\n例子：\n-- 清空\nfdb.kv_clr()\n"
            },
            {
                "name": "fdb.kv_iter",
                "snippet": "fdb.kv_iter()",
                "description": "fdb.kv_iter() - kv数据库迭代器\n返回值：\nuserdata 成功返回迭代器指针,否则返回nil\n例子：\n-- 清空\nlocal iter = fdb.kv_iter()\nif iter then\n    while 1 do\n        local k = fdb.kv_next(iter)\n        if not k then\n            break\n        end\n        log.info(\"fdb\", k, \"value\", fdb.kv_get(k))\n    end\nend\n"
            },
            {
                "name": "fdb.kv_next",
                "snippet": "fdb.kv_next(${1:iter})",
                "description": "fdb.kv_next(iter) - kv迭代器获取下一个key\n传入值：\nuserdata fdb.kv_iter()返回的指针\n返回值：\nstring 成功返回字符串key值, 否则返回nil\n例子：\n-- 清空\nlocal iter = fdb.kv_iter()\nif iter then\n    while 1 do\n        local k = fdb.kv_next(iter)\n        if not k then\n            break\n        end\n        log.info(\"fdb\", k, \"value\", fdb.kv_get(k))\n    end\nend\n"
            },
            {
                "name": "fdb.kv_stat",
                "snippet": "fdb.kv_stat()",
                "description": "fdb.kv_stat() - 获取kv数据库状态\n返回值：\nint 已使用的空间,单位字节\nint 总可用空间, 单位字节\nint 总kv键值对数量, 单位个\n例子：\n-- 本API于2022.07.23 添加\nlocal used,maxs,kv_count = fdb.kv_stat()\nlog.info(\"fdb\", \"kv\", used,maxs,kv_count)\n"
            },
            {
                "name": "fonts.list",
                "snippet": "fonts.list(${1:tp})",
                "description": "fonts.list(tp) - 返回固件支持的字体列表\n传入值：\nstring 类型, 默认 u8g2, 还可以是lvgl\n返回值：\ntable 字体列表\n例子：\n-- API新增于2022-07-12\nif fonts.list then\n    log.info(\"fonts\", \"u8g2\", json.encode(fonts.list(\"u8g2\")))\nend\n"
            },
            {
                "name": "fonts.u8g2_get",
                "snippet": "fonts.u8g2_get(${1:name},${2:tp})",
                "description": "fonts.u8g2_get(name, tp) - 获取字体\n传入值：\nstring 字体名称, 例如opposansm8_chinese unifont_t_symbols\nstring 类型, 默认 u8g2, 还可以是lvgl\n返回值：\nuserdata 若字体存放,返回字体指针, 否则返回nil\n例子：\noppo_8 = fonts.get(\"opposansm8_chinese\", \"u8g2\")\nif oppo_8 then\n    u8g2.SetFont(oppo_8)\nelse\n    log.warn(\"fonts\", \"no such font opposansm8_chinese\")\nend\n-- 若使用云编译的自定义字库, 使用方式如下\noppo_8 = fonts.get(\"oppo_bold_8\", \"u8g2\") -- oppo_bold_8 是云编译界面的字库命名\nif oppo_8 then\n    u8g2.SetFont(oppo_8)\nelse\n    log.warn(\"fonts\", \"no such font opposansm8_chinese\")\nend\n"
            },
            {
                "name": "fonts.u8g2_load",
                "snippet": "fonts.u8g2_load(${1:path},${2:path})",
                "description": "fonts.u8g2_load(path, path) - 从文件加载字体\n传入值：\nstring 字体路径, 例如 /luadb/abc.bin\nstring 类型, 默认 u8g2. 也支持lvgl\n返回值：\nuserdata 若字体存放,返回字体指针, 否则返回nil\n例子：\n-- API新增于2022-07-11\n-- 提醒: 若文件位于/luadb下, 不需要占用内存\n-- 若文件处于其他路径, 例如tf/sd卡, spi flash, 会自动加载到内存, 消耗lua vm的内存空间\n-- 加载后请适当引用, 不必反复加载同一个字体文件\noppo12 = fonts.load(\"/luadb/oppo12.bin\")\nif oppo12 then\n    u8g2.SetFont(oppo12)\nelse\n    log.warn(\"fonts\", \"no such font file oppo12.bin\")\nend\n"
            },
            {
                "name": "fota.init",
                "snippet": "fota.init(${1:storge_location},${2:len},${3:param1},${4:param2})",
                "description": "fota.init(storge_location, len, param1, param2) - 初始化fota流程\n传入值：\nint/string fota数据存储的起始位置<br>如果是int，则是由芯片平台具体判断<br>如果是string，则存储在文件系统中<br>如果为nil，则由底层决定存储位置\nint 数据存储的最大空间\nuserdata param1，如果数据存储在spiflash时,为spi_device\nint param2，目前只用于外部flash更新时, spiflash电源控制脚\n返回值：\nboolean 成功返回true, 失败返回false\n例子：\n-- 初始化fota流程\nlocal result = fota.init(0, 0x00300000, spi_device)    --由于105的flash从0x01000000开始，所以0就是外部spiflash\nlocal result = fota.init()    --ec618系列/EC7XX系列使用固定内部地址，所以不需要参数了\nlocal result = fota.init(0xe0000000, 0, spi_device, 27)    --EC7XX系列允许使用外部flash更新，但是地址必须加上0xe0000000的偏移\n"
            },
            {
                "name": "fota.wait",
                "snippet": "fota.wait()",
                "description": "fota.wait() - 等待底层fota流程准备好\n传入值：\nboolean 是否完整走完流程，true 表示正确走完流程了\n返回值：\nboolean 准备好返回true\n例子：\nlocal isDone = fota.wait()\n"
            },
            {
                "name": "fota.run",
                "snippet": "fota.run(${1:buff},${2:offset},${3:len})",
                "description": "fota.run(buff, offset, len) - 写入fota数据\n传入值：\nzbuff/string fota数据，尽量用zbuff\nint 起始偏移量,传入zbuff时有效,默认是0\nint 写入长度,传入zbuff时有效,默认是zbuff:used()\n返回值：\nboolean 有异常返回false，无异常返回true\nboolean 接收到最后一块返回true\nint 还未写入的数据量，超过64K必须做等待\n例子：\nlocal result, isDone, cache = fota.run(buf) -- 写入fota流程\n\n-- 提示: ，如果传入的是zbuff，写入成功后，请自行清空zbuff内的数据\n\n-- 2024.4.3新增offset, len参数, 仅对zbuff有效\nfota.run(buff, 0, 1024)\n"
            },
            {
                "name": "fota.file",
                "snippet": "fota.file(${1:path})",
                "description": "fota.file(path) - 从指定文件读取fota数据\n传入值：\nstring 文件路径\n返回值：\nboolean 有异常返回false，无异常返回true\nboolean 接收到最后一块返回true\nint 还未写入的数据量，超过64K必须做等待\n例子：\nlocal result, isDone, cache = fota.file(\"/xxx.bin\") -- 写入fota流程\n-- 本API于2023.03.23 添加\n"
            },
            {
                "name": "fota.isDone",
                "snippet": "fota.isDone()",
                "description": "fota.isDone() - 等待底层fota流程完成\n返回值：\nboolean 有异常返回false，无异常返回true\nboolean 写入到最后一块返回true\n例子：\nlocal result, isDone = fota.isDone()\n"
            },
            {
                "name": "fota.finish",
                "snippet": "fota.finish(${1:is_ok})",
                "description": "fota.finish(is_ok) - 结束fota流程\n传入值：\nboolean 是否完整走完流程，true 表示正确走完流程了\n返回值：\nboolean 成功返回true, 失败返回false\n例子：\n-- 结束fota流程\nlocal result = fota.finish(true)\n"
            },
            {
                "name": "fs.fsstat",
                "snippet": "fs.fsstat(${1:path})",
                "description": "fs.fsstat(path) - 获取文件系统信息\n传入值：\nstring 路径,默认\"/\",可选\n返回值：\nboolean 获取成功返回true,否则返回false\nint 总的block数量\nint 已使用的block数量\nint block的大小,单位字节\nstring 文件系统类型,例如lfs代表littlefs\n例子：\n-- 打印根分区的信息\nlog.info(\"fsstat\", fs.fsstat(\"/\"))\n"
            },
            {
                "name": "fs.fsize",
                "snippet": "fs.fsize(${1:path})",
                "description": "fs.fsize(path) - 获取文件大小\n传入值：\nstring 文件路径\n返回值：\nint 文件大小,若获取失败会返回0\n例子：\n-- 打印main.luac的大小\nlog.info(\"fsize\", fs.fsize(\"/main.luac\"))\n"
            },
            {
                "name": "fskv.init",
                "snippet": "fskv.init()",
                "description": "fskv.init() - 初始化kv数据库\n返回值：\nboolean 成功返回true,否则返回false\n例子：\nif fskv.init() then\n    log.info(\"fdb\", \"kv数据库初始化成功\")\nend\n\n-- 关于清空fdb库\n-- 下载工具是没有提供直接清除fdb数据的途径的, 但有办法解决\n-- 写一个main.lua, 执行 fskv.kvdb_init 后 执行 fskv.clear() 即可全清fdb数据.\n"
            },
            {
                "name": "fskv.set",
                "snippet": "fskv.set(${1:key},${2:value})",
                "description": "fskv.set(key, value) - 设置一对kv数据\n传入值：\nstring key的名称,必填,不能空字符串\nstring 用户数据,必填,不能nil, 支持字符串/数值/table/布尔值, 数据长度最大4095字节\n返回值：\nboolean 成功返回true,否则返回false\n例子：\n-- 设置数据, 字符串,数值,table,布尔值,均可\n-- 但不可以是nil, function, userdata, task\nlog.info(\"fdb\", fskv.set(\"wendal\", \"goodgoodstudy\"))\nlog.info(\"fdb\", fskv.set(\"upgrade\", true))\nlog.info(\"fdb\", fskv.set(\"timer\", 1))\nlog.info(\"fdb\", fskv.set(\"bigd\", {name=\"wendal\",age=123}))\n"
            },
            {
                "name": "fskv.sett",
                "snippet": "fskv.sett(${1:key},${2:skey},${3:value})",
                "description": "fskv.sett(key, skey, value) - 设置table内的键值对数据\n传入值：\nstring key的名称,必填,不能空字符串\nstring table的key名称, 必填, 不能是空字符串\nstring 用户数据,必填,支持字符串/数值/table/布尔值, 数据长度最大4095字节\n返回值：\nboolean 成功返回true,否则返回false/nil\n例子：\n-- 本API在2023.7.26新增,注意与set函数区别\n-- 设置数据, 字符串,数值,table,布尔值,均可\n-- 但不可以是function, userdata, task\nlog.info(\"fdb\", fskv.sett(\"mytable\", \"wendal\", \"goodgoodstudy\"))\nlog.info(\"fdb\", fskv.sett(\"mytable\", \"upgrade\", true))\nlog.info(\"fdb\", fskv.sett(\"mytable\", \"timer\", 1))\nlog.info(\"fdb\", fskv.sett(\"mytable\", \"bigd\", {name=\"wendal\",age=123}))\n\n-- 下列语句将打印出4个元素的table\nlog.info(\"fdb\", fskv.get(\"mytable\"), json.encode(fskv.get(\"mytable\")))\n-- 注意: 如果key不存在, 或者原本的值不是table类型,将会完全覆盖\n-- 例如下列写法,最终获取到的是table,而非第一行的字符串\nlog.info(\"fdb\", fskv.set(\"mykv\", \"123\"))\nlog.info(\"fdb\", fskv.sett(\"mykv\", \"age\", \"123\")) -- 保存的将是 {age:\"123\"}\n\n\n-- 如果设置的数据填nil, 代表删除对应的key\nlog.info(\"fdb\", fskv.sett(\"mykv\", \"name\", \"wendal\"))\nlog.info(\"fdb\", fskv.sett(\"mykv\", \"name\")) -- 相当于删除\n-- \n"
            },
            {
                "name": "fskv.get",
                "snippet": "fskv.get(${1:key},${2:skey})",
                "description": "fskv.get(key, skey) - 根据key获取对应的数据\n传入值：\nstring key的名称,必填,不能空字符串\nstring 可选的次级key,仅当原始值为table时有效,相当于 fskv.get(key)[skey]\n返回值：\nany 存在则返回数据,否则返回nil\n例子：\nif fskv.init() then\n    log.info(\"fdb\", fskv.get(\"wendal\"))\nend\n\n-- 若需要\"默认值\", 对应非bool布尔值, 可以这样写\nlocal v = fskv.get(\"wendal\") or \"123\"\n"
            },
            {
                "name": "fskv.del",
                "snippet": "fskv.del(${1:key})",
                "description": "fskv.del(key) - 根据key删除数据\n传入值：\nstring key的名称,必填,不能空字符串\n返回值：\nbool 成功返回true,否则返回false\n例子：\nlog.info(\"fdb\", fskv.del(\"wendal\"))\n"
            },
            {
                "name": "fskv.clear",
                "snippet": "fskv.clear()",
                "description": "fskv.clear() - 清空整个kv数据库\n返回值：\nbool 成功返回true,否则返回false\n例子：\n-- 清空\nfskv.clear()\n"
            },
            {
                "name": "fskv.iter",
                "snippet": "fskv.iter()",
                "description": "fskv.iter() - kv数据库迭代器\n返回值：\nuserdata 成功返回迭代器指针,否则返回nil\n例子：\n-- 清空\nlocal iter = fskv.iter()\nif iter then\n    while 1 do\n        local k = fskv.next(iter)\n        if not k then\n            break\n        end\n        log.info(\"fdb\", k, \"value\", fskv.kv_get(k))\n    end\nend\n"
            },
            {
                "name": "fskv.next",
                "snippet": "fskv.next(${1:iter})",
                "description": "fskv.next(iter) - kv迭代器获取下一个key\n传入值：\nuserdata fskv.iter()返回的指针\n返回值：\nstring 成功返回字符串key值, 否则返回nil\n例子：\n-- 清空\nlocal iter = fskv.iter()\nif iter then\n    while 1 do\n        local k = fskv.next(iter)\n        if not k then\n            break\n        end\n        log.info(\"fskv\", k, \"value\", fskv.get(k))\n    end\nend\n"
            },
            {
                "name": "fskv.status",
                "snippet": "fskv.status()",
                "description": "fskv.status() - 获取kv数据库状态\n返回值：\nint 已使用的空间,单位字节\nint 总可用空间, 单位字节\nint 总kv键值对数量, 单位个\n例子：\nlocal used, total,kv_count = fskv.status()\nlog.info(\"fdb\", \"kv\", used,total,kv_count)\n"
            },
            {
                "name": "ftp.login",
                "snippet": "ftp.login(${1:adapter},${2:ip_addr},${3:port},${4:username},${5:password})",
                "description": "ftp.login(adapter,ip_addr,port,username,password) - FTP客户端\n传入值：\nint 适配器序号, 只能是socket.ETH0, socket.STA, socket.AP,如果不填,会选择平台自带的方式,然后是最后一个注册的适配器\nstring ip_addr 地址\nstring port 端口,默认21\nstring username 用户名\nstring password 密码\nbool/table 是否为ssl加密连接,默认不加密,true为无证书最简单的加密，table为有证书的加密 <br>server_cert 服务器ca证书数据 <br>client_cert 客户端ca证书数据 <br>client_key 客户端私钥加密数据 <br>client_password 客户端私钥口令数据\n返回值：\nbool/string 成功返回true 失败返回string\n例子：\nftp_login = ftp.login(nil,\"xxx\")\n"
            },
            {
                "name": "ftp.command",
                "snippet": "ftp.command(${1:cmd})",
                "description": "ftp.command(cmd) - FTP命令\n传入值：\nstring cmd 命令 目前支持:NOOP SYST TYPE PWD MKD CWD CDUP RMD DELE LIST\n返回值：\nstring 成功返回true 失败返回string\n例子：\n    // 空操作，防止连接断掉\n    print(ftp.command(\"NOOP\").wait())\n    // 报告远程系统的操作系统类型\n    print(ftp.command(\"SYST\").wait())\n    // 指定文件类型\n    print(ftp.command(\"TYPE I\").wait())\n    // 显示当前工作目录名\n    print(ftp.command(\"PWD\").wait())\n    // 创建目录\n    print(ftp.command(\"MKD QWER\").wait())\n    // 改变当前工作目录\n    print(ftp.command(\"CWD /QWER\").wait())\n    // 返回上一层目录\n    print(ftp.command(\"CDUP\").wait())\n    // 删除目录\n    print(ftp.command(\"RMD QWER\").wait())\n    // 获取当前工作目录下的文件名列表\n    print(ftp.command(\"LIST\").wait())\n    // 删除文件\n    print(ftp.command(\"DELE /1/12222.txt\").wait())\n"
            },
            {
                "name": "ftp.pull",
                "snippet": "ftp.pull(${1:local_name},${2:remote_name})",
                "description": "ftp.pull(local_name,remote_name) - FTP文件下载\n传入值：\nstring local_name 本地文件\nstring remote_name 服务器文件\n返回值：\nbool/string 成功返回true 失败返回string\n例子：\nftp.pull(\"/1222.txt\",\"/1222.txt\").wait()\n"
            },
            {
                "name": "ftp.push",
                "snippet": "ftp.push(${1:local_name},${2:remote_name})",
                "description": "ftp.push(local_name,remote_name) - FTP文件上传\n传入值：\nstring local_name 本地文件\nstring remote_name 服务器文件\n返回值：\nbool/string 成功返回true 失败返回string\n例子：\nftp.push(\"/1222.txt\",\"/1222.txt\").wait()\n"
            },
            {
                "name": "ftp.close",
                "snippet": "ftp.close()",
                "description": "ftp.close() - FTP客户端关闭\n返回值：\nbool/string 成功返回true 失败返回string\n例子：\nftp.close().wait()\n"
            },
            {
                "name": "ftp.debug",
                "snippet": "ftp.debug(${1:onoff})",
                "description": "ftp.debug(onoff) - 配置是否打开debug信息\n传入值：\nboolean 是否打开debug开关\n返回值：\nnil 无返回值\n"
            },
            {
                "name": "sm.sm2encrypt",
                "snippet": "sm.sm2encrypt(${1:pkx},${2:pky},${3:data},${4:mode},${5:mode2})",
                "description": "sm.sm2encrypt(pkx,pky,data, mode, mode2) - sm2算法加密\n传入值：\nstring 公钥x,必选. HEX字符串\nstring 公钥y,必选. HEX字符串\nstring 待计算的数据,必选,最长32字节, 非HEX字符串\nboolean 输出模式,默认false. false-GMSSL默认格式DER, true-网站兼容模式\nboolean 标准版本,默认false. false-C1C3C2新国际, true-C1C2C3老国际\n返回值：\nstring 加密后的字符串, 原样输出,未经HEX转换. 若加密失败会返回nil或空字符串\n例子：\n-- 提示 mode/mode2 参数是 2023.10.17 新增\n-- 由于SM2在各平台的实现都有差异,用法务必参考demo\n"
            },
            {
                "name": "sm.sm2decrypt",
                "snippet": "sm.sm2decrypt(${1:private},${2:data},${3:mode},${4:mode2})",
                "description": "sm.sm2decrypt(private,data,mode,mode2) - sm2算法解密\n传入值：\nstring 私钥,必选,HEX字符串\nstring 待计算的数据,必选,原始数据,非HEX字符串\nboolean 输出模式,默认false. false-GMSSL默认格式DER, true-网站兼容模式\nboolean 标准版本,默认false. false-C1C3C2新国际, true-C1C2C3老国际\n返回值：\nstring 解密后的字符串,未经HEX转换.若解密失败会返回nil或空字符串\n例子：\n-- 提示 mode/mode2 参数是 2023.10.17 新增\n-- 由于SM2在各平台的实现都有差异,用法务必参考demo\n"
            },
            {
                "name": "sm.sm3",
                "snippet": "sm.sm3(${1:data})",
                "description": "sm.sm3(data) - sm3算法,算HASH值\n传入值：\nstring 待计算的数据,必选\n返回值：\nstring 对应的hash值\n例子：\nlocal encodeStr = gmssl.sm3(\"lqlq666lqlq946\")\nlog.info(\"testsm.sm3update\",string.toHex(encodeStr))\n"
            },
            {
                "name": "sm.sm3hmac",
                "snippet": "sm.sm3hmac(${1:data},${2:key})",
                "description": "sm.sm3hmac(data, key) - sm3算法,算HASH值,但带HMAC\n传入值：\nstring 待计算的数据,必选\nstring 密钥\n返回值：\nstring 对应的hash值\n例子：\nlocal encodeStr = gmssl.sm3hmac(\"lqlq666lqlq946\", \"123\")\nlog.info(\"testsm.sm3update\",string.toHex(encodeStr))\n"
            },
            {
                "name": "gmssl.sm4encrypt",
                "snippet": "gmssl.sm4encrypt(${1:mode},${2:padding},${3:originStr},${4:password})",
                "description": "gmssl.sm4encrypt(mode,padding,originStr,password) - SM4加密算法\n传入值：\nstring 加密模式, CBC或ECB   \nstring 填充方式, NONE/ZERO/PKCS5/PKCS7\nstring 加密的字符串\nstring 密钥\nstring 偏移量\n返回值：\nstring 加密后的数据\n例子：\nlocal originStr = \"SM4 ECB ZeroPadding test\"\n--加密模式：ECB；填充方式：ZeroPadding；密钥：1234567890123456；密钥长度：128 bit\nlocal encodeStr = gmssl.sm4encrypt(\"ECB\",\"ZERO\",originStr,\"1234567890123456\")\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\nlog.info(\"testsm.decrypt\",gmssl.sm4decrypt(\"ECB\",\"ZERO\",encodeStr,\"1234567890123456\"))\n\noriginStr = \"SM4 ECB Pkcs5Padding test\"\n--加密模式：ECB；填充方式：Pkcs5Padding；密钥：1234567890123456；密钥长度：128 bit\nencodeStr = gmssl.sm4encrypt(\"ECB\",\"PKCS5\",originStr,\"1234567890123456\")\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\nlog.info(\"testsm.decrypt\",gmssl.sm4decrypt(\"ECB\",\"PKCS5\",encodeStr,\"1234567890123456\"))\n\noriginStr = \"SM4 CBC Pkcs5Padding test\"\n--加密模式：CBC；填充方式：Pkcs5Padding；密钥：1234567890123456；密钥长度：256 bit；偏移量：1234567890666666\nencodeStr = gmssl.sm4encrypt(\"CBC\",\"PKCS5\",originStr,\"1234567890123456\",\"1234567890666666\")\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\nlog.info(\"testsm.decrypt\",gmssl.sm4decrypt(\"CBC\",\"PKCS5\",encodeStr,\"1234567890123456\",\"1234567890666666\"))\n"
            },
            {
                "name": "gmssl.sm4decrypt",
                "snippet": "gmssl.sm4decrypt(${1:mode},${2:padding},${3:encodeStr},${4:password})",
                "description": "gmssl.sm4decrypt(mode,padding,encodeStr,password) - SM4解密算法\n传入值：\nstring 加密模式, CBC或ECB   \nstring 填充方式, NONE/ZERO/PKCS5/PKCS7\nstring 已加密的字符串\nstring 密钥\nstring 偏移量\n返回值：\nstring 解密的字符串\n例子：\n-- 参考gmssl.sm4encrypt\n"
            },
            {
                "name": "sm.sm2sign",
                "snippet": "sm.sm2sign(${1:private},${2:data},${3:id})",
                "description": "sm.sm2sign(private,data,id) - sm2算法签名\n传入值：\nstring 私钥,必选,HEX字符串\nstring 待计算的数据,必选,原始数据,非HEX字符串\nstring id值,非HEX字符串,可选,默认值\"1234567812345678\"\n返回值：\nstring 前面字符串,未经HEX转换.若签名失败会返回nil\n例子：\n-- 本API于 2023.10.19 新增\n-- 具体用法请查阅demo\n"
            },
            {
                "name": "sm.sm2verify",
                "snippet": "sm.sm2verify(${1:pkx},${2:pky},${3:data},${4:id},${5:sig})",
                "description": "sm.sm2verify(pkx, pky, data, id, sig) - sm2算法验签\n传入值：\nstring 公钥X,必选,HEX字符串\nstring 公钥Y,必选,HEX字符串\nstring 待计算的数据,必选,原始数据,非HEX字符串\nstring id值,非HEX字符串,可选,默认值\"1234567812345678\"\nstring 签名数据,必须64字节,非HEX字符串\n返回值：\nboolean 验证成功返回true,否则返回nil\n例子：\n-- 本API于 2023.10.19 新增\n-- 具体用法请查阅demo\n"
            },
            {
                "name": "gpio.setup",
                "snippet": "gpio.setup(${1:pin},${2:mode},${3:pull},${4:irq},${5:alt})",
                "description": "gpio.setup(pin, mode, pull, irq, alt) - 设置管脚功能\n传入值：\nint pin gpio编号,必须是数值\nany mode 输入输出模式：<br>数字0/1代表输出模式<br>nil代表输入模式<br>function代表中断模式，如果填gpio.count，则为中断计数功能，中断时不回调\nint pull 上拉下拉模式, 可以是上拉模式 gpio.PULLUP 或下拉模式 gpio.PULLDOWN, 或者开漏模式 0. 需要根据实际硬件选用\nint irq 中断触发模式,默认gpio.BOTH。中断触发模式<br>上升沿gpio.RISING<br>下降沿gpio.FALLING<br>上升和下降都触发gpio.BOTH \nint alt 复用选项，目前只有EC618平台需要这个参数，有些GPIO可以复用到不同引脚上，可以选择复用选项（0或者4）从而复用到对应的引脚上\n返回值：\nany 输出模式返回设置电平的闭包, 输入模式和中断模式返回获取电平的闭包\n例子：\n\n-- 设置gpio17为输入\ngpio.setup(17, nil)\n\n-- 设置gpio17为输出,且初始化电平为低,使用硬件默认上下拉配置\ngpio.setup(17, 0)\n\n-- 设置gpio17为输出,且初始化电平为高,且启用内部上拉\ngpio.setup(17, 1, gpio.PULLUP)\n\n-- 设置gpio27为中断, 默认双向触发\ngpio.setup(27, function(val)\n    print(\"IRQ_27\",val) -- 提醒, val并不代表触发方向, 仅代表中断后某个时间点的电平\nend, gpio.PULLUP)\n\n-- 设置gpio27为中断, 仅上升沿触发\ngpio.setup(27, function(val)\n    print(\"IRQ_27\",val) -- 提醒, val并不代表触发方向, 仅代表中断后某个时间点的电平\nend, gpio.PULLUP, gpio.RISING)\n\n-- 中断计数 于2024.5.8新增\n-- 设置gpio7为中断计数，详细demo见gpio/gpio_irq_count\ngpio.setup(7, gpio.count)\n\n-- alt_func 于2023.7.2新增\n-- 本功能仅对部分平台有效, 且仅用于调整GPIO复用,其他复用方式请使用muc.iomux函数\n-- 以下示例代码, 将I2S_DOUT复用成gpio18\n-- AIR780E的PIN33(模块管脚序号), 对应paddr 38, 默认功能是I2S_DOUT, 复用成gpio18\n-- 方向输出,且初始化电平为低,使用硬件默认上下拉配置\n-- Air780E(EC618系列的GPIO复用请查阅 https://air780e.cn 首页硬件资料表格中的Air780E&Air780EG&Air780EX&Air700E_GPIO_table_20231227.pdf)\n-- Air780EP(EC718P系列的GPIO复用请查阅 https://air780ep.cn 首页硬件资料表格中的Air780E&Air780EG&Air780EX&Air700E_GPIO_table_20231227.pdf)\ngpio.setup(18, 0, nil, nil, 4)\n\n-- 提醒: \n-- 当管脚为输入模式或中断,才能通过gpio.get()获取到电平\n-- 当管脚为输出模式,才能通过gpio.set()设置电平\n-- 当管脚为输出模式,通过gpio.get()总会得到0\n-- 中断回调的val参数不代表触发方向, 仅代表中断后某个时间点的电平\n-- 对Cat.1模块,EC618系列只有AONGPIO才能双向触发，其他系列所有GPIO都能双向触发，具体看硬件手册\n-- 默认设置下,中断是没有防抖时间的,可以通过gpio.set_debounce(pin, 50)来设置防抖时间\n\n-- pull参数的额外说明, 上拉/下拉配置\n-- 对于部分的BSP来说, 只支持 gpio.PULLUP 或 gpio.PULLDOWN, 但有部分BSP支持开漏模式\n-- 对于支持开漏的bsp, pull参数要传 0 才能开启开漏模式, 不是传nil\n-- 例如:\n-- EC618系列(Air780E/Air780EG/Air780EX/Air700E等)\n-- EC718系列(Air780EP/Air780EPV等)\n-- XT804系列(Air101/Air103/Air601)\n"
            },
            {
                "name": "gpio.caplevel",
                "snippet": "gpio.caplevel(${1:pin},${2:level},${3:func})",
                "description": "gpio.caplevel(pin, level,func) - 捕获管脚电平持续时长，单位us\n传入值：\nint pin GPIO编号,必须是数值\nint level 需要捕获的电平, 可以是 高电平gpio.HIGH, 低电平gpio.LOW, 或者直接写数值1或0，即管脚上正常时间处于level的反，捕获设定的level持续时间\nfunction func 完成捕获后的回调函数，仅一个参数，参数为捕获到的时间长度number型数值，单位us\n返回值：\nany 返回获取电平的闭包\n例子：\n-- 捕获pin.PA07为高电平的持续时间\ngpio.caplevel(pin.PA07,1,function(val) print(val) end)\n"
            },
            {
                "name": "gpio.set",
                "snippet": "gpio.set(${1:pin},${2:value})",
                "description": "gpio.set(pin, value) - 设置管脚电平\n传入值：\nint pin GPIO编号,必须是数值\nint value 电平, 可以是 高电平gpio.HIGH, 低电平gpio.LOW, 或者直接写数值1或0\n返回值：\nnil 无返回值\n例子：\n-- 设置gpio17为低电平\ngpio.set(17, 0)\n"
            },
            {
                "name": "gpio.get",
                "snippet": "gpio.get(${1:pin})",
                "description": "gpio.get(pin) - 获取管脚电平\n传入值：\nint pin GPIO编号,必须是数值\n返回值：\nvalue 电平, 高电平gpio.HIGH, 低电平gpio.LOW, 对应数值1和0\n例子：\n-- 获取gpio17的当前电平\ngpio.get(17)\n"
            },
            {
                "name": "gpio.close",
                "snippet": "gpio.close(${1:pin})",
                "description": "gpio.close(pin) - 关闭管脚功能(高阻输入态),关掉中断\n传入值：\nint pin GPIO编号,必须是数值\n返回值：\nnil 无返回值,总是执行成功\n例子：\n-- 关闭gpio17\ngpio.close(17)\n"
            },
            {
                "name": "gpio.setDefaultPull",
                "snippet": "gpio.setDefaultPull(${1:val})",
                "description": "gpio.setDefaultPull(val) - 设置GPIO脚的默认上拉/下拉设置, 默认是平台自定义(一般为开漏).\n传入值：\nint val 0平台自定义,1上拉, 2下拉\n返回值：\nboolean 传值正确返回true,否则返回false\n例子：\n-- 设置gpio.setup的pull默认值为上拉\ngpio.setDefaultPull(1)\n"
            },
            {
                "name": "gpio.toggle",
                "snippet": "gpio.toggle(${1:pin})",
                "description": "gpio.toggle(pin) - 变换GPIO脚输出电平,仅输出模式可用\n传入值：\nint 管脚的GPIO号\n返回值：\nnil 无返回值\n例子：\n-- 本API于 2022.05.17 添加\n-- 假设GPIO16上有LED, 每500ms切换一次开关\ngpio.setup(16, 0)\nsys.timerLoopStart(function()\n    gpio.toggle(16)\nend, 500)\n"
            },
            {
                "name": "gpio.pulse",
                "snippet": "gpio.pulse(${1:pin},${2:level},${3:len},${4:delay})",
                "description": "gpio.pulse(pin,level,len,delay) - 在同一个GPIO输出一组脉冲, 注意, len的单位是bit, 高位在前.\n传入值：\nint gpio号\nint/string 数值或者字符串.\nint len 长度 单位是bit, 高位在前.\nint delay 延迟,当前无固定时间单位\n返回值：\nnil 无返回值\n例子：\n-- 通过PB06脚输出输出8个电平变化.\ngpio.pulse(pin.PB06,0xA9, 8, 0)\n"
            },
            {
                "name": "gpio.debounce",
                "snippet": "gpio.debounce(${1:pin},${2:ms},${3:mode})",
                "description": "gpio.debounce(pin, ms, mode) - 防抖设置, 根据硬件ticks进行防抖\n传入值：\nint gpio号, 0~127, 与硬件相关\nint 防抖时长,单位毫秒, 最大 65555 ms, 设置为0则关闭\nint 模式, 0冷却模式, 1延时模式. 默认是0\n返回值：\nnil 无返回值\n例子：\n-- 消抖模式, 当前支持2种, 2022.12.16开始支持mode=1\n-- 0 触发中断后,马上上报一次, 然后冷却N个毫秒后,重新接受中断\n-- 1 触发中断后,延迟N个毫秒,期间没有新中断且电平没有变化,上报一次\n\n-- 开启防抖, 模式0-冷却, 中断后马上上报, 但100ms内只上报一次\ngpio.debounce(7, 100) -- 若芯片支持pin库, 可用pin.PA7代替数字7\n-- 开启防抖, 模式1-延时, 中断后等待100ms,期间若保持该电平了,时间到之后上报一次\n-- 对应的,如果输入的是一个 50hz的方波,那么不会触发任何上报\ngpio.debounce(7, 100, 1)\n\n-- 关闭防抖,时间设置为0就关闭\ngpio.debounce(7, 0)\n"
            },
            {
                "name": "gpio.count",
                "snippet": "gpio.count(${1:pin})",
                "description": "gpio.count(pin) - 获取gpio中断数量，并清空累计值，类似air724的脉冲计数\n传入值：\nint gpio号, 0~127, 与硬件相关\n返回值：\nint 返回从上次获取中断数量后到当前的中断计数\n例子：\nlog.info(\"irq cnt\", gpio.count(10))\n"
            },
            {
                "name": "gtfont.init",
                "snippet": "gtfont.init(${1:spi_device})",
                "description": "gtfont.init(spi_device) - 初始化高通字体芯片\n传入值：\nuserdata 仅支持spi device 生成的指针数据\n返回值：\nboolean 成功返回true,否则返回false\n例子：\n-- 特别提醒: 使用本库的任何代码, 都需要 额外 的 高通字体芯片 !!\n-- 没有额外芯片是跑不了的!!\ngtfont.init(spi_device)\n"
            },
            {
                "name": "hmeta.model",
                "snippet": "hmeta.model()",
                "description": "hmeta.model() - 获取模组名称\n返回值：\nstring 若能识别到,返回模组类型, 否则会是nil\n例子：\nsys.taskInit(function()\n    while 1 do\n        sys.wait(3000)\n        -- hmeta识别底层模组类型的\n        -- 不同的模组可以使用相同的bsp,但根据封装的不同,根据内部数据仍可识别出具体模块\n        log.info(\"hmeta\", hmeta.model())\n        log.info(\"bsp\",   rtos.bsp())\n    end\nend)\n"
            },
            {
                "name": "hmeta.hwver",
                "snippet": "hmeta.hwver()",
                "description": "hmeta.hwver() - 获取模组的硬件版本号\n返回值：\nstring 若能识别到,返回模组类型, 否则会是nil\n例子：\nsys.taskInit(function()\n    while 1 do\n        sys.wait(3000)\n        -- hmeta识别底层模组类型的\n        -- 不同的模组可以使用相同的bsp,但根据封装的不同,根据内部数据仍可识别出具体模块\n        log.info(\"hmeta\", hmeta.model(), hmeta.hwver())\n        log.info(\"bsp\",   rtos.bsp())\n    end\nend)\n"
            },
            {
                "name": "hmeta.chip",
                "snippet": "hmeta.chip()",
                "description": "hmeta.chip() - 获取原始芯片型号\n返回值：\nstring 若能识别到,返回芯片类型, 否则会是nil\n例子：\n-- 若底层正确实现, 这个函数总会返回值\n-- 本函数于 2024.12.5 新增\n"
            },
            {
                "name": "ht1621.setup",
                "snippet": "ht1621.setup(${1:pin_cs},${2:pin_data},${3:pin_wr},${4:cmd_com_mode},${5:cmd_rc},${6:cmd_sysen})",
                "description": "ht1621.setup(pin_cs, pin_data, pin_wr, cmd_com_mode, cmd_rc, cmd_sysen) - 初始化ht1621\n传入值：\nint 片选引脚, 填模块的GPIO编码\nint 数据引脚, 填模块的GPIO编码\nint WR引脚, 填模块的GPIO编码\nint 命令模式, 默认是0x52\nint 内部RC振荡器,默认0x30\nint 系统振荡器开,默认0x02\n返回值：\nuserdata 返回ht1621对象\n例子：\nlocal seg = ht1621.setup(4, 5, 3)\nht1621.data(seg, 0, 0xeb)\n"
            },
            {
                "name": "ht1621.lcd",
                "snippet": "ht1621.lcd(${1:seg},${2:onoff})",
                "description": "ht1621.lcd(seg, onoff) - LCD开关\n传入值：\nuserdata ht1621.setup返回的ht1621对象\nboolean true开,false关\n返回值：\nnil 无返回值\n例子：\nlocal seg = ht1621.setup(4, 5, 3)\nht1621.lcd(seg, true)\n"
            },
            {
                "name": "ht1621.data",
                "snippet": "ht1621.data(${1:seg},${2:addr},${3:sdat})",
                "description": "ht1621.data(seg, addr, sdat) - 展示数据\n传入值：\nuserdata ht1621.setup返回的ht1621对象\nint 地址, 0-6, 超过6无效\nint 数据, 0-255\n返回值：\nnil 无返回值\n例子：\nlocal seg = ht1621.setup(4, 5, 3)\nht1621.lcd(seg, true)\nht1621.data(seg, 0, 0xF1)\n-- 附数字0-9的值表\n-- 0,1,2,3,4,5,6,7,8,9\n-- 0xeb,0x0a,0xad,0x8f,0x4e,0xc7,0xe7,0x8a,0xef,0xcf\n"
            },
            {
                "name": "ht1621.cmd",
                "snippet": "ht1621.cmd(${1:seg},${2:cmd})",
                "description": "ht1621.cmd(seg, cmd) - 发送指令\n传入值：\nuserdata ht1621.setup返回的ht1621对象\nint 指令, 0-255\n返回值：\nnil 无返回值\n例子：\n-- 具体指令请查阅硬件手册\n"
            },
            {
                "name": "http.request",
                "snippet": "http.request(${1:method},${2:url},${3:headers},${4:body},${5:opts},${6:ca_file},${7:client_ca},${8:client_key},${9:client_password})",
                "description": "http.request(method,url,headers,body,opts,ca_file,client_ca, client_key, client_password) - http客户端\n传入值：\nstring 请求方法, 支持 GET/POST 等合法的HTTP方法\nstring url地址, 支持 http和https, 支持域名, 支持自定义端口\ntabal 请求头 可选 例如 {[\"Content-Type\"] = \"application/x-www-form-urlencoded\"}\nstring/zbuff body 可选\ntable 额外配置 可选 包含 timeout:超时时间单位ms 可选,默认10分钟,写0即永久等待 dst:下载路径,可选 adapter:选择使用网卡,可选 debug:是否打开debug信息,可选,ipv6:是否为ipv6 默认不是,可选 callback:下载回调函数,参数 content_len:总长度 body_len:以下载长度 userdata 用户传参,可选 userdata:回调自定义传参  \nstring 服务器ca证书数据, 可选, 一般不需要\nstring 客户端ca证书数据, 可选, 一般不需要, 双向https认证才需要\nstring 客户端私钥加密数据, 可选, 一般不需要, 双向https认证才需要\nstring 客户端私钥口令数据, 可选, 一般不需要, 双向https认证才需要\n返回值：\nint code , 服务器反馈的值>=100, 最常见的是200.如果是底层错误,例如连接失败, 返回值小于0\ntabal headers 当code>100时, 代表服务器返回的头部数据 \nstring/int body 服务器响应的内容字符串,如果是下载模式, 则返回文件大小\n例子：\n\n--[[\ncode报错信息列表:\n-1 HTTP_ERROR_STATE 错误的状态, 一般是底层异常,请报issue\n-2 HTTP_ERROR_HEADER 错误的响应头部, 通常是服务器问题\n-3 HTTP_ERROR_BODY 错误的响应体,通常是服务器问题\n-4 HTTP_ERROR_CONNECT 连接服务器失败, 未联网,地址错误,域名错误\n-5 HTTP_ERROR_CLOSE 提前断开了连接, 网络或服务器问题\n-6 HTTP_ERROR_RX 接收数据报错, 网络问题\n-7 HTTP_ERROR_DOWNLOAD 下载文件过程报错, 网络问题或下载路径问题\n-8 HTTP_ERROR_TIMEOUT 超时, 包括连接超时,读取数据超时\n-9 HTTP_ERROR_FOTA fota功能报错,通常是更新包不合法\n]]\n\n-- GET请求\nlocal code, headers, body = http.request(\"GET\",\"http://site0.cn/api/httptest/simple/time\").wait()\nlog.info(\"http.get\", code, headers, body)\n-- POST请求\nlocal code, headers, body = http.request(\"POST\",\"http://httpbin.com/post\", {}, \"abc=123\").wait()\nlog.info(\"http.post\", code, headers, body)\n\n-- GET请求,但下载到文件\nlocal code, headers, body = http.request(\"GET\",\"http://httpbin.com/\", {}, \"\", {dst=\"/data.bin\"}).wait()\nlog.info(\"http.get\", code, headers, body)\n\n-- 自定义超时时间, 5000ms\nhttp.request(\"GET\",\"http://httpbin.com/\", nil, nil, {timeout=5000}).wait()\n"
            },
            {
                "name": "httpsrv.start",
                "snippet": "httpsrv.start(${1:port},${2:func})",
                "description": "httpsrv.start(port, func) - 启动并监听一个http端口\n传入值：\nint 端口号\nfunction 回调函数\n返回值：\nbool 成功返回true, 否则返回false\n例子：\n\n-- 监听80端口\nhttpsrv.start(80, function(client, method, uri, headers, body)\n    -- method 是字符串, 例如 GET POST PUT DELETE\n    -- uri 也是字符串 例如 / /api/abc\n    -- headers table类型\n    -- body 字符串\n    log.info(\"httpsrv\", method, uri, json.encode(headers), body)\n    if uri == \"/led/1\" then\n        LEDA(1)\n        return 200, {}, \"ok\"\n    elseif uri == \"/led/0\" then\n        LEDA(0)\n        return 200, {}, \"ok\"\n    end\n    -- 返回值的约定 code, headers, body\n    -- 若没有返回值, 则默认 404, {} ,\"\"\n    return 404, {}, \"Not Found\" .. uri\nend)\n-- 关于静态文件\n-- 情况1: / , 映射为 /index.html\n-- 情况2: /abc.html , 先查找 /abc.html, 不存在的话查找 /abc.html.gz\n-- 若gz存在, 会自动以压缩文件进行响应, 绝大部分浏览器支持.\n-- 当前默认查找 /luadb/xxx 下的文件,暂不可配置\n"
            },
            {
                "name": "httpsrv.stop",
                "snippet": "httpsrv.stop(${1:port})",
                "description": "httpsrv.stop(port) - 停止http服务\n传入值：\nint 端口号\n返回值：\nnil 当前无返回值\n"
            },
            {
                "name": "i2c.exist",
                "snippet": "i2c.exist(${1:id})",
                "description": "i2c.exist(id) - i2c编号是否存在\n传入值：\nint 设备id, 例如i2c1的id为1, i2c2的id为2\n返回值：\nbool 存在就返回true,否则返回false\n例子：\n-- 检查i2c1是否存在\nif i2c.exist(1) then\n    log.info(\"存在 i2c1\")\nend\n"
            },
            {
                "name": "i2c.setup",
                "snippet": "i2c.setup(${1:id},${2:speed},${3:pullup})",
                "description": "i2c.setup(id, speed, pullup) - i2c初始化\n传入值：\nint 设备id, 例如i2c1的id为1, i2c2的id为2\nint I2C速度, 例如i2c.FAST\nbool 是否软件上拉, 默认不开启，需要硬件支持\n返回值：\nint 成功就返回1,否则返回0\n例子：\n-- 初始化i2c1\ni2c.setup(1, i2c.FAST) -- id正确就一定成功\n-- 如需判断i2c id是否合法, 请使用 i2c.exist 函数\n"
            },
            {
                "name": "i2c.createSoft",
                "snippet": "i2c.createSoft(${1:scl},${2:sda},${3:delay})",
                "description": "i2c.createSoft(scl,sda,delay) - 新建一个软件i2c对象\n传入值：\nint i2c SCL引脚编号(GPIO编号)\nint i2c SDA引脚编号(GPIO编号)\nint 每个操作的延时, 单位us, 默认5\n返回值：\n软件I2C对象 可当作i2c的id使用\n例子：\n-- 注意！这个接口是软件模拟i2c，速度可能会比硬件的慢\n-- 不需要调用i2c.close接口\n-- 初始化软件i2c\nlocal softI2C = i2c.createSoft(1, 2, 5)\ni2c.send(softI2C, 0x5C, string.char(0x0F, 0x2F))\n-- 注意, 第3个参数是 2023.06.19 添加的delay\n-- 通过调整delay参数的值, 可增加或降低I2C的速度\n"
            },
            {
                "name": "i2c.send",
                "snippet": "i2c.send(${1:id},${2:addr},${3:data},${4:stop})",
                "description": "i2c.send(id, addr, data,stop) - i2c发送数据\n传入值：\nint 设备id, 例如i2c1的id为1, i2c2的id为2\nint I2C子设备的地址, 7位地址\ninteger/string/table 待发送的数据,自适应参数类型\ninteger 可选参数 是否发送停止位 1发送 0不发送 默认发送(105不支持)\n返回值：\ntrue/false 发送是否成功\n例子：\n-- 往i2c0发送1个字节的数据\ni2c.send(0, 0x68, 0x75)\n-- 往i2c1发送2个字节的数据\ni2c.send(1, 0x5C, string.char(0x0F, 0x2F))\ni2c.send(1, 0x5C, {0x0F, 0x2F})\n"
            },
            {
                "name": "i2c.recv",
                "snippet": "i2c.recv(${1:id},${2:addr},${3:len})",
                "description": "i2c.recv(id, addr, len) - i2c接收数据\n传入值：\nint 设备id, 例如i2c1的id为1, i2c2的id为2\nint I2C子设备的地址, 7位地址\nint 接收数据的长度\n返回值：\nstring 收到的数据\n例子：\n-- 从i2c1读取2个字节的数据\nlocal data = i2c.recv(1, 0x5C, 2)\n"
            },
            {
                "name": "i2c.writeReg",
                "snippet": "i2c.writeReg(${1:id},${2:addr},${3:reg},${4:data},${5:stop})",
                "description": "i2c.writeReg(id, addr, reg, data,stop) - i2c写寄存器数据\n传入值：\nint 设备id, 例如i2c1的id为1, i2c2的id为2\nint I2C子设备的地址, 7位地址\nint 寄存器地址\nstring 待发送的数据\ninteger 可选参数 是否发送停止位 1发送 0不发送 默认发送(105不支持)\n返回值：\ntrue/false 发送是否成功\n例子：\n-- 从i2c1的地址为0x5C的设备的寄存器0x01写入2个字节的数据\ni2c.writeReg(1, 0x5C, 0x01, string.char(0x00, 0xF2))\n"
            },
            {
                "name": "i2c.readReg",
                "snippet": "i2c.readReg(${1:id},${2:addr},${3:reg},${4:len})",
                "description": "i2c.readReg(id, addr, reg, len) - i2c读寄存器数据\n传入值：\nint 设备id, 例如i2c1的id为1, i2c2的id为2\nint I2C子设备的地址, 7位地址\nint 寄存器地址\nint 待接收的数据长度\ninteger 可选参数 是否发送停止位 1发送 0不发送 默认发送(105不支持)\n返回值：\nstring 收到的数据\n例子：\n-- 从i2c1的地址为0x5C的设备的寄存器0x01读出2个字节的数据\ni2c.readReg(1, 0x5C, 0x01, 2)\n"
            },
            {
                "name": "i2c.close",
                "snippet": "i2c.close(${1:id})",
                "description": "i2c.close(id) - 关闭i2c设备\n传入值：\nint 设备id, 例如i2c1的id为1, i2c2的id为2\n返回值：\nnil 无返回值\n例子：\n-- 关闭i2c1\ni2c.close(1)\n"
            },
            {
                "name": "i2c.readDHT12",
                "snippet": "i2c.readDHT12(${1:id})",
                "description": "i2c.readDHT12(id) - 从i2c总线读取DHT12的温湿度数据\n传入值：\nint 设备id, 例如i2c1的id为1, i2c2的id为2\nint DHT12的设备地址,默认0x5C\n返回值：\nboolean 读取成功返回true,否则返回false\nint 湿度值,单位0.1%, 例如 591 代表 59.1%\nint 温度值,单位0.1摄氏度, 例如 292 代表 29.2摄氏度\n例子：\n-- 从i2c0读取DHT12\ni2c.setup(0)\nlocal re, H, T = i2c.readDHT12(0)\nif re then\n    log.info(\"dht12\", H, T)\nend\n"
            },
            {
                "name": "i2c.readSHT30",
                "snippet": "i2c.readSHT30(${1:id},${2:addr})",
                "description": "i2c.readSHT30(id,addr) - 从i2c总线读取DHT30的温湿度数据(由\"好奇星\"贡献)\n传入值：\nint 设备id, 例如i2c1的id为1, i2c2的id为2\nint 设备addr,SHT30的设备地址,默认0x44 bit7\n返回值：\nboolean 读取成功返回true,否则返回false\nint 湿度值,单位0.1%, 例如 591 代表 59.1%\nint 温度值,单位0.1摄氏度, 例如 292 代表 29.2摄氏度\n例子：\n-- 从i2c0读取SHT30\ni2c.setup(0)\nlocal re, H, T = i2c.readSHT30(0)\nif re then\n    log.info(\"sht30\", H, T)\nend\n"
            },
            {
                "name": "i2c.transfer",
                "snippet": "i2c.transfer(${1:id},${2:addr},${3:txBuff},${4:rxBuff},${5:rxLen})",
                "description": "i2c.transfer(id, addr, txBuff, rxBuff, rxLen) - i2c通用传输，包括发送N字节，发送N字节+接收N字节，接收N字节三种功能，在发送转接收过程中发送reStart信号,解决类似mlx90614必须带restart信号，但是又不能用i2c.send来控制的，比如air105\n传入值：\nint 设备id, 例如i2c1的id为1, i2c2的id为2\nint I2C子设备的地址, 7位地址\ninteger/string/zbuff 待发送的数据,自适应参数类型，如果为nil，则不发送数据\nzbuff 待接收数据的zbuff 如果不用zbuff，则接收数据将在return返回\nint 需要接收的数据长度，如果为0或nil，则不接收数据\n返回值：\nboolean true/false 发送是否成功\nstring or nil 如果参数5是interger，则返回接收到的数据\n例子：\nlocal result, _ = i2c.transfer(0, 0x11, txbuff, rxbuff, 1)\nlocal result, _ = i2c.transfer(0, 0x11, txbuff, nil, 0)    --只发送txbuff里的数据，不接收数据，典型应用就是写寄存器了，这里寄存器地址和值都放在了txbuff里\nlocal result, _ = i2c.transfer(0, 0x11, \"\\x01\\x02\\x03\", nil, 1) --发送0x01， 0x02，0x03，不接收数据，如果是eeprom，就是往0x01的地址写02和03，或者往0x0102的地址写03，看具体芯片了\nlocal result, rxdata = i2c.transfer(0, 0x11, \"\\x01\\x02\", nil, 1) --发送0x01， 0x02，然后接收1个字节，典型应用就是eeprom\nlocal result, rxdata = i2c.transfer(0, 0x11, 0x00, nil, 1) --发送0x00，然后接收1个字节，典型应用各种传感器\n"
            },
            {
                "name": "i2c.xfer",
                "snippet": "i2c.xfer(${1:id},${2:addr},${3:txBuff},${4:rxBuff},${5:rxLen},${6:transfer_done_topic},${7:timeout})",
                "description": "i2c.xfer(id, addr, txBuff, rxBuff, rxLen, transfer_done_topic, timeout) - i2c非阻塞通用传输，类似transfer，但是不会等到I2C传输完成才返回，调用本函数会立刻返回，I2C传输完成后，通过消息回调\n传入值：\nint 设备id, 例如i2c1的id为1, i2c2的id为2\nint I2C子设备的地址, 7位地址\nzbuff 待发送的数据，由于用的非阻塞模型，为保证动态数据的有效性，只能使用zbuff，发送的数据从zbuff.addr开始，长度为zbuff.used\nzbuff 待接收数据的zbuff，如果为nil，则忽略后面参数， 不接收数据。接收的数据会放在zbuff.addr开始的位置，会覆盖掉之前的数据，注意zhuff的预留空间要足够\nint 需要接收的数据长度，如果为0或nil，则不接收数据\nstring 传输完成后回调的消息\nint 超时时间，如果填nil，则为100ms\n返回值：\nboolean true/false 本次传输是否正确启动，true，启动，false，有错误无法启动。传输完成会发布消息transfer_done_topic和boolean型结果\n例子：\nlocal result = i2c.xfer(0, 0x11, txbuff, rxbuff, 1, \"I2CDONE\") if result then result, i2c_id, succ, error_code = sys.waitUntil(\"I2CDONE\") end if not result or not succ then log.info(\"i2c fail, error code\", error_code) else log.info(\"i2c ok\") end\n\n"
            },
            {
                "name": "i2c.scan",
                "snippet": "i2c.scan(${1:id},${2:speed})",
                "description": "i2c.scan(id,speed) - 扫描i2c设备\n传入值：\nint 设备id, 例如i2c1的id为1, i2c2的id为2\nint 速度, 可选i2c.SLOW i2c.FAST i2c.PLUS i2c.HSMODE 默认为i2c.SLOW,如探测不到则修改此项\n返回值：\nnil 当前无返回值\n例子：\n-- 本函数于2023.07.04添加\n-- 这个函数的主要目标是为了在开发期扫描i2c设备\n-- 有些BSP在指定addr无响应时会输出日志,导致输出会被打乱\ni2c.scan()\n"
            },
            {
                "name": "i2s.setup",
                "snippet": "i2s.setup(${1:id},${2:mode},${3:sample},${4:bitw},${5:channel},${6:format},${7:framebit})",
                "description": "i2s.setup(id, mode, sample, bitw, channel, format, framebit) - 初始化i2s\n传入值：\nint i2s通道号,与具体设备有关\nint 模式, 0 主机 1 从机\nint 采样率,默认44100. 可选\nint 数据位数,默认16, 可以是8的倍数\nint 声道, 0 左声道, 1 右声道, 2 立体声. 可选\nint 格式, 可选MODE_I2S, MODE_LSB, MODE_MSB\nint 1个声道的BCLK数量, 可选16和32\n返回值：\nboolean 成功与否\nint 底层返回值\n例子：\n-- 以默认参数初始化i2s\ni2s.setup(0)\n-- 以详细参数初始化i2s, 示例为默认值\ni2s.setup(0, 0, 44100, 16, 0, 0, 16)\n"
            },
            {
                "name": "i2s.send",
                "snippet": "i2s.send(${1:id},${2:data},${3:len})",
                "description": "i2s.send(id, data, len) - 发送i2s数据\n传入值：\nint 通道id\nstring 数据, 可以是字符串或zbuff\nint 数据长度,单位字节, 字符串默认为字符串全长, zbuff默认为指针位置\n返回值：\nboolean 成功与否\nint 底层返回值,供调试用\n例子：\nlocal f = io.open(\"/luadb/abc.wav\")\nwhile 1 do\n    local data = f:read(4096)\n    if not data or #data == 0 then\n        break\n    end\n    i2s.send(0, data)\n    sys.wait(100)\nend\n"
            },
            {
                "name": "i2s.recv",
                "snippet": "i2s.recv(${1:id},${2:buffer},${3:len})",
                "description": "i2s.recv(id, buffer, len) - 接收i2s数据，注意在数据在回调时已经存放在zbuff里，目前只有air780e系列支持\n传入值：\nint 通道id\nzbuff 数据缓存区\nint 单次返回的数据长度,单位字节,必须与传入的zbuff的大小一致\n返回值：\nboolean 成功与否\n例子：\nlocal buffer = zbuff.create(3200)\nlocal succ = i2s.recv(0, buffer, 3200);\n"
            },
            {
                "name": "i2s.close",
                "snippet": "i2s.close(${1:id})",
                "description": "i2s.close(id) - 关闭i2s\n传入值：\nint 通道id\n返回值：\nnil 无返回值\n例子：\ni2s.close(0)\n"
            },
            {
                "name": "i2s.on",
                "snippet": "i2s.on(${1:id},${2:func})",
                "description": "i2s.on(id, func) - 注册I2S事件回调\n传入值：\nint i2s id, i2s0写0, i2s1写1\nfunction 回调方法\n返回值：\nnil 无返回值\n例子：\ni2s.on(0, function(id, buff)\n    if buff then\n        log.info(\"i2s get data in zbuff\")\n    else\n        log.info(\"i2s tx one block done\")\n    end\nend)\n"
            },
            {
                "name": "i2s.txStat",
                "snippet": "i2s.txStat(${1:id})",
                "description": "i2s.txStat(id) - 获取i2s的发送缓冲区状态\n传入值：\nint i2s id, i2s0写0, i2s1写1\nreturn 底层缓冲区的总大小\nreturn 底层缓冲区的剩余待发送数据\n例子：\n-- 读取发送缓冲区的状态, 从而判断是否需要继续传入音频数据\nlocal max, remain = i2s.txStat(0)\nlog.info(\"i2s发送缓冲区状态\", max, remain)\n"
            },
            {
                "name": "i2s.getPara",
                "snippet": "i2s.getPara(${1:id})",
                "description": "i2s.getPara(id) - 获取I2S参数，参数具体参考setup\n传入值：\nint 通道id\n返回值：\nboolean 是否在工作状态 true是\nint 模式, 0 主机 1 从机\nint 采样率\nint 数据位数\nint 声道\nint 格式\nint 1个声道的BCLK数量\n"
            },
            {
                "name": "iconv.open",
                "snippet": "iconv.open(${1:tocode},${2:fromcode})",
                "description": "iconv.open(tocode, fromcode)  - 打开相应字符编码转换函数\n传入值：\nstring tocode$目标编码格式$gb2312/ucs2/ucs2be/utf8\nstring fromcode$源编码格式$gb2312/ucs2/ucs2be/utf8\nreturn table$cd$编码转换函数的转换句柄$ \n例子：\n--unicode大端编码 转化为 utf8编码\nlocal cd = iconv.open(\"utf8\", \"ucs2be\")\n"
            },
            {
                "name": "iconv:iconv",
                "snippet": "iconv:iconv(${1:inbuf})",
                "description": "iconv:iconv(inbuf) - 字符编码转换\n传入值：\nstring 释义：待转换字符串\n返回值：\nnumber 释义：返回编码转换后的结果<br>取值：0成功,-1失败\n例子：\n--unicode大端编码 转化为 utf8编码\nfunction ucs2beToUtf8(ucs2s)\n    local iconv = iconv.open(\"utf8\", \"ucs2be\")\n    return iconv:iconv(ucs2s)\nend\n"
            },
            {
                "name": "cd:iconv",
                "snippet": "cd:iconv(${1:inbuf})",
                "description": "cd:iconv(inbuf)  - 字符编码转换\n传入值：\nstring inbuf$输入字符串$例如:ucs2s \nreturn number$result$返回编码转换后的结果$0成功,-1失败\n例子：\n--unicode大端编码 转化为 utf8编码\nfunction ucs2beToUtf8(ucs2s)\n    local cd = iconv.open(\"utf8\", \"ucs2be\")\n    return cd:iconv(ucs2s)\nend\n"
            },
            {
                "name": "iconv.close",
                "snippet": "iconv.close(${1:cd})",
                "description": "iconv.close(cd)  - 关闭字符编码转换\n传入值：\nstring cd$iconv.open返回的句柄$ \nreturn  \n例子：\n--关闭字符编码转换\nlocal cd = iconv.open(\"utf8\", \"ucs2be\")\niconv.close(cd)\n"
            },
            {
                "name": "io.exists",
                "snippet": "io.exists(${1:path})",
                "description": "io.exists(path) - 判断文件是否存在\n传入值：\nstring 文件路径\n返回值：\nbool 存在返回true,否则返回false\n例子：\nlog.info(\"io\", \"file exists\", io.exists(\"/boottime\"))\n",
                "category": "Input/Output"
            },
            {
                "name": "io.fileSize",
                "snippet": "io.fileSize(${1:path})",
                "description": "io.fileSize(path) - 获取文件大小\n传入值：\nstring 文件路径\n返回值：\nint 文件数据,若文件不存在会返回nil\n例子：\nlocal fsize = io.fileSize(\"/bootime\")\nif fsize and fsize > 1024 then\n  log.info(\"io\", \"file size\", fsize)\nend\n",
                "category": "Input/Output"
            },
            {
                "name": "io.readFile",
                "snippet": "io.readFile(${1:path},${2:mode},${3:offset},${4:len})",
                "description": "io.readFile(path, mode, offset, len) - 读取整个文件,请注意内存消耗\n传入值：\nstring 文件路径\nstring 读取模式, 默认 \"rb\"\nint 起始位置,默认0\nint 读取长度,默认整个文件\n返回值：\nstring 文件数据,若文件不存在会返回nil\n例子：\nlocal data = io.readFile(\"/bootime\")\n-- 注意: offset和len参数是 2023.6.6添加的\n-- 读取abc.txt, 先跳过128字节, 然后读取512字节数据\nlocal data = io.readFile(\"/abc.txt\", \"rb\", 128, 512)\n",
                "category": "Input/Output"
            },
            {
                "name": "io.writeFile",
                "snippet": "io.writeFile(${1:path},${2:data})",
                "description": "io.writeFile(path, data) - 将数据写入文件\n传入值：\nstring 文件路径\nstring 数据\n返回值：\nboolean 成功返回true, 否则返回false\n例子：\nio.writeFile(\"/bootime\", \"1\")\n",
                "category": "Input/Output"
            },
            {
                "name": "io.fill",
                "snippet": "io.fill(${1:buff},${2:offset},${3:len})",
                "description": "io.fill(buff, offset, len) - 读取文件并填充到zbuff内,但不移动指针位置\n传入值：\nuserdata zbuff实体\nint 写入的位置,默认是0\nint 写入的长度,默认是zbuff的len减去offset\n返回值：\nboolean 成功返回true,否则返回false\nint 返回实际读取到的长度，如果小于0也说明是读取失败了\n例子：\nlocal buff = zbuff.create(1024)\nlocal f = io.open(\"/sd/test.txt\")\nif f then\n  f:fill(buff)\nend\n",
                "category": "Input/Output"
            },
            {
                "name": "io.mkfs",
                "snippet": "io.mkfs(${1:path})",
                "description": "io.mkfs(path) - 格式化文件系统,需指定挂载点\n传入值：\nstring 挂载点\n返回值：\nbool 成功与否\nint 底层返回值\n例子：\nlocal ret, errio = io.mkfs(\"/sd\")\nlog.info(\"fs\", \"mkfs\", ret, errio)\n",
                "category": "Input/Output"
            },
            {
                "name": "io.mkdir",
                "snippet": "io.mkdir(${1:path})",
                "description": "io.mkdir(path) - 创建文件夹\n传入值：\nstring 需要建立的目录路径\n返回值：\nbool 成功与否\nint 底层返回值\n例子：\nlocal ret, errio = io.mkdir(\"/data/\")\nlog.info(\"fs\", \"mkdir\", ret, errio)\n",
                "category": "Input/Output"
            },
            {
                "name": "io.rmdir",
                "snippet": "io.rmdir(${1:path})",
                "description": "io.rmdir(path) - 删除文件夹\n传入值：\nstring 需要移除的目录路径\n返回值：\nbool 成功与否\nint 底层返回值\n例子：\nlocal ret, errio = io.rmdir(\"/data/\")\nlog.info(\"fs\", \"rmdir\", ret, errio)\n",
                "category": "Input/Output"
            },
            {
                "name": "io.lsdir",
                "snippet": "io.lsdir(${1:path},${2:len},${3:offset})",
                "description": "io.lsdir(path, len, offset) - 列出目录下的文件\n传入值：\nstring 需要枚举的目录路径\nint 最大长度, 默认10, 最高50\nint 偏移量, 默认0, 当目录文件很多时分页查询用\n返回值：\nbool 成功与否\nint 底层返回值\n例子：\nlocal ret, data = io.lsdir(\"/data/\", 10, 0)\nif ret then\n  log.info(\"fs\", \"lsdir\", json.encode(data))\nelse\n  log.info(\"fs\", \"lsdir\", \"fail\", ret, data)\nend\n",
                "category": "Input/Output"
            },
            {
                "name": "io.lsmount",
                "snippet": "io.lsmount()",
                "description": "io.lsmount() - 列出所有挂载点\n返回值：\ntable 挂载点列表\n例子：\nlocal data = io.lsmount()\nlog.info(\"fs\", \"lsmount\", json.encode(data))\n",
                "category": "Input/Output"
            },
            {
                "name": "ioqueue.init",
                "snippet": "ioqueue.init(${1:hwtimer_id},${2:cmd_cnt},${3:repeat_cnt})",
                "description": "ioqueue.init(hwtimer_id,cmd_cnt,repeat_cnt) - 初始化一个io操作队列\n传入值：\nint 硬件定时器id，默认用0，根据实际MCU确定，air105为0~5，与pwm共用，同一个通道号不能同时为pwm和ioqueue\nint 一个完整周期需要的命令，可以比实际的多\nint 重复次数,默认是1，如果写0则表示无限次数循环\nreturn 无\n例子：\nioqueue.init(0,10,5) --以timer0为时钟源初始化一个io操作队列，有10个有效命令，循环5次\n"
            },
            {
                "name": "ioqueue.setdelay",
                "snippet": "ioqueue.setdelay(${1:hwtimer_id},${2:time_us},${3:time_tick},${4:continue})",
                "description": "ioqueue.setdelay(hwtimer_id,time_us,time_tick,continue) - 对io操作队列增加延时命令\n传入值：\nint 硬件定时器id\nint 延时时间,0~65535us\nint 延时微调时间,0~255tick,总的延时时间是time_us * 1us_tick + time_tick\nboolean 是否连续是连续延时，默认否，如果是，定时器在时间到后不会停止而是重新计时，\n"
            },
            {
                "name": "ioqueue.delay",
                "snippet": "ioqueue.delay(${1:hwtimer_id})",
                "description": "ioqueue.delay(hwtimer_id) - 对io操作队列增加一次重复延时，在前面必须有setdelay且是连续延时\n传入值：\nint 硬件定时器id\nreturn 无\n例子：\nioqueue.setdelay(0,9,15,true) --延时9us+15个tick,在之后遇到delay命令时，会延时9us+15个tick\nioqueue.delay(0)\n"
            },
            {
                "name": "ioqueue.setgpio",
                "snippet": "ioqueue.setgpio(${1:hwtimer_id},${2:pin},${3:is_input},${4:pull_mode},${5:init_level})",
                "description": "ioqueue.setgpio(hwtimer_id,pin,is_input,pull_mode,init_level) - 对io操作队列增加设置gpio命令\n传入值：\nint 硬件定时器id\nint pin\nboolean 是否是输入\nint 上下拉模式,只能是0,gpio.PULLUP,gpio.PULLDOWN\nint 初始输出电平\nreturn 无\n例子：\nioqueue.setgpio(0,pin.PB01,true,gpio.PULLUP,0) --PB01设置成上拉输入\nioqueue.setgpio(0,pin.PB01,false,0,1)--PB01设置成默认上下拉输出高电平\n"
            },
            {
                "name": "ioqueue.input",
                "snippet": "ioqueue.input(${1:hwtimer_id},${2:pin})",
                "description": "ioqueue.input(hwtimer_id,pin) - 对io操作队列增加读取gpio命令\n传入值：\nint 硬件定时器id\nint pin\nreturn 无\n例子：\nioqueue.input(0,pin.PB01)\n\n"
            },
            {
                "name": "ioqueue.output",
                "snippet": "ioqueue.output(${1:hwtimer_id},${2:pin},${3:level})",
                "description": "ioqueue.output(hwtimer_id,pin,level) - 对io操作队列增加输出GPIO命令\n传入值：\nint 硬件定时器id\nint pin\nint 输出电平\nreturn 无\n例子：\nioqueue.output(0,pin.PB01,0)\n"
            },
            {
                "name": "ioqueue.set_cap",
                "snippet": "ioqueue.set_cap(${1:hwtimer_id},${2:pin},${3:pull_mode},${4:irq_mode},${5:max_tick})",
                "description": "ioqueue.set_cap(hwtimer_id,pin,pull_mode,irq_mode,max_tick) - 对io操作队列增加设置捕获某个IO命令\n传入值：\nint 硬件定时器id\nint pin\nint 上下拉模式,只能是0,gpio.PULLUP,gpio.PULLDOWN\nint 中断模式,只能是gpio.BOTH,gpio.RISING,gpio.FALLING\nint 定时器最大计时时间 考虑到lua是int类型，最小0x10000, 最大值为0x7fffffff，默认为最大值\nreturn 无\n例子：\nioqueue.setcap(0,pin.PB01,gpio.PULLUP,gpio.FALLING,48000000)\n"
            },
            {
                "name": "ioqueue.capture",
                "snippet": "ioqueue.capture(${1:hwtimer_id})",
                "description": "ioqueue.capture(hwtimer_id) - 对io操作队列增加捕获一次IO状态命令\n传入值：\nint 硬件定时器id\nreturn 无\n例子：\nioqueue.capture(0)\n"
            },
            {
                "name": "ioqueue.capend",
                "snippet": "ioqueue.capend(${1:hwtimer_id},${2:pin})",
                "description": "ioqueue.capend(hwtimer_id,pin) - 对io操作队列增加结束捕获某个IO命令\n传入值：\nint 硬件定时器id\nint pin\nreturn 无\n例子：\nioqueue.capend(0,pin.PB01)\n"
            },
            {
                "name": "ioqueue.get",
                "snippet": "ioqueue.get(${1:hwtimer_id},${2:input_buff},${3:capture_buff})",
                "description": "ioqueue.get(hwtimer_id, input_buff, capture_buff) - * 获取io操作队列中输入和捕获的数据\n传入值：\nint 硬件定时器id\nzbuff 存放IO输入数据的buff，按照1byte pin + 1byte level 形式存放数据\nzbuff 存放IO捕获数据的buff，按照1byte pin + 1byte level + 4byte tick形式存放数据\n返回值：\nint 返回多少组IO输入数据\nint 返回多少组IO捕获数据\n例子：\nlocal input_cnt, capture_cnt = ioqueue.get(0, input_buff, capture_buff)\n"
            },
            {
                "name": "ioqueue.start",
                "snippet": "ioqueue.start(${1:hwtimer_id})",
                "description": "ioqueue.start(hwtimer_id) - 启动io操作队列\n传入值：\nint 硬件定时器id\nreturn 无\n例子：\nioqueue.start(0)\n"
            },
            {
                "name": "ioqueue.stop",
                "snippet": "ioqueue.stop(${1:hwtimer_id})",
                "description": "ioqueue.stop(hwtimer_id) - 停止io操作队列，可以通过start从头开始\n传入值：\nint 硬件定时器id\n返回值：\nint 返回已经循环的次数，如果是0，表示一次循环都没有完成\nint 返回单次循环中已经执行的cmd次数，如果是0，可能是一次循环刚刚结束\n例子：\nioqueue.stop(0)\n"
            },
            {
                "name": "ioqueue.release",
                "snippet": "ioqueue.release(${1:hwtimer_id})",
                "description": "ioqueue.release(hwtimer_id) - 释放io操作队列的资源，下次使用必须重新init\n传入值：\nint 硬件定时器id\nreturn 无\n例子：\nioqueue.clear(0)\n"
            },
            {
                "name": "ioqueue.clear",
                "snippet": "ioqueue.clear(${1:hwtimer_id})",
                "description": "ioqueue.clear(hwtimer_id) - 清空io操作队列\n传入值：\nint 硬件定时器id\nreturn 无\n例子：\nioqueue.clear(0)\n"
            },
            {
                "name": "ioqueue.done",
                "snippet": "ioqueue.done(${1:hwtimer_id})",
                "description": "ioqueue.done(hwtimer_id) - 检测io操作队列是否已经执行完成\n传入值：\nint 硬件定时器id\n返回值：\nboolean 队列是否执行完成，\n例子：\nlocal result = ioqueue.done(0)\n"
            },
            {
                "name": "ioqueue.exti",
                "snippet": "ioqueue.exti(${1:pin},${2:pull_mode},${3:irq_mode},${4:onoff})",
                "description": "ioqueue.exti(pin,pull_mode,irq_mode,onoff) - 启动/停止一个带系统tick返回的外部中断\n传入值：\nint pin\nint 上下拉模式,只能是0,gpio.PULLUP,gpio.PULLDOWN\nint 中断模式,只能是gpio.BOTH,gpio.RISING,gpio.FALLING\nboolean 开关，默认是false关\nreturn 无\n例子：\nioqueue.exti(pin.PB01, gpio.PULLUP, gpio.BOTH, true)\nioqueue.exti(pin.PB01)\n"
            },
            {
                "name": "iotauth.aliyun",
                "snippet": "iotauth.aliyun(${1:product_key},${2:device_name},${3:device_secret},${4:method},${5:cur_timestamp})",
                "description": "iotauth.aliyun(product_key, device_name,device_secret,method,cur_timestamp) - 阿里云物联网平台三元组生成\n传入值：\nstring product_key\nstring device_name\nstring device_secret\nstring method 加密方式,\"hmacmd5\" \"hmacsha1\" \"hmacsha256\" 可选,默认\"hmacmd5\"\nnumber cur_timestamp 可选 默认为 32472115200(2999-01-01 0:0:0)\nbool istls 是否TLS直连 true:TLS直连  false:TCP直连模式 默认TCP直连模式\n返回值：\nstring mqtt三元组 client_id\nstring mqtt三元组 user_name\nstring mqtt三元组 password\n例子：\nlocal client_id,user_name,password = iotauth.aliyun(\"123456789\",\"abcdefg\",\"Y877Bgo8X5owd3lcB5wWDjryNPoB\")\nprint(client_id,user_name,password)\n"
            },
            {
                "name": "iotauth.onenet",
                "snippet": "iotauth.onenet(${1:produt_id},${2:device_name},${3:key},${4:method},${5:cur_timestamp},${6:version})",
                "description": "iotauth.onenet(produt_id, device_name,key,method,cur_timestamp,version) - 中国移动物联网平台三元组生成\n传入值：\nstring produt_id 产品id\nstring device_name 设备名称\nstring key  设备密钥或者项目的acess_key\nstring method 加密方式,\"md5\" \"sha1\" \"sha256\" 可选,默认\"md5\"\nnumber 时间戳, 不用填\nstring version 可选 默认\"2018-10-31\"\nstring 当key是access_key时, 填 \"products/\" .. product_id . 本参数于2024.1.29新增\n返回值：\nstring mqtt三元组 client_id\nstring mqtt三元组 user_name\nstring mqtt三元组 password\n例子：\n-- OneNet平台官网: https://open.iot.10086.cn/\n-- OneNet有多种版本, 注意区分, 一般来说produt_id纯数字就是老版本, 否则就是新版本\n\n-- 新版OneNET平台, 产品id是英文字母字符串\n-- 对应demo/onenet/studio\nlocal produt_id = \"Ck2AF9QD2K\"\nlocal device_name = \"test\"\nlocal device_key = \"KuF3NT/jUBJ62LNBB/A8XZA9CqS3Cu79B/ABmfA1UCw=\"\nlocal client_id,user_name,password = iotauth.onenet(produt_id, device_name, device_key)\nlog.info(\"onenet.new\", client_id,user_name,password)\n\n-- 旧版OneNET平台, 产品id是数字字符串. 2024.1.29新增\n-- 对应demo/onenet/old_mqtt\nlocal produt_id = \"12342334\"\nlocal device_name = \"test\"\nlocal access_key = \"adfasdfadsfadsf=\"\nlocal client_id,user_name,password = iotauth.onenet(produt_id, device_name, access_key, nil, nil, nil, \"products/\" .. produt_id)\nlog.info(\"onenet.old\", client_id,user_name,password)\n\n"
            },
            {
                "name": "iotauth.iotda",
                "snippet": "iotauth.iotda(${1:device_id},${2:device_secret},${3:cur_timestamp})",
                "description": "iotauth.iotda(device_id,device_secret,cur_timestamp) - 华为物联网平台三元组生成\n传入值：\nstring device_id\nstring device_secret\nnumber cur_timestamp 可选 如不填则不校验时间戳\n返回值：\nstring mqtt三元组 client_id\nstring mqtt三元组 user_name\nstring mqtt三元组 password\n例子：\nlocal client_id,user_name,password = iotauth.iotda(\"6203cc94c7fb24029b110408_88888888\",\"123456789\")\nprint(client_id,user_name,password)\n"
            },
            {
                "name": "iotauth.qcloud",
                "snippet": "iotauth.qcloud(${1:product_id},${2:device_name},${3:device_secret},${4:method},${5:cur_timestamp},${6:sdk_appid})",
                "description": "iotauth.qcloud(product_id, device_name,device_secret,method,cur_timestamp,sdk_appid) - 腾讯联网平台三元组生成\n传入值：\nstring 产品id,创建项目后可以查看到,类似于LD8S5J1L07\nstring 设备名称,例如设备的imei号\nstring 设备密钥,创建设备后,查看设备详情可得到\nstring method 加密方式,\"sha1\" \"sha256\" 可选,默认\"sha256\"\nnumber cur_timestamp 可选 默认为 32472115200(2999-01-01 0:0:0)\nstring sdk_appid 可选 默认为\"12010126\"\n返回值：\nstring mqtt三元组 client_id\nstring mqtt三元组 user_name\nstring mqtt三元组 password\n例子：\nlocal client_id,user_name,password = iotauth.qcloud(\"LD8S5J1L07\",\"test\",\"acyv3QDJrRa0fW5UE58KnQ==\")\nprint(client_id,user_name,password)\n"
            },
            {
                "name": "iotauth.tuya",
                "snippet": "iotauth.tuya(${1:device_id},${2:device_secret},${3:cur_timestamp})",
                "description": "iotauth.tuya(device_id,device_secret,cur_timestamp) - 涂鸦联网平台三元组生成\n传入值：\nstring device_id\nstring device_secret\nnumber cur_timestamp 可选 默认7258089600(2200-01-01 0:0:0)\n返回值：\nstring mqtt三元组 client_id\nstring mqtt三元组 user_name\nstring mqtt三元组 password\n例子：\nlocal client_id,user_name,password = iotauth.tuya(\"6c95875d0f5ba69607nzfl\",\"fb803786602df760\")\nprint(client_id,user_name,password)\n"
            },
            {
                "name": "iotauth.baidu",
                "snippet": "iotauth.baidu(${1:iot_core_id},${2:device_key},${3:device_secret},${4:method},${5:cur_timestamp})",
                "description": "iotauth.baidu(iot_core_id, device_key,device_secret,method,cur_timestamp) - 百度物联网平台三元组生成\n传入值：\nstring iot_core_id\nstring device_key\nstring device_secret\nstring method 加密方式,\"MD5\" \"SHA256\" 可选,默认\"MD5\"\nnumber cur_timestamp 可选 如不填则不校验时间戳\n返回值：\nstring mqtt三元组 client_id\nstring mqtt三元组 user_name\nstring mqtt三元组 password\n例子：\nlocal client_id,user_name,password = iotauth.baidu(\"abcd123\",\"mydevice\",\"ImSeCrEt0I1M2jkl\")\nprint(client_id,user_name,password)\n"
            },
            {
                "name": "ir.sendNEC",
                "snippet": "ir.sendNEC(${1:pin},${2:addr},${3:cmd},${4:repeat},${5:disablePWM})",
                "description": "ir.sendNEC(pin, addr, cmd, repeat, disablePWM) - 发送NEC数据\n传入值：\nint 使用的GPIO引脚编号\nint 用户码（大于0xff则采用Extended NEC模式）\nint 数据码\nint 可选，引导码发送次数（110ms一次），默认0次\nbool 可选，是否禁止直接发送pwm波，默认false\n例子：\n--直接发\nir.sendNEC(0, 0x11, 0x22)\n--外接了38K的PWM载波，只控制电平\nir.sendNEC(0, 0x11, 0x22,0,true)\n"
            },
            {
                "name": "json.encode",
                "snippet": "json.encode(${1:obj},${2:t})",
                "description": "json.encode(obj,t) - 将对象序列化为json字符串\n传入值：\nobj 需要序列化的对象\nstring 浮点数精度和模式,这项不存在的时候,为默认值\"7f\",数字只支持\"0~14\",模式只支持\"f/g\"\n返回值：\nstring 序列化后的json字符串, 失败的话返回nil\nstring 序列化失败的报错信息\n例子：\njson.encode(obj)-->浮点数用%.7g的方式转换为字符串\njson.encode(obj,\"12f\")-->浮点数用%.12f的方式转换为字符串\n\n-- 2024.1.9 起, 默认使用7f格式化浮点数\n-- 之前的版本使用 7g格式化浮动数\n"
            },
            {
                "name": "json.decode",
                "snippet": "json.decode(${1:str})",
                "description": "json.decode(str) - 将字符串反序列化为对象\n传入值：\nstring 需要反序列化的json字符串\n返回值：\nobj 反序列化后的对象(通常是table), 失败的话返回nil\nresult 成功返回1,否则返回0\nerr 反序列化失败的报错信息\n例子：\njson.decode(\"[1,2,3,4,5,6]\")\n"
            },
            {
                "name": "keyboard.init",
                "snippet": "keyboard.init(${1:port},${2:conf},${3:map},${4:debounce})",
                "description": "keyboard.init(port, conf, map, debounce) - 初始化键盘矩阵\n传入值：\nint 预留, 当前填0\nint 启用的keyboard管脚掩码, 例如使用keyboard0~9, 则掩码为 0x1FF, 若使用 0~3 则 0xF\nint keyboard管脚方向映射, 其中输入为0,输出为1, 按位设置.  例如 keyboard0~3作为输入, keyboard4~7为输入, 则 0xF0\nint 消抖配置,预留,可以不填\n例子：\n-- 做一个 4*4 键盘矩阵, 使用 keyboard0~7, 其中0~3做输入, 4~7做输出\n-- 使用 keyboard0~7, 对应conf为 0xFF\n-- 其中0~3做输入, 4~7做输出, 对应map 为 0xF0\nkeyboard.init(0, 0xFF, 0xF0)\n\n-- 做一个 2*3 键盘矩阵, 使用 keyboard0~4, 其中0~1做输入, 2~4做输出\n-- 使用 keyboard0~4, 二进制为 11111,  对应conf的十六进制表达为 0x1F\n-- 其中0~1做输入, 2~4做输出, 二进制为 11100 对应map 为 0x14\n-- keyboard.init(0, 0xFF, 0x14)\n\nsys.subscribe(\"KB_INC\", function(port, data, state)\n    -- port 当前固定为0, 可以无视\n    -- data, 需要配合init的map进行解析\n    -- state, 1 为按下, 0 为 释放\n    -- TODO 详细介绍\nend)\n"
            },
            {
                "name": "lcd.init",
                "snippet": "lcd.init(${1:tp},${2:args},${3:spi_dev},${4:init_in_service})",
                "description": "lcd.init(tp, args, spi_dev, init_in_service) - lcd显示屏初始化\n传入值：\nstring lcd类型，当前支持：<br>st7796<br>st7789<br>st7735<br>st7735v<br>st7735s<br>gc9a01<br>gc9106l<br>gc9306x<br>ili9486<br>custom\ntable 附加参数,与具体设备有关：<br>pin_pwr（背光）为可选项,可不设置<br>port：spi端口,例如0,1,2...如果为device方式则为\"device\"<br>pin_dc：lcd数据/命令选择引脚<br>pin_rst：lcd复位引脚<br>pin_pwr：lcd背光引脚 可选项,可不设置<br>direction：lcd屏幕方向 0:0° 1:180° 2:270° 3:90°<br>w：lcd 水平分辨率<br>h：lcd 竖直分辨率<br>xoffset：x偏移(不同屏幕ic 不同屏幕方向会有差异)<br>yoffset：y偏移(不同屏幕ic 不同屏幕方向会有差异)<br>direction0：0°方向命令，(不同屏幕ic会有差异)<br>direction90：90°方向命令，(不同屏幕ic会有差异)<br>direction180：180°方向命令，(不同屏幕ic会有差异)<br>direction270：270°方向命令，(不同屏幕ic会有差异) <br>sleepcmd：睡眠命令，默认0X10<br>wakecmd：唤醒命令，默认0X11 <br>interface_mode lcd模式，默认lcd.WIRE_4_BIT_8_INTERFACE_I\nuserdata spi设备,当port = \"device\"时有效\nboolean 允许初始化在lcd service里运行，默认是false\n例子：\n-- 初始化spi0的st7735s 注意:lcd初始化之前需要先初始化spi\nspi_lcd = spi.deviceSetup(0,20,0,0,8,2000000,spi.MSB,1,1)\nlog.info(\"lcd.init\",\nlcd.init(\"st7735s\",{port = \"device\",pin_dc = 17, pin_pwr = 7,pin_rst = 19,direction = 2,w = 160,h = 80,xoffset = 1,yoffset = 26},spi_lcd))\n"
            },
            {
                "name": "lcd.close",
                "snippet": "lcd.close()",
                "description": "lcd.close() - 关闭lcd显示屏\n例子：\n-- 关闭lcd\nlcd.close()\n"
            },
            {
                "name": "lcd.on",
                "snippet": "lcd.on()",
                "description": "lcd.on() - 开启lcd显示屏背光\n例子：\n-- 开启lcd显示屏背光\nlcd.on()\n"
            },
            {
                "name": "lcd.off",
                "snippet": "lcd.off()",
                "description": "lcd.off() - 关闭lcd显示屏背光\n例子：\n-- 关闭lcd显示屏背光\nlcd.off()\n"
            },
            {
                "name": "lcd.sleep",
                "snippet": "lcd.sleep()",
                "description": "lcd.sleep() - lcd睡眠\n例子：\n-- lcd睡眠\nlcd.sleep()\n"
            },
            {
                "name": "lcd.wakeup",
                "snippet": "lcd.wakeup()",
                "description": "lcd.wakeup() - lcd唤醒\n例子：\n-- lcd唤醒\nlcd.wakeup()\n"
            },
            {
                "name": "lcd.invon",
                "snippet": "lcd.invon()",
                "description": "lcd.invon() - lcd反显\n例子：\n-- lcd反显\nlcd.invon()\n"
            },
            {
                "name": "lcd.invoff",
                "snippet": "lcd.invoff()",
                "description": "lcd.invoff() - lcd反显关闭\n例子：\n-- lcd反显关闭\nlcd.invoff()\n"
            },
            {
                "name": "lcd.cmd",
                "snippet": "lcd.cmd(${1:cmd})",
                "description": "lcd.cmd(cmd) - lcd命令\n传入值：\nint cmd\n例子：\n-- lcd命令\nlcd.cmd(0x21)\n"
            },
            {
                "name": "lcd.data",
                "snippet": "lcd.data(${1:data})",
                "description": "lcd.data(data) - lcd数据\n传入值：\nint data\n例子：\n-- lcd数据\nlcd.data(0x21)\n"
            },
            {
                "name": "lcd.setColor",
                "snippet": "lcd.setColor(${1:back},${2:fore})",
                "description": "lcd.setColor(back,fore) - lcd颜色设置\n传入值：\nint 背景色\nint 前景色\n例子：\n-- lcd颜色设置\nlcd.setColor(0xFFFF,0x0000)\n"
            },
            {
                "name": "lcd.draw",
                "snippet": "lcd.draw(${1:x1},${2:y1},${3:x2},${4:y2},${5:color})",
                "description": "lcd.draw(x1, y1, x2, y2,color) - lcd颜色填充\n传入值：\nint 左上边缘的X位置.\nint 左上边缘的Y位置.\nint 右下边缘的X位置.\nint 右下边缘的Y位置.\nstring 字符串或zbuff对象\n例子：\n-- lcd颜色填充\nlocal buff = zbuff.create({201,1,16},0x001F)\nlcd.draw(20,30,220,30,buff)\n"
            },
            {
                "name": "lcd.clear",
                "snippet": "lcd.clear(${1:color})",
                "description": "lcd.clear(color) - lcd清屏\n传入值：\nint 屏幕颜色 可选参数,默认背景色\n例子：\n-- lcd清屏\nlcd.clear()\n"
            },
            {
                "name": "lcd.fill",
                "snippet": "lcd.fill(${1:x1},${2:y1},${3:x2},${4:y2},${5:color})",
                "description": "lcd.fill(x1, y1, x2, y2,color) - lcd颜色填充\n传入值：\nint 左上边缘的X位置.\nint 左上边缘的Y位置.\nint 右下边缘的X位置,不含\nint 右下边缘的Y位置,不含\nint 绘画颜色 可选参数,默认背景色\n例子：\n-- lcd颜色填充\nlcd.fill(20,30,220,30,0x0000)\n"
            },
            {
                "name": "lcd.drawPoint",
                "snippet": "lcd.drawPoint(${1:x0},${2:y0},${3:color})",
                "description": "lcd.drawPoint(x0,y0,color) - 画一个点.\n传入值：\nint 点的X位置.\nint 点的Y位置.\nint 绘画颜色 可选参数,默认前景色\n例子：\nlcd.drawPoint(20,30,0x001F)\n"
            },
            {
                "name": "lcd.drawLine",
                "snippet": "lcd.drawLine(${1:x0},${2:y0},${3:x1},${4:y1},${5:color})",
                "description": "lcd.drawLine(x0,y0,x1,y1,color) - 在两点之间画一条线.\n传入值：\nint 第一个点的X位置.\nint 第一个点的Y位置.\nint 第二个点的X位置.\nint 第二个点的Y位置.\nint 绘画颜色 可选参数,默认前景色\n例子：\nlcd.drawLine(20,30,220,30,0x001F)\n"
            },
            {
                "name": "lcd.drawRectangle",
                "snippet": "lcd.drawRectangle(${1:x0},${2:y0},${3:x1},${4:y1},${5:color})",
                "description": "lcd.drawRectangle(x0,y0,x1,y1,color) - 从x / y位置（左上边缘）开始绘制一个框\n传入值：\nint 左上边缘的X位置.\nint 左上边缘的Y位置.\nint 右下边缘的X位置.\nint 右下边缘的Y位置.\nint 绘画颜色 可选参数,默认前景色\n例子：\nlcd.drawRectangle(20,40,220,80,0x001F)\n"
            },
            {
                "name": "lcd.drawCircle",
                "snippet": "lcd.drawCircle(${1:x0},${2:y0},${3:r},${4:color})",
                "description": "lcd.drawCircle(x0,y0,r,color) - 从x / y位置（圆心）开始绘制一个圆\n传入值：\nint 圆心的X位置.\nint 圆心的Y位置.\nint 半径.\nint 绘画颜色 可选参数,默认前景色\n例子：\nlcd.drawCircle(120,120,20,0x001F)\n"
            },
            {
                "name": "lcd.drawQrcode",
                "snippet": "lcd.drawQrcode(${1:x},${2:y},${3:str},${4:size})",
                "description": "lcd.drawQrcode(x, y, str, size) - 缓冲区绘制QRCode\n传入值：\nint x坐标\nint y坐标\nstring 二维码的内容\nint 显示大小 (注意:二维码生成大小与要显示内容和纠错等级有关,生成版本为1-40(对应 21x21 - 177x177)的不定大小,如果和设置大小不同会自动在指定的区域中间显示二维码,如二维码未显示请查看日志提示)\n返回值：\nnil 无返回值\n"
            },
            {
                "name": "lcd.setFont",
                "snippet": "lcd.setFont(${1:font},${2:indentation})",
                "description": "lcd.setFont(font, indentation) - 设置字体\n传入值：\nint font lcd.font_XXX 请查阅常量表\nint indentation, 等宽字体ascii右侧缩进0~127个pixel，等宽字体的ascii字符可能在右侧有大片空白，用户可以选择删除部分。留空或者超过127则直接删除右半边, 非等宽字体无效\n例子：\n-- 设置为字体,对之后的drawStr有效,调用lcd.drawStr前一定要先设置\n\n-- 若提示 \"only font pointer is allow\" , 则代表当前固件不含对应字体, 可使用云编译服务免费定制\n-- 云编译文档: https://wiki.luatos.com/develop/compile/Cloud_compilation.html\n\n-- lcd库的默认字体均以 lcd.font_ 开头\nlcd.setFont(lcd.font_opposansm12)\nlcd.drawStr(40,10,\"drawStr\")\nsys.wait(2000)\nlcd.setFont(lcd.font_opposansm12_chinese) -- 具体取值可参考api文档的常量表\nlcd.drawStr(40,40,\"drawStr测试\")\n"
            },
            {
                "name": "lcd.drawStr",
                "snippet": "lcd.drawStr(${1:x},${2:y},${3:str},${4:fg_color})",
                "description": "lcd.drawStr(x,y,str,fg_color) - 显示字符串\n传入值：\nint x 横坐标\nint y 竖坐标  注意:此(x,y)为左下起始坐标\nstring str 文件内容\nint fg_color str颜色 注意:此参数可选，如不填写则使用之前设置的颜色，绘制只会绘制字体部分，背景需要自己清除\n例子：\n-- 显示之前先设置为中文字体,对之后的drawStr有效\nlcd.setFont(lcd.font_opposansm12)\nlcd.drawStr(40,10,\"drawStr\")\nsys.wait(2000)\nlcd.setFont(lcd.font_opposansm16_chinese)\nlcd.drawStr(40,40,\"drawStr测试\")\n"
            },
            {
                "name": "lcd.drawGtfontGb2312",
                "snippet": "lcd.drawGtfontGb2312(${1:str},${2:size},${3:x},${4:y})",
                "description": "lcd.drawGtfontGb2312(str,size,x,y) - 使用gtfont显示gb2312字符串\n传入值：\nstring str 显示字符串\nint size 字体大小 (支持16-192号大小字体)\nint x 横坐标\nint y 竖坐标\n例子：\n-- 注意, gtfont是额外的字体芯片硬件, 需要外挂在SPI总线才能调用本函数的\nlcd.drawGtfontGb2312(\"啊啊啊\",32,0,0)\n"
            },
            {
                "name": "lcd.drawGtfontGb2312Gray",
                "snippet": "lcd.drawGtfontGb2312Gray(${1:str},${2:size},${3:gray},${4:x},${5:y})",
                "description": "lcd.drawGtfontGb2312Gray(str,size,gray,x,y) - 使用gtfont灰度显示gb2312字符串\n传入值：\nstring str 显示字符串\nint size 字体大小 (支持16-192号大小字体)\nint gray 灰度[1阶/2阶/3阶/4阶]\nint x 横坐标\nint y 竖坐标\n例子：\n-- 注意, gtfont是额外的字体芯片硬件, 需要外挂在SPI总线才能调用本函数的\nlcd.drawGtfontGb2312Gray(\"啊啊啊\",32,4,0,40)\n"
            },
            {
                "name": "lcd.drawGtfontUtf8",
                "snippet": "lcd.drawGtfontUtf8(${1:str},${2:size},${3:x},${4:y})",
                "description": "lcd.drawGtfontUtf8(str,size,x,y) - 使用gtfont显示UTF8字符串\n传入值：\nstring str 显示字符串\nint size 字体大小 (支持16-192号大小字体)\nint x 横坐标\nint y 竖坐标\n例子：\nlcd.drawGtfontUtf8(\"啊啊啊\",32,0,0)\n"
            },
            {
                "name": "lcd.drawGtfontUtf8Gray",
                "snippet": "lcd.drawGtfontUtf8Gray(${1:str},${2:size},${3:gray},${4:x},${5:y})",
                "description": "lcd.drawGtfontUtf8Gray(str,size,gray,x,y) - 使用gtfont灰度显示UTF8字符串\n传入值：\nstring str 显示字符串\nint size 字体大小 (支持16-192号大小字体)\nint gray 灰度[1阶/2阶/3阶/4阶]\nint x 横坐标\nint y 竖坐标\n例子：\nlcd.drawGtfontUtf8Gray(\"啊啊啊\",32,4,0,40)\n"
            },
            {
                "name": "lcd.getSize",
                "snippet": "lcd.getSize()",
                "description": "lcd.getSize() - 获取屏幕尺寸\n返回值：\nint 宽, 如果未初始化会返回0\nint 高, 如果未初始化会返回0\n例子：\nlog.info(\"lcd\", \"size\", lcd.getSize())\n"
            },
            {
                "name": "lcd.drawXbm",
                "snippet": "lcd.drawXbm(${1:x},${2:y},${3:w},${4:h},${5:data})",
                "description": "lcd.drawXbm(x, y, w, h, data) - 绘制位图\n传入值：\nint X坐标\nint y坐标\nint 位图宽\nint 位图高\nint 位图数据,每一位代表一个像素\n例子：\n-- 取模使用PCtoLCD2002软件即可 阴码 逐行 逆向\n-- 在(0,0)为左上角,绘制 16x16 \"今\" 的位图\nlcd.drawXbm(0, 0, 16,16, string.char(\n    0x80,0x00,0x80,0x00,0x40,0x01,0x20,0x02,0x10,0x04,0x48,0x08,0x84,0x10,0x83,0x60,\n    0x00,0x00,0xF8,0x0F,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0x02,0x00,0x01,0x80,0x00\n))\n"
            },
            {
                "name": "lcd.showImage",
                "snippet": "lcd.showImage(${1:x},${2:y},${3:file})",
                "description": "lcd.showImage(x, y, file) - 显示图片,当前只支持jpg,jpeg\n传入值：\nint X坐标\nint y坐标\nstring 文件路径\n例子：\nlcd.showImage(0,0,\"/luadb/logo.jpg\")\n"
            },
            {
                "name": "lcd.flush",
                "snippet": "lcd.flush()",
                "description": "lcd.flush() - 主动刷新数据到界面, 仅设置buff且禁用自动属性后使用\n返回值：\nbool 成功返回true, 否则返回nil/false\n例子：\n-- 本API与 lcd.setupBuff lcd.autoFlush 配合使用\nlcd.flush()\n"
            },
            {
                "name": "lcd.setupBuff",
                "snippet": "lcd.setupBuff(${1:conf},${2:onheap})",
                "description": "lcd.setupBuff(conf, onheap) - 设置显示缓冲区, 所需内存大小为 2×宽×高 字节. 请衡量内存需求与业务所需的刷新频次.\n传入值：\nuserdata conf指针, 不需要传\nbool true使用heap内存, false使用vm内存, 默认使用vm内存, 不需要主动传\n返回值：\nbool 是否成功\n例子：\n-- 初始化lcd的buff缓冲区, 可理解为FrameBuffer区域.\nlcd.setupBuff()\n"
            },
            {
                "name": "lcd.autoFlush",
                "snippet": "lcd.autoFlush(${1:enable})",
                "description": "lcd.autoFlush(enable) - 设置自动刷新, 需配合lcd.setupBuff使用\n传入值：\nbool 是否自动刷新,默认为true\n例子：\n-- 设置buff 并禁用自动更新\nlcd.setupBuff()\nlcd.autoFlush(false)\n-- 禁止自动更新后, 需要使用 lcd.flush() 主动刷新数据到屏幕\n"
            },
            {
                "name": "lcd.rgb565",
                "snippet": "lcd.rgb565(${1:r},${2:g},${3:b},${4:swap})",
                "description": "lcd.rgb565(r, g, b, swap) - RGB565颜色生成\n传入值：\nint 红色, 0x00 ~ 0xFF\nint 绿色, 0x00 ~ 0xFF\nint 蓝色, 0x00 ~ 0xFF\nbool 是否翻转, true 翻转, false 不翻转. 默认翻转\n返回值：\nint 颜色值\n例子：\n-- 本API支持多种模式, 参数数量分别是 1, 2, 3, 4\n-- 1. 单参数形式, 24bit RGB值, swap = true, 推荐\nlocal red =   lcd.rgb565(0xFF0000)\nlocal green = lcd.rgb565(0x00FF00)\nlocal blue =  lcd.rgb565(0x0000FF)\n\n-- 2. 两参数形式, 24bit RGB值, 增加swap的设置\nlocal red =   lcd.rgb565(0xFF0000, true)\nlocal green = lcd.rgb565(0x00FF00, true)\nlocal blue =  lcd.rgb565(0x0000FF, true)\n\n-- 3. 三参数形式, 红/绿/蓝, 各8bit\nlocal red = lcd.rgb565(0xFF, 0x00, 0x00)\nlocal green = lcd.rgb565(0x00, 0xFF, 0x00)\nlocal blue = lcd.rgb565(0x00, 0x00, 0xFF)\n\n-- 4. 四参数形式, 红/绿/蓝, 各8bit, 增加swap的设置\nlocal red = lcd.rgb565(0xFF, 0x00, 0x00, true)\nlocal green = lcd.rgb565(0x00, 0xFF, 0x00, true)\nlocal blue = lcd.rgb565(0x00, 0x00, 0xFF, true)\n"
            },
            {
                "name": "lcdseg.setup",
                "snippet": "lcdseg.setup(${1:bias},${2:duty},${3:vlcd},${4:com_number},${5:fresh_rate},${6:com_mark},${7:seg_mark})",
                "description": "lcdseg.setup(bias, duty, vlcd, com_number, fresh_rate, com_mark, seg_mark) - 初始化lcdseg库\n传入值：\nint bias值,通常为 1/3 bias, 对应 lcdseg.BIAS_ONETHIRD\nint duty值,通常为 1/4 duty, 对应 lcdseg.DUTY_ONEFOURTH\nint 电压, 单位100mV, 例如2.7v写27. air103支持的值有 27/29/31/33\nint COM脚的数量, 取决于具体模块, air103支持1-4\nint 刷新率,通常为60, 对应60HZ\nint COM启用与否的掩码, 默认为0xFF,全部启用.若只启用COM0/COM1, 则0x03\nint seg启用与否的掩码, 默认为0xFFFFFFFF,即全部启用. 若只启用前16个, 0xFFFF\n返回值：\nbool 成功返回true,否则返回false\n例子：\n-- 初始化lcdseg\nif lcdseg.setup(lcdseg.BIAS_ONETHIRD, lcdseg.DUTY_ONEFOURTH, 33, 4, 60) then\n    lcdseg.enable(1)\n\n    lcdseg.seg_set(0, 1, 1)\n    lcdseg.seg_set(2, 0, 1)\n    lcdseg.seg_set(3, 31, 1)\nend\n"
            },
            {
                "name": "lcdseg.enable",
                "snippet": "lcdseg.enable(${1:en})",
                "description": "lcdseg.enable(en) - 启用或禁用lcdseg库\n传入值：\nint 1启用,0禁用\n返回值：\nbool 成功与否\n"
            },
            {
                "name": "lcdseg.power",
                "snippet": "lcdseg.power(${1:en})",
                "description": "lcdseg.power(en) - 启用或禁用lcdseg的输出\n传入值：\nint 1启用,0禁用\n返回值：\nbool 成功与否\n"
            },
            {
                "name": "lcdseg.seg_set",
                "snippet": "lcdseg.seg_set(${1:com},${2:seg},${3:en})",
                "description": "lcdseg.seg_set(com, seg, en) - 设置具体一个段码的状态\n传入值：\nint COM号\nint seg号 要更改的字段的位索引\nint 1启用,0禁用\n返回值：\nbool 成功与否\n"
            },
            {
                "name": "libcoap.new",
                "snippet": "libcoap.new(${1:code},${2:uri},${3:headers},${4:payload})",
                "description": "libcoap.new(code, uri, headers, payload) - 创建一个coap数据包\n传入值：\nint coap的code, 例如libcoap.GET/libcoap.POST/libcoap.PUT/libcoap.DELETE\nstring 目标URI,必须填写, 不需要加上/开头\ntable 请求头,类似于http的headers,可选\nstring 请求体,类似于http的body,可选\n返回值：\nuserdata coap数据包\n例子：\n-- 创建一个请求服务器time的数据包\nlocal coapdata = libcoap.new(libcoap.GET, \"time\")\nlocal data = coapdata:rawdata()\n"
            },
            {
                "name": "libcoap.parse",
                "snippet": "libcoap.parse(${1:str})",
                "description": "libcoap.parse(str) - 解析coap数据包\n传入值：\nstring coap数据包\n返回值：\nuserdata coap数据包,如果解析失败会返回nil\n例子：\n-- 解析服务器传入的数据包\nlocal coapdata = libcoap.parse(indata)\nlog.info(\"coapdata\", coapdata:hcode(), coapdata:data())\n"
            },
            {
                "name": "coapdata:msgid",
                "snippet": "coapdata:msgid()",
                "description": "coapdata:msgid() - 获取coap数据包的msgid\n返回值：\nint coap数据包的msgid\n例子：\n-- 解析服务器传入的数据包\nlocal coapdata = libcoap.parse(indata)\nlog.info(\"coapdata\", coapdata:msgid())\n"
            },
            {
                "name": "coapdata:token",
                "snippet": "coapdata:token()",
                "description": "coapdata:token() - 获取coap数据包的token\n返回值：\nstring coap数据包的token\n例子：\n-- 解析服务器传入的数据包\nlocal coapdata = libcoap.parse(indata)\nlog.info(\"coapdata\", coapdata:token())\n"
            },
            {
                "name": "coapdata:rawdata",
                "snippet": "coapdata:rawdata()",
                "description": "coapdata:rawdata() - 获取coap数据包的二进制数据,用于发送到服务器\n返回值：\nstring coap数据包的二进制数据\n例子：\n-- 解析服务器传入的数据包\nlocal coapdata = libcoap.new(libcoap.GET, \"time\")\nnetc:send(coapdata:rawdata())\n"
            },
            {
                "name": "coapdata:code",
                "snippet": "coapdata:code()",
                "description": "coapdata:code() - 获取coap数据包的code\n返回值：\nint coap数据包的code\n例子：\n-- 解析服务器传入的数据包\nlocal coapdata = libcoap.parse(indata)\nlog.info(\"coapdata\", coapdata:code())\n"
            },
            {
                "name": "coapdata:hcode",
                "snippet": "coapdata:hcode()",
                "description": "coapdata:hcode() - 获取coap数据包的http code, 比coap原始的code要友好\n返回值：\nint coap数据包的http code,例如200,205,404\n例子：\n-- 解析服务器传入的数据包\nlocal coapdata = libcoap.parse(indata)\nlog.info(\"coapdata\", coapdata:hcode())\n"
            },
            {
                "name": "coapdata:type",
                "snippet": "coapdata:type(${1:t})",
                "description": "coapdata:type(t) - 获取coap数据包的type, 例如libcoap.CON/NON/ACK/RST\n传入值：\nint 新的type值,可选\n返回值：\nint coap数据包的type\n例子：\n-- 解析服务器传入的数据包\nlocal coapdata = libcoap.parse(indata)\nlog.info(\"coapdata\", coapdata:type())\n"
            },
            {
                "name": "coapdata:data",
                "snippet": "coapdata:data()",
                "description": "coapdata:data() - 获取coap数据包的data\n返回值：\nstring coap数据包的data\n例子：\n-- 解析服务器传入的数据包\nlocal coapdata = libcoap.parse(indata)\nlog.info(\"coapdata\", coapdata:data())\n"
            },
            {
                "name": "libgnss.parse",
                "snippet": "libgnss.parse(${1:str})",
                "description": "libgnss.parse(str) - 处理nmea数据\n传入值：\nstring 原始nmea数据\n例子：\n-- 解析nmea数据\nlibgnss.parse(indata)\nlog.info(\"nmea\", json.encode(libgnss.getRmc(), \"11g\"))\n"
            },
            {
                "name": "libgnss.isFix",
                "snippet": "libgnss.isFix()",
                "description": "libgnss.isFix() - 当前是否已经定位成功\n返回值：\nboolean 定位成功与否\n例子：\nlog.info(\"nmea\", \"isFix\", libgnss.isFix())\n"
            },
            {
                "name": "libgnss.getIntLocation",
                "snippet": "libgnss.getIntLocation(${1:speed_type})",
                "description": "libgnss.getIntLocation(speed_type) - 获取位置信息\n传入值：\nint 速度单位,默认是m/h\n返回值：\nint lat数据, 格式为 ddddddddd\nint lng数据, 格式为 ddddddddd\nint speed数据, 单位米. 于2023.9.26修正\n例子：\n-- 建议用libgnss.getRmc(1)\nlog.info(\"nmea\", \"loc\", libgnss.getIntLocation())\n\n-- 2023.12.11 新增speed_type参数\n--[[\n速度单位可选值\n0 - m/h 米/小时, 默认值, 整型\n1 - m/s 米/秒, 浮点数\n2 - km/h 千米/小时, 浮点数\n3 - kn/h 英里/小时, 浮点数\n]]\n-- 默认 米/小时\nlog.info(\"nmea\", \"loc\", libgnss.getIntLocation())\n-- 米/秒\nlog.info(\"nmea\", \"loc\", libgnss.getIntLocation(1))\n-- 千米/小时\nlog.info(\"nmea\", \"loc\", libgnss.getIntLocation(2))\n-- 英里/小时\nlog.info(\"nmea\", \"loc\", libgnss.getIntLocation(3))\n"
            },
            {
                "name": "libgnss.getRmc",
                "snippet": "libgnss.getRmc(${1:data_mode})",
                "description": "libgnss.getRmc(data_mode) - 获取原始RMC位置信息\n传入值：\nint 坐标类数据的格式, 0-DDMM.MMM格式, 1-DDDDDDD格式, 2-DD.DDDDD格式, 3-原始RMC字符串\n返回值：\ntable 原始rmc数据\n例子：\n-- 解析nmea\nlog.info(\"nmea\", \"rmc\", json.encode(libgnss.getRmc(2)))\n-- 实例输出\n--[[\n{\n    \"course\":0,\n    \"valid\":true,   // true定位成功,false定位丢失\n    \"lat\":23.4067,  // 纬度, 正数为北纬, 负数为南纬\n    \"lng\":113.231,  // 经度, 正数为东经, 负数为西经\n    \"variation\":0,  // 地面航向，单位为度，从北向起顺时针计算\n    \"speed\":0       // 地面速度, 单位为\"节\"\n    \"year\":2023,    // 年份\n    \"month\":1,      // 月份, 1-12\n    \"day\":5,        // 月份天, 1-31\n    \"hour\":7,       // 小时,0-23\n    \"min\":23,       // 分钟,0-59\n    \"sec\":20,       // 秒,0-59\n}\n]]\n"
            },
            {
                "name": "libgnss.getGsv",
                "snippet": "libgnss.getGsv()",
                "description": "libgnss.getGsv() - 获取原始GSV信息\n返回值：\ntable 原始GSV数据\n例子：\n-- 解析nmea\nlog.info(\"nmea\", \"gsv\", json.encode(libgnss.getGsv()))\n--[[实例输出\n{\n    \"total_sats\":24,      // 总可见卫星数量\n    \"sats\":[\n        {\n            \"snr\":27,     // 信噪比\n            \"azimuth\":278, // 方向角\n            \"elevation\":59, // 仰角\n            \"tp\":0,        // 0 - GPS, 1 - BD\n            \"nr\":4         // 卫星编号\n        },\n        // 这里忽略了22个卫星的信息\n        {\n            \"snr\":0,\n            \"azimuth\":107,\n            \"elevation\":19,\n            \"tp\":1,\n            \"nr\":31\n        }\n    ]\n}\n]]\n"
            },
            {
                "name": "libgnss.getGsa",
                "snippet": "libgnss.getGsa(${1:data_mode})",
                "description": "libgnss.getGsa(data_mode) - 获取原始GSA信息\n传入值：\nint 模式\n返回值：\ntable 原始GSA数据\n例子：\n-- 获取\nlog.info(\"nmea\", \"gsa\", json.encode(libgnss.getGsa(), \"11g\"))\n-- 示例数据(模式0, 也就是默认模式)\n--[[\n{\n    \"sats\":[ // 正在使用的卫星编号\n        9,\n        6,\n        16,\n        16,\n        26,\n        21,\n        27,\n        27,\n        4,\n        36,\n        3,\n        7,\n        8,\n        194\n    ],\n    \"vdop\":0.03083333, // 垂直精度因子，0.00 - 99.99，不定位时值为 99.99\n    \"pdop\":0.0455,     // 水平精度因子，0.00 - 99.99，不定位时值为 99.99\n    \"fix_type\":3,      // 定位模式, 1-未定位, 2-2D定位, 3-3D定位\n    \"hdop\":0.0335      // 位置精度因子，0.00 - 99.99，不定位时值为 99.99\n}\n]]\n\n-- 示例数据(模式1), 2024.5.26新增\n[\n    {\"pdop\":7.8299999,\"sats\":[13,15,18,23],\"vdop\":3.2400000,\"hdop\":7.1300001,\"fix_type\":3},\n    {\"pdop\":7.8299999,\"sats\":[20,35,8,13],\"vdop\":3.2400000,\"hdop\":7.1300001,\"fix_type\":3}\n]\n"
            },
            {
                "name": "libgnss.getVtg",
                "snippet": "libgnss.getVtg(${1:data_mode})",
                "description": "libgnss.getVtg(data_mode) - 获取VTA速度信息\n传入值：\nint 可选, 3-原始字符串, 不传或者传其他值, 则返回浮点值\n返回值：\ntable 原始VTA数据\n例子：\n-- 解析nmea\nlog.info(\"nmea\", \"vtg\", json.encode(libgnss.getVtg()))\n-- 示例\n--[[\n{\n    \"speed_knots\":0,        // 速度, 英里/小时\n    \"true_track_degrees\":0,  // 真北方向角\n    \"magnetic_track_degrees\":0, // 磁北方向角\n    \"speed_kph\":0           // 速度, 千米/小时\n}\n-- 提醒: Air780EG和Air510U,在速度<5km/h时, 不会返回方向角\n]]\n"
            },
            {
                "name": "libgnss.getZda",
                "snippet": "libgnss.getZda()",
                "description": "libgnss.getZda() - 获取原始ZDA时间和日期信息\n返回值：\ntable 原始zda数据\n例子：\nlog.info(\"nmea\", \"zda\", json.encode(libgnss.getZda()))\n-- 实例输出\n--[[\n{\n    \"minute_offset\":0,   // 本地时区的分钟, 一般固定输出0\n    \"hour_offset\":0,     // 本地时区的小时, 一般固定输出0\n    \"year\":2023         // UTC 年，四位数字\n    \"month\":1,          // UTC 月，两位，01 ~ 12\n    \"day\":5,            // UTC 日，两位数字，01 ~ 31\n    \"hour\":7,           // 小时\n    \"min\":50,           // 分\n    \"sec\":14,           // 秒\n}\n]]\n"
            },
            {
                "name": "libgnss.debug",
                "snippet": "libgnss.debug(${1:mode})",
                "description": "libgnss.debug(mode) - 设置调试模式\n传入值：\nbool true开启调试,false关闭调试,默认为false\n例子：\n-- 开启调试, 会输出GNSS原始数据到日志中\nlibgnss.debug(true)\n-- 关闭调试\nlibgnss.debug(false)\n"
            },
            {
                "name": "libgnss.getGga",
                "snippet": "libgnss.getGga(${1:data_mode})",
                "description": "libgnss.getGga(data_mode) - 获取GGA数据\n传入值：\nint 坐标类数据的格式, 0-DDMM.MMM格式, 1-DDDDDDD格式, 2-DD.DDDDD格式, 3-原始字符串\n返回值：\ntable GGA数据, 若如不存在会返回nil\n例子：\nlocal gga = libgnss.getGga(2)\nif gga then\n    log.info(\"GGA\", json.encode(gga, \"11g\"))\nend\n--实例输出\n--[[\n{\n    \"dgps_age\":0,             // 差分校正时延，单位为秒\n    \"fix_quality\":1,          // 定位状态标识 0 - 无效,1 - 单点定位,2 - 差分定位\n    \"satellites_tracked\":14,  // 参与定位的卫星数量\n    \"altitude\":0.255,         // 海平面分离度, 或者成为海拔, 单位是米,\n    \"hdop\":0.0335,            // 水平精度因子，0.00 - 99.99，不定位时值为 99.99\n    \"longitude\":113.231,      // 经度, 正数为东经, 负数为西经\n    \"latitude\":23.4067,       // 纬度, 正数为北纬, 负数为南纬\n    \"height\":0                // 椭球高，固定输出 1 位小数\n}\n]]\n"
            },
            {
                "name": "libgnss.getGll",
                "snippet": "libgnss.getGll(${1:data_mode})",
                "description": "libgnss.getGll(data_mode) - 获取GLL数据\n传入值：\nint 坐标类数据的格式, 0-DDMM.MMM格式, 1-DDDDDDD格式, 2-DD.DDDDD格式\n返回值：\ntable GLL数据, 若如不存在会返回nil\n例子：\nlocal gll = libgnss.getGll(2)\nif gll then\n    log.info(\"GLL\", json.encode(gll, \"11g\"))\nend\n-- 实例数据\n--[[\n{\n    \"status\":\"A\",        // 定位状态, A有效, B无效\n    \"mode\":\"A\",          // 定位模式, V无效, A单点解, D差分解\n    \"sec\":20,            // 秒, UTC时间为准\n    \"min\":23,            // 分钟, UTC时间为准\n    \"hour\":7,            // 小时, UTC时间为准\n    \"longitude\":113.231, // 经度, 正数为东经, 负数为西经\n    \"latitude\":23.4067,  // 纬度, 正数为北纬, 负数为南纬\n    \"us\":0               // 微妙数, 通常为0\n}\n]]\n"
            },
            {
                "name": "libgnss.clear",
                "snippet": "libgnss.clear()",
                "description": "libgnss.clear() - 清除历史定位数据\n返回值：\nnil 无返回值\n例子：\n-- 该操作会清除所有定位数据\n"
            },
            {
                "name": "libgnss.bind",
                "snippet": "libgnss.bind(${1:id},${2:next_id})",
                "description": "libgnss.bind(id, next_id) - 绑定uart端口进行GNSS数据读取\n传入值：\nint uart端口号\nint 转发到uart的id, 例如虚拟uart.VUART_0\n例子：\n-- 配置串口信息, 通常为 115200 8N1\nuart.setup(2, 115200)\n-- 绑定uart, 马上开始解析GNSS数据\nlibgnss.bind(2)\n-- 无需再调用uart.on然后调用libgnss.parse\n-- 开发期可打开调试日志\nlibgnss.debug(true)\n\n-- 2023-01-02之后编译的固件有效\n-- 从uart2读取并解析, 同时转发到虚拟串口0\nlibgnss.bind(2, uart.VUART_0)\n"
            },
            {
                "name": "libgnss.locStr",
                "snippet": "libgnss.locStr(${1:mode})",
                "description": "libgnss.locStr(mode) - 获取位置字符串\n传入值：\nint 字符串模式. 0- Air780EG所需的格式\nreturn 指定模式的字符串\n例子：\n-- 仅推荐在定位成功后调用\n"
            },
            {
                "name": "libgnss.rtcAuto",
                "snippet": "libgnss.rtcAuto(${1:enable})",
                "description": "libgnss.rtcAuto(enable) - 定位成功后自动设置RTC\n传入值：\nbool 开启与否, 默认是false关闭\n例子：\n-- 开启自动设置RTC\nlibgnss.rtcAuto(true)\n"
            },
            {
                "name": "libgnss.on",
                "snippet": "libgnss.on(${1:tp},${2:fn})",
                "description": "libgnss.on(tp, fn) - 底层事件回调\n传入值：\nstring 事件类型,当前支持\"raw\"\n例子：\n-- 本函数一般用于调试, 用于获取底层实际收到的数据\nlibgnss.on(\"raw\", function(data)\n    log.info(\"GNSS\", data)\nend)\n"
            },
            {
                "name": "libgnss.getTxt",
                "snippet": "libgnss.getTxt()",
                "description": "libgnss.getTxt() - 获取非标的GPTXT数据\n传入值：\nreturn GPTXT所携带的字符串\n例子：\n-- 本函数于2023.6.6 添加\nlog.info(\"gnss\", \"txt\", libgnss.getTxt())\n\n-- 测试语句\nlibgnss.parse(\"$GPTXT,01,01,01,ANTENNA SHORT*63\\r\\n\")\nlog.info(\"GNSS\", libgnss.getTxt())\nlibgnss.parse(\"$GPTXT,01,01,01,ANTENNA OPEN*25\\r\\n\")\nlog.info(\"GNSS\", libgnss.getTxt())\nlibgnss.parse(\"$GPTXT,01,01,01,ANTENNA OK*35\\r\\n\")\nlog.info(\"GNSS\", libgnss.getTxt())\n"
            },
            {
                "name": "libgnss.casic_aid",
                "snippet": "libgnss.casic_aid(${1:dt},${2:loc})",
                "description": "libgnss.casic_aid(dt, loc) - 合成Air530Z所需要的辅助定位数据\n传入值：\ntable 时间信息\ntable 经纬度及海拔\n返回值：\nstring 辅助定位数据\n例子：\n-- 本函数适合CASIC系列GNSS模块的辅助定位信息的合成\n-- 本函数 2023.11.14 新增\n\n-- 首先是时间信息,注意是UTC时间\n-- 时间来源很多, 一般建议socket.sntp()时间同步后的系统时间\nlocal dt = os.date(\"!*t\")\n\n-- 然后是辅助定位坐标\n-- 来源有很多方式:\n-- 1. 从历史定位数据得到, 例如之前定位成功后保存到本地文件系统了\n-- 2. 通过基站定位或者wifi定位获取到\n-- 3. 通过IP定位获取到大概坐标\n-- 坐标系是WGS84, 但鉴于是辅助定位,精度不是关键因素\nlocal lla = {\n    lat = 23.12,\n    lng = 114.12\n}\n\nlocal aid = libgnss.casic_aid(dt, lla)\n"
            },
            {
                "name": "lf.init",
                "snippet": "lf.init(${1:spi_device})",
                "description": "lf.init(spi_device) - 初始化 little_flash\n传入值：\nint userdata spi_device\n返回值：\nuserdata 成功返回一个数据结构,否则返回nil\n例子：\n--spi_device\nspi_device = spi.deviceSetup(0,17,0,0,8,2000000,spi.MSB,1,0)\nlog.info(\"lf.init\",lf.init(spi_device))\n"
            },
            {
                "name": "lf.mount",
                "snippet": "lf.mount(${1:flash},${2:mount_point},${3:offset},${4:maxsize})",
                "description": "lf.mount(flash, mount_point, offset, maxsize) - 挂载 little_flash lfs文件系统\n传入值：\nuserdata flash Flash 设备对象 lf.init()返回的数据结构\nstring mount_point 挂载目录名\nint 起始偏移量,默认0\nint 总大小, 默认是整个flash\n返回值：\nbool 成功返回true\n例子：\nlog.info(\"lf.mount\",lf.mount(little_flash_device,\"/little_flash\"))\n"
            },
            {
                "name": "log.setLevel",
                "snippet": "log.setLevel(${1:level})",
                "description": "log.setLevel(level) - 设置日志级别\n传入值：\nstring level 日志级别,可用字符串或数值, 字符串为(SILENT,DEBUG,INFO,WARN,ERROR,FATAL), 数值为(0,1,2,3,4,5)\n返回值：\nnil 无返回值\n例子：\n-- 设置日志级别为INFO\nlog.setLevel(\"INFO\")\n"
            },
            {
                "name": "log.style",
                "snippet": "log.style(${1:val})",
                "description": "log.style(val) - 设置日志风格\n传入值：\nint 日志风格,默认为0, 不传就是获取当前值\n返回值：\nint 当前的日志风格\n例子：\n-- 以 log.info(\"ABC\", \"DEF\", 123) 为例, 假设该代码位于main.lua的12行\n-- 默认日志0\n-- I/user.ABC DEF 123\n-- 调试风格1, 添加额外的调试信息\n-- I/main.lua:12 ABC DEF 123\n-- 调试风格2, 添加额外的调试信息, 位置有所区别\n-- I/user.ABC main.lua:12 DEF 123\n\nlog.style(0) -- 默认风格0\nlog.style(1) -- 调试风格1\nlog.style(2) -- 调试风格2\n"
            },
            {
                "name": "log.getLevel",
                "snippet": "log.getLevel()",
                "description": "log.getLevel() - 获取日志级别\n返回值：\nint 日志级别对应0,1,2,3,4,5\n例子：\n-- 得到日志级别\nlog.getLevel()\n"
            },
            {
                "name": "log.debug",
                "snippet": "log.debug(${1:tag},${2:val},${3:val2},${4:val3},${5:...})",
                "description": "log.debug(tag, val, val2, val3, ...) - 输出日志,级别debug\n传入值：\nstring tag         日志标识,必须是字符串\n... 需打印的参数\n返回值：\nnil 无返回值\n例子：\n-- 日志输出 D/onenet connect ok\nlog.debug(\"onenet\", \"connect ok\")\n"
            },
            {
                "name": "log.info",
                "snippet": "log.info(${1:tag},${2:val},${3:val2},${4:val3},${5:...})",
                "description": "log.info(tag, val, val2, val3, ...) - 输出日志,级别info\n传入值：\nstring tag         日志标识,必须是字符串\n... 需打印的参数\n返回值：\nnil 无返回值\n例子：\n-- 日志输出 I/onenet connect ok\nlog.info(\"onenet\", \"connect ok\")\n"
            },
            {
                "name": "log.warn",
                "snippet": "log.warn(${1:tag},${2:val},${3:val2},${4:val3},${5:...})",
                "description": "log.warn(tag, val, val2, val3, ...) - 输出日志,级别warn\n传入值：\nstring tag         日志标识,必须是字符串\n... 需打印的参数\n返回值：\nnil 无返回值\n例子：\n-- 日志输出 W/onenet connect ok\nlog.warn(\"onenet\", \"connect ok\")\n"
            },
            {
                "name": "log.error",
                "snippet": "log.error(${1:tag},${2:val},${3:val2},${4:val3},${5:...})",
                "description": "log.error(tag, val, val2, val3, ...) - 输出日志,级别error\n传入值：\nstring tag         日志标识,必须是字符串\n... 需打印的参数\n返回值：\nnil 无返回值\n例子：\n-- 日志输出 E/onenet connect ok\nlog.error(\"onenet\", \"connect ok\")\n"
            },
            {
                "name": "lora.init",
                "snippet": "lora.init(${1:ic},${2:loraconfig},${3:spiconfig})",
                "description": "lora.init(ic, loraconfig,spiconfig) - lora初始化\n传入值：\nstring lora 型号，当前支持：<br>llcc68<br>sx1268\ntable lora配置参数,与具体设备有关\n例子：\nlora.init(\"llcc68\",\n    {\n        id = 0,           -- SPI id\n        cs = pin.PB04,    -- SPI 片选的GPIO号,如果没有pin库,填GPIO数字编号就行\n        res = pin.PB00,   -- 复位脚连接的GPIO号,如果没有pin库,填GPIO数字编号就行\n        busy = pin.PB01,  -- 忙检测脚的GPIO号\n        dio1 = pin.PB06,  -- 数据输入中断脚\n        lora_init = true  -- 是否发送初始化命令. 如果是唤醒后直接读取, 就传false\n    }\n)\n"
            },
            {
                "name": "lora.set_channel",
                "snippet": "lora.set_channel(${1:freq})",
                "description": "lora.set_channel(freq) - 设置频道频率\n传入值：\nnumber 频率\n例子：\nlora.set_channel(433000000)\n"
            },
            {
                "name": "lora.set_txconfig",
                "snippet": "lora.set_txconfig(${1:ic},${2:txconfig})",
                "description": "lora.set_txconfig(ic, txconfig) - lora配置发送参数\n传入值：\nstring lora 型号，当前支持：<br>llcc68<br>sx1268\ntable lora发送配置参数,与具体设备有关\n例子：\nlora.set_txconfig(\"llcc68\",\n    {\n        mode=1,\n        power=22,\n        fdev=0,\n        bandwidth=0,\n        datarate=9,\n        coderate=4,\n        preambleLen=8,\n        fixLen=false,\n        crcOn=true,\n        freqHopOn=0,\n        hopPeriod=0,\n        iqInverted=false,\n        timeout=3000\n    }\n)\n"
            },
            {
                "name": "lora.set_rxconfig",
                "snippet": "lora.set_rxconfig(${1:ic},${2:set_rxconfig})",
                "description": "lora.set_rxconfig(ic, set_rxconfig) - lora配置接收参数\n传入值：\nstring lora 型号，当前支持：<br>llcc68<br>sx1268\ntable lora接收配置参数,与具体设备有关\n例子：\nlora.set_rxconfig(\"llcc68\",\n    {\n        mode=1,\n        bandwidth=0,\n        datarate=9,\n        coderate=4,\n        bandwidthAfc=0,\n        preambleLen=8,\n        symbTimeout=0,\n        fixLen=false,\n        payloadLen=0,\n        crcOn=true,\n        freqHopOn=0,\n        hopPeriod=0,\n        iqInverted=false,\n        rxContinuous=false\n    }\n)\n"
            },
            {
                "name": "lora.send",
                "snippet": "lora.send(${1:data})",
                "description": "lora.send(data) - 发数据\n传入值：\nstring 写入的数据\n例子：\nlora.send(\"PING\")\n"
            },
            {
                "name": "lora.recv",
                "snippet": "lora.recv(${1:timeout})",
                "description": "lora.recv(timeout) - 开启收数据\n传入值：\nnumber 超时时间，默认1000 单位ms\n例子：\nsys.subscribe(\"LORA_RX_DONE\", function(data, size)\n    log.info(\"LORA_RX_DONE: \", data, size)\n    lora.send(\"PING\")\nend)\n-- 老版本没有recv, 可以改成 lora.recive\nlora.recv(1000)\n"
            },
            {
                "name": "lora.mode",
                "snippet": "lora.mode(${1:mode})",
                "description": "lora.mode(mode) - 设置进入模式(休眠，正常等)\n传入值：\nnumber 模式 正常模式:lora.STANDBY 休眠模式:lora.SLEEP 默认为正常模式\n例子：\nlora.mode(lora.STANDBY)\n"
            },
            {
                "name": "lora2.init",
                "snippet": "lora2.init(${1:ic},${2:loraconfig},${3:spiconfig})",
                "description": "lora2.init(ic, loraconfig,spiconfig) - lora初始化\n传入值：\nstring lora 型号，当前支持：<br>llcc68<br>sx1268\ntable lora配置参数,与具体设备有关\n返回值：\nuserdata 若成功会返回lora对象,否则返回nil\n例子：\nspi_lora = spi.deviceSetup(spi_id,pin_cs,0,0,8,10*1000*1000,spi.MSB,1,0)\nlora_device = lora2.init(\"llcc68\",{res = pin_reset,busy = pin_busy,dio1 = pin_dio1},spi_lora)\n"
            },
            {
                "name": "lora_device:set_channel",
                "snippet": "lora_device:set_channel(${1:freq})",
                "description": "lora_device:set_channel(freq) - 设置频道频率\n传入值：\nnumber 频率\n例子：\nlora_device:set_channel(433000000)\n"
            },
            {
                "name": "lora_device:set_txconfig",
                "snippet": "lora_device:set_txconfig(${1:txconfig})",
                "description": "lora_device:set_txconfig(txconfig) - lora配置发送参数\n传入值：\ntable lora发送配置参数,与具体设备有关\n例子：\nlora_device:set_txconfig(\n    {\n        mode=1,\n        power=22,\n        fdev=0,\n        bandwidth=0,\n        datarate=9,\n        coderate=4,\n        preambleLen=8,\n        fixLen=false,\n        crcOn=true,\n        freqHopOn=0,\n        hopPeriod=0,\n        iqInverted=false,\n        timeout=3000\n    }\n)\n"
            },
            {
                "name": "lora_device:set_rxconfig",
                "snippet": "lora_device:set_rxconfig(${1:set_rxconfig})",
                "description": "lora_device:set_rxconfig(set_rxconfig) - lora配置接收参数\n传入值：\ntable lora接收配置参数,与具体设备有关\n例子：\nlora_device:set_rxconfig(\n    {\n        mode=1,\n        bandwidth=0,\n        datarate=9,\n        coderate=4,\n        bandwidthAfc=0,\n        preambleLen=8,\n        symbTimeout=0,\n        fixLen=false,\n        payloadLen=0,\n        crcOn=true,\n        freqHopOn=0,\n        hopPeriod=0,\n        iqInverted=false,\n        rxContinuous=false\n    }\n)\n"
            },
            {
                "name": "lora_device:send",
                "snippet": "lora_device:send(${1:data})",
                "description": "lora_device:send(data) - 发数据\n传入值：\nstring 写入的数据\n例子：\nlora_device:send(\"PING\")\n"
            },
            {
                "name": "lora_device:recv",
                "snippet": "lora_device:recv(${1:timeout})",
                "description": "lora_device:recv(timeout) - 开启收数据\n传入值：\nnumber 超时时间，默认1000 单位ms\n例子：\nsys.subscribe(\"LORA_RX_DONE\", function(data, size)\n    log.info(\"LORA_RX_DONE: \", data, size)\n    lora_device:send(\"PING\")\nend)\nlora_device:recv(1000)\n"
            },
            {
                "name": "lora_device:mode",
                "snippet": "lora_device:mode(${1:mode})",
                "description": "lora_device:mode(mode) - 设置进入模式(休眠，正常等)\n传入值：\nnumber 模式 正常模式:lora.STANDBY 休眠模式:lora.SLEEP 默认为正常模式\n例子：\nlora_device:mode(lora.STANDBY)\n"
            },
            {
                "name": "lora_device:on",
                "snippet": "lora_device:on(${1:cb})",
                "description": "lora_device:on(cb) - 注册lora回调\n传入值：\nfunction cb lora回调,参数包括lora_device, event, data, size\n返回值：\nnil 无返回值\n例子：\nlora_device:on(function(lora_device, event, data, size)\n    log.info(\"lora\", \"event\", event, lora_device, data, size)\n    if event == \"tx_done\" then\n        lora_device:recv(1000)\n    elseif event == \"rx_done\" then\n        lora_device:send(\"PING\")\n    elseif event == \"tx_timeout\" then\n\n    elseif event == \"rx_timeout\" then\n        lora_device:recv(1000)\n    elseif event == \"rx_error\" then\n\n    end\nend)\n--[[\nevent可能出现的值有\n    tx_done         -- 发送完成\n    rx_done         -- 接收完成\n    tx_timeout      -- 发送超时\n    rx_timeout      -- 接收超时\n    rx_error        -- 接收错误\n]]\n"
            },
            {
                "name": "lvgl.draw_mask_radius_param_t",
                "snippet": "lvgl.draw_mask_radius_param_t()",
                "description": "lvgl.draw_mask_radius_param_t() - 创建一个lv_draw_mask_radius_param_t\n返回值：\nuserdata lv_draw_mask_radius_param_t指针\n例子：\nlocal radius = lvgl.draw_mask_radius_param_t()\n"
            },
            {
                "name": "lvgl.draw_mask_radius_param_t_free",
                "snippet": "lvgl.draw_mask_radius_param_t_free(${1:radius})",
                "description": "lvgl.draw_mask_radius_param_t_free(radius) - 释放一个lv_draw_mask_radius_param_t\n例子：\nlocal lvgl.draw_mask_radius_param_t_free(radius)\n"
            },
            {
                "name": "lvgl.draw_mask_line_param_t",
                "snippet": "lvgl.draw_mask_line_param_t()",
                "description": "lvgl.draw_mask_line_param_t() - 创建一个lv_draw_mask_line_param_t\n返回值：\nuserdata lv_draw_mask_line_param_t指针\n例子：\nlocal line = lvgl.draw_mask_line_param_t()\n"
            },
            {
                "name": "lvgl.draw_mask_line_param_t_free",
                "snippet": "lvgl.draw_mask_line_param_t_free(${1:line})",
                "description": "lvgl.draw_mask_line_param_t_free(line) - 释放一个lv_draw_mask_line_param_t\n例子：\nlocal lvgl.draw_mask_line_param_t_free(line)\n"
            },
            {
                "name": "lvgl.draw_mask_fade_param_t",
                "snippet": "lvgl.draw_mask_fade_param_t()",
                "description": "lvgl.draw_mask_fade_param_t() - 创建一个lv_draw_mask_fade_param_t\n返回值：\nuserdata lv_draw_mask_fade_param_t指针\n例子：\nlocal fade = lvgl.draw_mask_fade_param_t()\n"
            },
            {
                "name": "lvgl.draw_mask_fade_param_t_free",
                "snippet": "lvgl.draw_mask_fade_param_t_free(${1:fade})",
                "description": "lvgl.draw_mask_fade_param_t_free(fade) - 释放一个lv_draw_mask_fade_param_t\n例子：\nlocal lvgl.draw_mask_fade_param_t_free(fade)\n"
            },
            {
                "name": "lvgl.font_get",
                "snippet": "lvgl.font_get(${1:name})",
                "description": "lvgl.font_get(name) - 获取内置字体\n传入值：\nstring 字体名称+字号, 例如 opposans_m_10\n返回值：\nuserdata 字体指针\n例子：\n\nlocal font = lvgl.font_get(\"opposans_m_12\")\n"
            },
            {
                "name": "lvgl.font_load",
                "snippet": "lvgl.font_load(${1:path/spi_device},${2:size},${3:bpp},${4:thickness},${5:cache_size},${6:sty_zh},${7:sty_en})",
                "description": "lvgl.font_load(path/spi_device,size,bpp,thickness,cache_size,sty_zh,sty_en) - 从文件系统加载字体\n传入值：\nstring/userdata 字体路径/spi_device (spi_device为使用外置高通矢量字库芯片)\nnumber size 可选,字号 16-192 默认16(使用高通矢量字库)\nnumber bpp 可选 深度 默认4(使用高通矢量字库)\nnumber thickness 可选 粗细值 默认size * bpp(使用高通矢量字库)\nnumber cache_size 可选 默认0(使用高通矢量字库)\nnumber sty_zh 可选 选择字体 默认1(使用高通矢量字库)\nnumber sty_en 可选 选择字体 默认3(使用高通矢量字库)\n返回值：\nuserdata 字体指针\n例子：\nlocal font = lvgl.font_load(\"/font_32.bin\")\n--local font = lvgl.font_load(spi_device,16)(高通矢量字库)\n"
            },
            {
                "name": "lvgl.font_free",
                "snippet": "lvgl.font_free(${1:font})",
                "description": "lvgl.font_free(font) - 释放字体,慎用!!!仅通过font_load加载的字体允许卸载,通过font_get获取的字体不允许卸载\n传入值：\nstring 字体路径\n返回值：\nuserdata 字体指针\n例子：\nlocal font = lvgl.font_load(\"/font_32.bin\")\n-- N N N N 操作\n-- 确定字体不被使用,不被引用,且内存紧张需要释放\nlvgl.font_free(font)\n"
            },
            {
                "name": "lvgl.obj_set_event_cb",
                "snippet": "lvgl.obj_set_event_cb(${1:obj},${2:func})",
                "description": "lvgl.obj_set_event_cb(obj, func) - 设置组件的事件回调\n传入值：\nuserdata lvgl组件指针\nfunc lua函数, 参数有2个 (obj, event), 其中obj是当前对象, event是事件类型, 为整型\n返回值：\nnil 无返回值\n"
            },
            {
                "name": "lvgl.obj_set_signal_cb",
                "snippet": "lvgl.obj_set_signal_cb(${1:obj},${2:func})",
                "description": "lvgl.obj_set_signal_cb(obj, func) - 设置组件的信号回调\n传入值：\nuserdata lvgl组件指针\nfunc lua函数, 参数有2个 (obj, signal), 其中obj是当前对象, signal是信号类型, 为整型\n返回值：\nnil 无返回值\n"
            },
            {
                "name": "lvgl.anim_set_exec_cb",
                "snippet": "lvgl.anim_set_exec_cb(${1:anim},${2:func})",
                "description": "lvgl.anim_set_exec_cb(anim, func) - 设置动画回调\n传入值：\nuserdata 动画指针\nuserdata lvgl组件指针\nfunc lua函数, 参数有2个 (obj, value), 其中obj是当前对象, signal是信号类型, 为整型\n返回值：\nnil 无返回值\n"
            },
            {
                "name": "lvgl.anim_set_ready_cb",
                "snippet": "lvgl.anim_set_ready_cb(${1:anim},${2:func})",
                "description": "lvgl.anim_set_ready_cb(anim, func) - 设置动画回调\n传入值：\nuserdata 动画指针\nuserdata lvgl组件指针\nfunc lua函数, 参数有1个 (anim), 其中anim是当前对象\n返回值：\nnil 无返回值\n"
            },
            {
                "name": "lvgl.anim_path_set_cb",
                "snippet": "lvgl.anim_path_set_cb(${1:path},${2:func})",
                "description": "lvgl.anim_path_set_cb(path, func) - 设置动画回调\n传入值：\nuserdata 动画指针\nuserdata lvgl组件指针\nfunc lua函数, 参数有1个 (path), 其中path是当前对象\n返回值：\nnil 无返回值\n"
            },
            {
                "name": "lvgl.event_send",
                "snippet": "lvgl.event_send(${1:obj},${2:ent})",
                "description": "lvgl.event_send(obj, ent) - 发送事件给组件\n传入值：\nuserdata 组件指针\nint 事件id, 例如 lvgl.EVENT_PRESSED\n返回值：\nbool 成功返回true, 对象已被删除的话返回false或者nil\nint 底层返回值,如果obj为nil就返回nil\n"
            },
            {
                "name": "lvgl.scr_act",
                "snippet": "lvgl.scr_act()",
                "description": "lvgl.scr_act() - 获取当前活跃的screen对象\n返回值：\n指针 screen指针\n例子：\nlocal scr = lvgl.scr_act()\n\n"
            },
            {
                "name": "lvgl.layer_top",
                "snippet": "lvgl.layer_top()",
                "description": "lvgl.layer_top() - 获取layer_top\n返回值：\n指针 layer指针\n"
            },
            {
                "name": "lvgl.layer_sys",
                "snippet": "lvgl.layer_sys()",
                "description": "lvgl.layer_sys() - 获取layer_sys\n返回值：\n指针 layer指针\n"
            },
            {
                "name": "lvgl.scr_load",
                "snippet": "lvgl.scr_load(${1:scr})",
                "description": "lvgl.scr_load(scr) - 载入指定的screen\n传入值：\nuserdata screen指针\n例子：\n    local scr = lvgl.obj_create(nil, nil)\n    local btn = lvgl.btn_create(scr)\n    lvgl.obj_align(btn, lvgl.scr_act(), lvgl.ALIGN_CENTER, 0, 0)\n    local label = lvgl.label_create(btn)\n    lvgl.label_set_text(label, \"LuatOS!\")\n    lvgl.scr_load(scr)\n"
            },
            {
                "name": "lvgl.scr_load_anim",
                "snippet": "lvgl.scr_load_anim(${1:scr})",
                "description": "lvgl.scr_load_anim(scr) - 载入指定的screen并使用指定的转场动画\n传入值：\nuserdata screen指针\n例子：\n    local scr = lvgl.obj_create(nil, nil)\n    local btn = lvgl.btn_create(scr)\n    lvgl.obj_align(btn, lvgl.scr_act(), lvgl.ALIGN_CENTER, 0, 0)\n    local label = lvgl.label_create(btn)\n    lvgl.label_set_text(label, \"LuatOS!\")\n\n    local scr2 = lvgl.obj_create(nil,nil)\n    local btn2 = lvgl.btn_create(scr2)\n    lvgl.obj_align(btn, scr2, lvgl.ALIGN_CENTER, 0, 20)\n    local label2 = lvgl.label_create(btn2)\n    lvgl.label_set_text(label2, \"Btn2\")\n    lvgl.scr_load(scr)\n    --sys.wait(1000);\n    lvgl.scr_load_anim(scr2,lvgl.SCR_LOAD_ANIM_OVER_LEFT,100,100,false)\n原函数：lv_scr_load_anim(lv_obj_t * new_scr, lv_scr_load_anim_t anim_type, uint32_t time, uint32_t delay, bool auto_del)\n"
            },
            {
                "name": "lvgl.theme_set_act",
                "snippet": "lvgl.theme_set_act(${1:name})",
                "description": "lvgl.theme_set_act(name) - 设置主题\n传入值：\nstring 主题名称,可选值有 default/mono/empty/material_light/material_dark/material_no_transition/material_no_focus\n返回值：\nbool 成功返回true,否则返回nil\n例子：\n-- 黑白主题\nlvgl.theme_set_act(\"mono\")\n-- 空白主题\nlvgl.theme_set_act(\"empty\")\n"
            },
            {
                "name": "lvgl.sleep",
                "snippet": "lvgl.sleep(${1:enable})",
                "description": "lvgl.sleep(enable) - LVGL休眠控制，暂停/恢复刷新定时器，目前只有105和EC618可以用\n传入值：\nboolean true暂停 false恢复\n例子：\nlvgl.sleep(true)        --暂停刷新，系统可以休眠\nlvgl.sleep(false)        --恢复刷新，系统不休眠\n"
            },
            {
                "name": "lvgl.init",
                "snippet": "lvgl.init(${1:w},${2:h},${3:lcd},${4:buff_size},${5:buff_mode})",
                "description": "lvgl.init(w, h, lcd, buff_size, buff_mode) - 初始化LVGL\n传入值：\nint 屏幕宽,可选,默认从lcd取\nint 屏幕高,可选,默认从lcd取\nuserdata lcd指针,可选,lcd初始化后有默认值,预留的多屏入口\nint 缓冲区大小,默认宽*10, 不含色深.\nint 缓冲模式,默认0, 单buff模式, 可选1,双buff模式\n返回值：\nbool 成功返回true,否则返回false\n"
            },
            {
                "name": "lvgl.anim_create",
                "snippet": "lvgl.anim_create()",
                "description": "lvgl.anim_create() - 创建并初始化一个anim\n返回值：\nuserdata anim指针\n例子：\nlocal anim = lvgl.anim_create()\n"
            },
            {
                "name": "lvgl.anim_free",
                "snippet": "lvgl.anim_free(${1:anim})",
                "description": "lvgl.anim_free(anim) - 释放一个anim\n例子：\nlocal lvgl.anim_free(anim)\n"
            },
            {
                "name": "lvgl.anim_path_t",
                "snippet": "lvgl.anim_path_t()",
                "description": "lvgl.anim_path_t() - 创建一个lv_anim_path_t\n返回值：\nuserdata lv_anim_path_t指针\n例子：\nlocal anim_path_t = lvgl.anim_path_t()\n"
            },
            {
                "name": "lvgl.anim_path_t_free",
                "snippet": "lvgl.anim_path_t_free(${1:anim_path_t})",
                "description": "lvgl.anim_path_t_free(anim_path_t) - 释放一个lv_anim_path_t\n例子：\nlocal lvgl.anim_path_t_free(anim_path_t)\n"
            },
            {
                "name": "lvgl.anim_set_path_str",
                "snippet": "lvgl.anim_set_path_str(${1:anim},${2:tp})",
                "description": "lvgl.anim_set_path_str(anim, tp) - 设置动画路径方式\n传入值：\nuserdata 动画指针\nstring 类型, 支持 linear/ease_in/ease_out/ease_in_out/overshoot/bounce/step\n返回值：\nnil 无返回值\n"
            },
            {
                "name": "lvgl.qrcode_create",
                "snippet": "lvgl.qrcode_create(${1:parent},${2:size},${3:dark_color},${4:light_color})",
                "description": "lvgl.qrcode_create(parent, size, dark_color, light_color) - 创建qrcode组件\n传入值：\nuserdata 父组件\nint 长度,因为qrcode是正方形\nint 二维码中数据点的颜色, RGB颜色, 默认 0x3333ff\nint 二维码中背景点的颜色, RGB颜色, 默认 0xeeeeff\n返回值：\nuserdata qrcode组件\n例子：\n-- 创建并显示qrcode\nlocal qrcode = lvgl.qrcode_create(scr, 100)\nlvgl.qrcode_update(qrcode, \"https://luatos.com\")\nlvgl.obj_align(qrcode, lvgl.scr_act(), lvgl.ALIGN_CENTER, -100, -100)\n"
            },
            {
                "name": "lvgl.qrcode_update",
                "snippet": "lvgl.qrcode_update(${1:qrcode},${2:cnt})",
                "description": "lvgl.qrcode_update(qrcode, cnt) - 设置qrcode组件的二维码内容,配合qrcode_create使用\n传入值：\nuserdata qrcode组件,由qrcode_create创建\nstring 二维码的内容数据\n返回值：\nbool 更新成功返回true,否则返回false. 通常只有数据太长无法容纳才会返回false\n"
            },
            {
                "name": "lvgl.qrcode_delete",
                "snippet": "lvgl.qrcode_delete(${1:qrcode})",
                "description": "lvgl.qrcode_delete(qrcode) - 删除qrcode组件\n传入值：\nuserdata qrcode组件,由qrcode_create创建\n返回值：\nnil 无返回值\n"
            },
            {
                "name": "lvgl.style_t",
                "snippet": "lvgl.style_t()",
                "description": "lvgl.style_t() - 创建一个style\n返回值：\nuserdata style指针\n例子：\nlocal style = lvgl.style_t()\nlvgl.style_init(style)\n"
            },
            {
                "name": "lvgl.style_create",
                "snippet": "lvgl.style_create()",
                "description": "lvgl.style_create() - 创建一个style并初始化\n返回值：\nuserdata style指针\n例子：\nlocal style = lvgl.style_create()\n"
            },
            {
                "name": "lvgl.style_list_create",
                "snippet": "lvgl.style_list_create()",
                "description": "lvgl.style_list_create() - 创建一个style_list\n返回值：\nuserdata style指针\n例子：\nlocal style_list = lvgl.style_list_create()\n"
            },
            {
                "name": "lvgl.style_list_t",
                "snippet": "lvgl.style_list_t()",
                "description": "lvgl.style_list_t() - 创建一个style_list\n返回值：\nuserdata style指针\n例子：\nlocal style = lvgl.style_list_t()\n"
            },
            {
                "name": "lvgl.style_delete",
                "snippet": "lvgl.style_delete(${1:style})",
                "description": "lvgl.style_delete(style) - 删除style,慎用,通常不会执行删除操作\n传入值：\nuserdata style指针\n例子：\nlocal style = lvgl.style_create()\n-- ...\n-- ...\n-- lvgl.style_delete(style)\n"
            },
            {
                "name": "lvgl.style_list_delete",
                "snippet": "lvgl.style_list_delete(${1:style})",
                "description": "lvgl.style_list_delete(style) - 删除style_list,慎用,通常不会执行删除操作\n传入值：\nuserdata style指针\n例子：\nlocal style_list = lvgl.style_list_create()\n-- ...\n-- ...\n-- lvgl.style_list_delete(style_list)\n"
            },
            {
                "name": "lvgl.demo_benchmark",
                "snippet": "lvgl.demo_benchmark()",
                "description": "lvgl.demo_benchmark() - lvgl benchmark demo\n返回值：\nnil 无返回值\n例子：\nlvgl.init()\nlvgl.demo_benchmark()\n"
            },
            {
                "name": "lvgl.demo_keypad_encoder",
                "snippet": "lvgl.demo_keypad_encoder()",
                "description": "lvgl.demo_keypad_encoder() - lvgl keypad_encoder demo\n返回值：\nnil 无返回值\n例子：\nlvgl.init()\nlvgl.demo_keypad_encoder()\n"
            },
            {
                "name": "lvgl.demo_music",
                "snippet": "lvgl.demo_music()",
                "description": "lvgl.demo_music() - lvgl music demo\n返回值：\nnil 无返回值\n例子：\nlvgl.init()\nlvgl.demo_music()\n"
            },
            {
                "name": "lvgl.demo_printer",
                "snippet": "lvgl.demo_printer()",
                "description": "lvgl.demo_printer() - lvgl printer demo\n返回值：\nnil 无返回值\n例子：\nlvgl.init()\nlvgl.demo_printer()\n"
            },
            {
                "name": "lvgl.demo_stress",
                "snippet": "lvgl.demo_stress()",
                "description": "lvgl.demo_stress() - lvgl stress demo\n返回值：\nnil 无返回值\n例子：\nlvgl.init()\nlvgl.demo_stress()\n"
            },
            {
                "name": "lvgl.demo_widgets",
                "snippet": "lvgl.demo_widgets()",
                "description": "lvgl.demo_widgets() - lvgl widgets demo\n返回值：\nnil 无返回值\n例子：\nlvgl.init()\nlvgl.demo_widgets()\n"
            },
            {
                "name": "lvgl.indev_drv_register",
                "snippet": "lvgl.indev_drv_register(${1:tp},${2:dtp})",
                "description": "lvgl.indev_drv_register(tp, dtp) - 注册输入设备驱动\n传入值：\nstring 设备类型，当前支持\"pointer\",指针类/触摸类均可，\"keyboard\",键盘类型\nstring 设备型号，当前支持\"emulator\",模拟器类型\n返回值：\nbool 成功返回true,否则返回false\n例子：\nlvgl.indev_drv_register(\"pointer\", \"emulator\")\n"
            },
            {
                "name": "lvgl.indev_point_emulator_update",
                "snippet": "lvgl.indev_point_emulator_update(${1:x},${2:y},${3:state})",
                "description": "lvgl.indev_point_emulator_update(x, y, state) - 更新模拟输入设备的坐标数据\n传入值：\nint x坐标,以左上角为0,右下角为最大值\nint y坐标,以左上角为0,右下角为最大值\nint 状态, 0 为 释放, 1 为按下\n返回值：\nnil 无返回值\n例子：\n-- 模拟在屏幕上的点击,通过timeout模拟长按和短按\nsys.taskInit(function(x, y, timeout)\n    lvgl.indev_point_emulator_update(x, y, 1)\n    sys.wait(timeout)\n    lvgl.indev_point_emulator_update(x, y, 0)\nend, 240, 120, 50)\n"
            },
            {
                "name": "lvgl.indev_kb_update",
                "snippet": "lvgl.indev_kb_update(${1:key})",
                "description": "lvgl.indev_kb_update(key) - 更新键盘输入设备的按键值\n传入值：\nint 按键值，默认为0，按键抬起\n返回值：\nnil 无返回值\n"
            },
            {
                "name": "lvgl.gif_create",
                "snippet": "lvgl.gif_create(${1:parent},${2:path})",
                "description": "lvgl.gif_create(parent, path) - 创建gif组件\n传入值：\nuserdata 父组件,可以是nil,但通常不会是nil\nstring 文件路径\n返回值：\nuserdata 组件指针,若失败会返回nil,建议检查\n例子：\nlocal gif = lvgl.gif_create(scr, \"S/emtry.gif\")\nif gif then\n    log.info(\"gif\", \"create ok\")\nend\n\n"
            },
            {
                "name": "lvgl.gif_restart",
                "snippet": "lvgl.gif_restart(${1:gif})",
                "description": "lvgl.gif_restart(gif) - 重新播放gif组件\n传入值：\nuserdata gif组件支持, 由gif_create方法返回\n返回值：\nnil 无返回值\n例子：\nlocal gif = lvgl.gif_create(scr, \"S/emtry.gif\")\nif gif then\n    log.info(\"gif\", \"create ok\")\nend\n\n"
            },
            {
                "name": "max30102.init",
                "snippet": "max30102.init(${1:i2c_id},${2:int})",
                "description": "max30102.init(i2c_id,int) - 初始化MAX30102传感器\n传入值：\nint 传感器所在的i2c总线id,默认为0\nint int引脚\n返回值：\nbool 成功返回true, 否则返回nil或者false\n例子：\nif max30102.init(0,pin.PC05) then\n    log.info(\"max30102\", \"init ok\")\nelse\n    log.info(\"max30102\", \"init fail\")\nend\n"
            },
            {
                "name": "max30102.get",
                "snippet": "max30102.get()",
                "description": "max30102.get() - 获取心率血氧(大概需要10s时间测量)\n返回值：\nbool 成功返回true, 否则返回nil或者false\nnumber 心率\nnumber 血氧\n"
            },
            {
                "name": "max30102.shutdown",
                "snippet": "max30102.shutdown()",
                "description": "max30102.shutdown() - 关闭max30102\n"
            },
            {
                "name": "mcu.setClk",
                "snippet": "mcu.setClk(${1:mhz})",
                "description": "mcu.setClk(mhz) - 设置主频,单位MHZ\n传入值：\nint 主频,根据设备的不同有不同的有效值,请查阅手册\n返回值：\nbool 成功返回true,否则返回false\n例子：\n\n-- 注意: 并非所有模块都支持主频调整,请查阅手册\n-- Air101/Air103/Air601 支持设置成 2/40/80/160/240. 特别提醒, 设置到2M后, 如果要休眠, 必须先设置到80M\n-- ESP32系列支持设置成 40/80/160/240 , 需要2024.1.1之后的固件\n-- Air780系列, Air105, 不支持设置主频\n-- Air780系列, 进入休眠模式时自动降频到24M\n\n-- 设置到80MHZ\nmcu.setClk(80)\nsys.wait(1000)\n-- 设置到240MHZ\nmcu.setClk(240)\nsys.wait(1000)\n-- 设置到2MHZ\nmcu.setClk(2)\nsys.wait(1000)\n"
            },
            {
                "name": "mcu.getClk",
                "snippet": "mcu.getClk()",
                "description": "mcu.getClk() - 获取主频,单位MHZ\n返回值：\nint 若失败返回-1,否则返回主频数值,若等于0,可能处于32k晶振的省电模式\n例子：\nlocal mhz = mcu.getClk()\nprint(\"Boom\", mhz)\n"
            },
            {
                "name": "mcu.unique_id",
                "snippet": "mcu.unique_id()",
                "description": "mcu.unique_id() - 获取设备唯一id. 注意,可能包含不可见字符,如需查看建议toHex()后打印\n返回值：\nstring 设备唯一id.若不支持, 会返回空字符串.\n例子：\nlocal unique_id = mcu.unique_id()\nprint(\"unique_id\", unique_id)\n"
            },
            {
                "name": "mcu.ticks",
                "snippet": "mcu.ticks()",
                "description": "mcu.ticks() - 获取启动后的tick数,本身是无符号值,范围0~0xffffffff,lua是有符号计算,计算时超过0x7fffffff会变负数\n返回值：\nint 当前tick值\n例子：\nlocal tick = mcu.ticks()\nprint(\"ticks\", tick)\n-- 如需不会溢出的值, 可用mcu.ticks32(), 于2024.5.7新增\n"
            },
            {
                "name": "mcu.hz",
                "snippet": "mcu.hz()",
                "description": "mcu.hz() - 获取每秒的tick数量\n返回值：\nint 每秒的tick数量,通常为1000\n例子：\nlocal hz = mcu.hz()\nprint(\"mcu.hz\", hz)\n"
            },
            {
                "name": "mcu.reg32",
                "snippet": "mcu.reg32(${1:address},${2:value},${3:mask})",
                "description": "mcu.reg32(address, value, mask) - 读写mcu的32bit寄存器或者ram,谨慎使用写功能,请熟悉mcu的寄存器使用方法后再使用\n传入值：\nint 寄存器或者ram地址\nint 写入的值,如果没有,则直接返回当前值\nint 位掩码,可以对特定几个位置的bit做修改, 默认0xffffffff,修改全部32bit\n返回值：\nint 返回当前寄存的值\n例子：\nlocal value = mcu.reg32(0x2009FFFC, 0x01, 0x01) --对0x2009FFFC地址上的值,修改bit0为1\n"
            },
            {
                "name": "mcu.x32",
                "snippet": "mcu.x32(${1:value})",
                "description": "mcu.x32(value) - 转换10进制数为16进制字符串输出\n传入值：\nint 需要转换的值\n返回值：\nstring 16进制字符串\n例子：\nlocal value = mcu.x32(0x2009FFFC) --输出\"0x2009fffc\"\n"
            },
            {
                "name": "mcu.tick64",
                "snippet": "mcu.tick64()",
                "description": "mcu.tick64() - 获取启动后的高精度tick，如果支持bit64库，可以直接输出转换好的bit64结构\n传入值：\nboolean 是否输出bit64结构,true是,其他都是false,留空也是false,用于兼容旧的demo\n返回值：\nstring 当前tick值,8个字节的uint64,如果支持64bit库,同时要求输出64bit结构的话,会输出9字节的string\nint 1us有几个tick,0表示未知\n例子：\nlocal tick_str, tick_per = mcu.tick64()\nprint(\"ticks\", tick_str, tick_per)\n"
            },
            {
                "name": "mcu.dtick64",
                "snippet": "mcu.dtick64(${1:tick1},${2:tick2},${3:check_value})",
                "description": "mcu.dtick64(tick1, tick2, check_value) - 计算2个64bit tick的差值\n传入值：\nstring 64bit的string\nstring 64bit的string\nint 参考值,可选项,如果为0,则返回结果中第一个项目为true\n返回值：\nboolean 与参考值比较,如果大于等于为true,反之为false\nint 差值tick1 - tick2,如果超过了0x7fffffff,结果可能是错的\n例子：\nlocal result, diff_tick = mcu.dtick64(tick1, tick2)\nprint(\"ticks\", result, diff_tick)\n"
            },
            {
                "name": "mcu.setXTAL",
                "snippet": "mcu.setXTAL(${1:source_main},${2:source_32k},${3:delay})",
                "description": "mcu.setXTAL(source_main, source_32k, delay) - 选择时钟源,当前仅air105支持\n传入值：\nboolean 高速时钟是否使用外部时钟源,如果为空则不改变\nboolean 低速32K是否使用外部时钟源,如果为空则不改变\nint PLL稳定时间,在切换高速时钟的时候,根据硬件环境,需要delay一段时间等待PLL稳定,默认是1200,建议不小于1024\n例子：\nmcu.setXTAL(true, true, 1248)    --高速时钟使用外部时钟,低速32K使用外部晶振, delay1248\n"
            },
            {
                "name": "mcu.hardfault",
                "snippet": "mcu.hardfault(${1:mode})",
                "description": "mcu.hardfault(mode) - mcu死机时处理模式，目前只有EC618平台适用\n传入值：\nint 处理模式，0死机停机，1死机后重启，2死机后尽量将错误信息提交给外部工具后重启 3.死机时写入关键信息到flash后立刻重启\n例子：\nmcu.hardfault(0)    --死机后停机，一般用于调试状态\nmcu.hardfault(1)    --死机后重启，一般用于正式产品\nmcu.hardfault(2)    --死机后尽量将错误信息提交给外部工具后重启，一般用于压力测试或者正式产品\n"
            },
            {
                "name": "mcu.iomux",
                "snippet": "mcu.iomux(${1:type},${2:channel},${3:value})",
                "description": "mcu.iomux(type, channel, value) - 在外设打开前，将外设IO复用到非默认配置上，目前只支持Air780E的部分外设复用到其他配置，这是一个临时接口，如果后续有更合适的api，本接口将不再更新\n传入值：\nint 外设类型，目前只有mcu.UART,mcu.I2C\nint 总线序号，0~N，\nint 新的配置，这个需要根据具体平台决定\n例子：\nmcu.iomux(mcu.UART, 2, 1)    -- Air780E的UART2复用到gpio12和gpio13(Air780EG默认是这个复用，不要动)\nmcu.iomux(mcu.UART, 2, 2)    -- Air780E的UART2复用到gpio6和gpio7\nmcu.iomux(mcu.I2C, 0, 1)    -- Air780E的I2C0复用到gpio12和gpio13\nmcu.iomux(mcu.I2C, 0, 2)    -- Air780E的I2C0复用到gpio16和gpio17\nmcu.iomux(mcu.I2C, 1, 1)    -- Air780E的I2C1复用到gpio4和gpio5\n"
            },
            {
                "name": "mcu.altfun",
                "snippet": "mcu.altfun(${1:type},${2:sn},${3:pad_index},${4:alt_fun},${5:is_input})",
                "description": "mcu.altfun(type, sn, pad_index, alt_fun, is_input) - IO外设功能复用选择，注意普通MCU是以GPIO号为序号，但是专用SOC，比如CAT1的，是以PAD号为序号。本函数不是所有平台适用\n传入值：\nint 外设类型，目前有mcu.UART,mcu.I2C,mcu.SPI,mcu.PWM,mcu.GPIO,mcu.I2S,mcu.LCD,mcu.CAM，具体需要看平台\nint 总线序号，0~N，如果是mcu.GPIO，则是GPIO号。具体看平台的IOMUX复用表\nint pad号，如果留空不写，则表示清除配置，使用平台的默认配置。具体看平台的IOMUX复用表\nint 复用功能序号，0~N。具体看平台的IOMUX复用表\nboolean 是否是输入功能，true是，留空是false\n例子：\n-- 以 Air780EP 为例\n-- 将GPIO46映射到paddr 32 alt 1\nmcu.altfun(mcu.GPIO, 46, 32, 1, 0)\n-- mcu.altfun(mcu.GPIO, 46) -- 还原成默认配置\n\n-- UART2复用到paddr 25/26 alt 3\nmcu.altfun(mcu.UART,2,  25, 3, 1)\nmcu.altfun(mcu.UART,2,  26, 3, 0)\n"
            },
            {
                "name": "mcu.ticks2",
                "snippet": "mcu.ticks2(${1:mode})",
                "description": "mcu.ticks2(mode) - 获取高精度的计数\n传入值：\nint 模式, 看后面的用法说明\n返回值：\nint 根据mode的不同,返回值的含义不同\n例子：\n-- 本函数于2024.5.7新增\n-- 与mcu.ticks()的区别是,底层计数器是64bit的, 在可预计的将来不会溢出\n-- 所以本函数返回的值总是递增的, 而且32bit固件也能处理\n\n-- 模式可选值 及 对应的返回值\n-- 0: 返回微秒数, 以秒为分割, 例如 1234567890us 返回2个值: 1234, 567890\n-- 1: 返回毫秒数, 以千秒为分割, 例如 1234567890ms 返回2个值: 1234, 567890\n-- 2: 返回秒数,   以百万秒为分割, 例如 1234567890s  返回2个值: 1234, 567890\n\nlocal us_h, us_l = mcu.ticks2(0)\nlocal ms_h, ms_l = mcu.ticks2(1)\nlocal sec_h, sec_l = mcu.ticks2(2)\nlog.info(\"us_h\", us_h, \"us_l\", us_l)\nlog.info(\"ms_h\", ms_h, \"ms_l\", ms_l)\nlog.info(\"sec_h\", sec_h, \"sec_l\", sec_l)\n"
            },
            {
                "name": "mcu.XTALRefOutput",
                "snippet": "mcu.XTALRefOutput(${1:source_main},${2:source_32k})",
                "description": "mcu.XTALRefOutput(source_main, source_32k) - 晶振参考时钟输出\n传入值：\nboolean 高速晶振参考时钟是否输出\nboolean 低速32K晶振参考时钟是否输出\n例子：\n-- 本函数于2024.5.17新增\n-- 当前仅Air780EP系列支持\nmcu.XTALRefOutput(true, false)    --高速晶振参考时钟输出,低速32K不输出\n"
            },
            {
                "name": "miniz.compress",
                "snippet": "miniz.compress(${1:data},${2:flags})",
                "description": "miniz.compress(data, flags) - 快速压缩,需要165kb的系统内存和32kb的LuaVM内存\n传入值：\nstring 待压缩的数据, 少于400字节的数据不建议压缩, 且压缩后的数据不能大于32k.\nflags 压缩参数,默认是 miniz.WRITE_ZLIB_HEADER , 即写入zlib头部\n返回值：\nstring 若压缩成功,返回数据字符串, 否则返回nil\n例子：\n\nlocal bigdata = \"123jfoiq4hlkfjbnasdilfhuqwo;hfashfp9qw38hrfaios;hfiuoaghfluaeisw\"\nlocal cdata = miniz.compress(bigdata)\nif cdata then\n    log.info(\"miniz\", \"before\", #bigdata, \"after\", #cdata)\n    log.info(\"miniz\", \"cdata as hex\", cdata:toHex())\nend\n\n"
            },
            {
                "name": "miniz.uncompress",
                "snippet": "miniz.uncompress(${1:data},${2:flags})",
                "description": "miniz.uncompress(data, flags) - 快速解压,需要32kb的LuaVM内存\n传入值：\nstring 待解压的数据, 解压后的数据不能大于32k\nflags 解压参数,默认是 miniz.PARSE_ZLIB_HEADER , 即解析zlib头部\n返回值：\nstring 若解压成功,返回数据字符串, 否则返回nil\n例子：\n\nlocal bigdata = \"123jfoiq4hlkfjbnasdilfhuqwo;hfashfp9qw38hrfaios;hfiuoaghfluaeisw\"\nlocal cdata = miniz.compress(bigdata)\nif cdata then\n    log.info(\"miniz\", \"before\", #bigdata, \"after\", #cdata)\n    log.info(\"miniz\", \"cdata as hex\", cdata:toHex())\n\n    local udata = miniz.uncompress(cdata)\n    log.info(\"miniz\", \"udata\", udata)\nend\n"
            },
            {
                "name": "mlx90640.init",
                "snippet": "mlx90640.init(${1:i2c_id},${2:refresh_rate)(注意:2023.5.15之后使用此接口},${3:用户需要自行初始化i2c接口})",
                "description": "mlx90640.init(i2c_id,refresh_rate) (注意:2023.5.15之后使用此接口,用户需要自行初始化i2c接口) - 初始化MLX90640传感器\n传入值：\nint 传感器所在的i2c总线id或者软i2c对象,默认为0\nint 传感器的测量速率,默认为4Hz\n返回值：\nbool 成功返回true, 否则返回nil或者false\n例子：\ni2c.setup(i2cid,i2c_speed)\nif mlx90640.init(0,mlx90640.FPS4HZ) then\n    log.info(\"mlx90640\", \"init ok\")\n    sys.wait(500) -- 稍等片刻\n    while 1 do\n        mlx90640.feed() -- 取一帧数据\n        mlx90640.draw2lcd(0, 0 ,1)-- 需提前把lcd初始化好\n        sys.wait(250) -- 默认是4HZ\n    end\nelse\n    log.info(\"mlx90640\", \"init fail\")\nend\n\n"
            },
            {
                "name": "mlx90640.feed",
                "snippet": "mlx90640.feed()",
                "description": "mlx90640.feed() - 取一帧数据\n"
            },
            {
                "name": "mlx90640.raw_data",
                "snippet": "mlx90640.raw_data()",
                "description": "mlx90640.raw_data() - 获取底层裸数据,浮点数矩阵\n返回值：\ntable 浮点数数据,768个像素对应的温度值\n"
            },
            {
                "name": "mlx90640.raw_point",
                "snippet": "mlx90640.raw_point(${1:index})",
                "description": "mlx90640.raw_point(index) - 获取单一点数据\n传入值：\nint 索引值(0-767)\n返回值：\nnumber 单点温度值\n"
            },
            {
                "name": "mlx90640.ta_temp",
                "snippet": "mlx90640.ta_temp()",
                "description": "mlx90640.ta_temp() - 获取外壳温度\n返回值：\nnumber 外壳温度\n"
            },
            {
                "name": "mlx90640.max_temp",
                "snippet": "mlx90640.max_temp()",
                "description": "mlx90640.max_temp() - 获取最高温度\n返回值：\nnumber 最高温度\nnumber 最高温度位置\n"
            },
            {
                "name": "mlx90640.min_temp",
                "snippet": "mlx90640.min_temp()",
                "description": "mlx90640.min_temp() - 获取最低温度\n返回值：\nnumber 最低温度\nnumber 最低温度位置\n"
            },
            {
                "name": "mlx90640.average_temp",
                "snippet": "mlx90640.average_temp()",
                "description": "mlx90640.average_temp() - 获取平均温度\n返回值：\nnumber 平均温度\n"
            },
            {
                "name": "mlx90640.get_vdd",
                "snippet": "mlx90640.get_vdd()",
                "description": "mlx90640.get_vdd() - 获取vdd\n返回值：\nnumber vdd\n"
            },
            {
                "name": "mlx90640.draw2lcd",
                "snippet": "mlx90640.draw2lcd(${1:x},${2:y},${3:fold})",
                "description": "mlx90640.draw2lcd(x, y, fold) - 绘制到lcd\n传入值：\nint 左上角x坐标\nint 左上角y坐标\nint 放大倍数,必须为2的指数倍(1,2,4,8,16...)默认为1\n返回值：\nbool 成功返回true,否则返回false\n"
            },
            {
                "name": "mobile.imei",
                "snippet": "mobile.imei(${1:index})",
                "description": "mobile.imei(index) - 获取IMEI\n传入值：\nint 编号,默认0. 在支持双卡的模块上才会出现0或1的情况\n返回值：\nstring 当前的IMEI值,若失败返回nil\n"
            },
            {
                "name": "mobile.imsi",
                "snippet": "mobile.imsi(${1:index})",
                "description": "mobile.imsi(index) - 获取IMSI\n传入值：\nint 编号,默认0. 在支持双卡的模块上才会出现0或1的情况\n返回值：\nstring 当前的IMSI值,若失败返回nil\n"
            },
            {
                "name": "mobile.sn",
                "snippet": "mobile.sn()",
                "description": "mobile.sn() - 获取SN\n返回值：\nstring 当前的SN值,若失败返回nil. 注意, SN可能包含不可见字符\n例子：\n-- 注意, 出厂未必有写SN\n-- 一般用途的唯一id, 可以用mobile.imei()代替\n-- 如需要真正的唯一ID, 使用 mcu.unique_id()\n"
            },
            {
                "name": "mobile.muid",
                "snippet": "mobile.muid()",
                "description": "mobile.muid() - 获取MUID\n返回值：\nstring 当前的MUID值,若失败返回nil\n"
            },
            {
                "name": "mobile.iccid",
                "snippet": "mobile.iccid(${1:id})",
                "description": "mobile.iccid(id) - 获取或设置ICCID\n传入值：\nint SIM卡的编号, 例如0, 1, 默认0\n返回值：\nstring ICCID值,若失败返回nil\n"
            },
            {
                "name": "mobile.number",
                "snippet": "mobile.number(${1:id})",
                "description": "mobile.number(id) - 获取手机卡号，注意，只有写入了手机号才能读出，因此有可能读出来是空的\n传入值：\nint SIM卡的编号, 例如0, 1, 默认0\n返回值：\nstring number值,若失败返回nil\n"
            },
            {
                "name": "mobile.simid",
                "snippet": "mobile.simid(${1:id})",
                "description": "mobile.simid(id) - 获取当前SIM卡槽,或者切换卡槽\n传入值：\nint SIM卡的编号, 例如0, 1, 如果支持双卡，比如EC618，可以填2来自适应，但是会占用掉4个IO(gpio4/5/6/23)。如果不填就直接读取当前卡槽\nboolean 是否优先用SIM0，只有SIM卡编号写2自适应才有用！！！。true优先用SIM0，false则由具体平台决定，支持双卡双待SIM0优先，不支持的是上一次检测到的优先，默认是false，必须在开机就配置，否则就无效了\n返回值：\nint 当前sim卡槽编号,若失败返回-1\n例子：\nmobile.simid(0) -- 固定使用SIM0\nmobile.simid(1) -- 固件使用SIM1\nmobile.simid(2) -- 自动识别SIM0, SIM1, 优先级看具体平台\nmobile.simid(2, true) -- -- 自动识别SIM0, SIM1, 且SIM0优先\n-- 提醒, 自动识别是会增加时间的\n"
            },
            {
                "name": "mobile.simPin",
                "snippet": "mobile.simPin(${1:id},${2:operation},${3:pin1},${4:pin2})",
                "description": "mobile.simPin(id,operation,pin1,pin2) - 检测当前SIM卡是否准备好，对SIM卡的PIN码做相关操作\n传入值：\nint SIM卡的编号, 例如0, 1, 支持双卡双待的才需要选择\nint PIN码操作类型，只能是mobile.PIN_XXXX，不操作就留空\nstring 更换pin时操作的pin码，或者验证操作的pin码，或者解锁pin码时的PUK，4~8字节\nstring 更换pin码操作时的新的pin码，解锁pin码时的新PIN，4~8字节\n返回值：\nboolean 当无PIN操作时，返回SIM卡是否准备好，有PIN操作时，返回是否成功\n例子：\nlocal cpin_is_ready = mobile.simPin() -- 当前sim卡是否准备好，一般返回false就是没卡\nlocal succ = mobile.simPin(0, mobile.PIN_VERIFY, \"1234\")    -- 输入pin码验证\n"
            },
            {
                "name": "mobile.rtime",
                "snippet": "mobile.rtime(${1:time},${2:auto_reset_stack},${3:data_first})",
                "description": "mobile.rtime(time, auto_reset_stack, data_first) - 设置RRC自动释放时间间隔，当开启时后，遇到极弱信号+频繁数据操作可能会引起网络严重故障，因此需要额外设置自动重启协议栈\n传入值：\nint RRC自动释放时间，等同于Air724的AT+RTIME，单位秒，写0或者不写则是停用，不要超过20秒，没有意义\nboolean 网络遇到严重故障时尝试自动恢复，和飞行模式/SIM卡切换冲突，true开启，false关闭，留空时，如果设置了时间则自动开启。本参数于2023年9月14日已废弃\nboolean 是否启用数据传输优化，true启用，false关闭，留空为false，开启后必须等到TCP数据ACK或者超时失败，或者socket CONNECT完成（无论成功或者失败）才允许RRC提前释放，可能会增加功耗。本参数于2024年8月12日启用\n返回值：\nnil 无返回值\n例子：\nmobile.rtime(3)    --与基站无数据交互3秒后提前释放RRC\nmobile.rtime(3,nil,true) --启用数据传输优化，与基站无数据交互3秒后，提前释放RRC\n"
            },
            {
                "name": "mobile.setAuto",
                "snippet": "mobile.setAuto(${1:check_sim_period},${2:get_cell_period},${3:search_cell_time},${4:auto_reset_stack},${5:network_check_period})",
                "description": "mobile.setAuto(check_sim_period, get_cell_period, search_cell_time, auto_reset_stack, network_check_period) - 设置一些辅助周期性或者自动功能，目前支持SIM卡暂时脱离后恢复，周期性获取小区信息，网络遇到严重故障时尝试自动恢复\n传入值：\nint SIM卡自动恢复时间，单位毫秒，建议5000~10000，和飞行模式/SIM卡切换冲突，不能再同一时间使用，必须错开执行。写0或者不写则是关闭功能\nint 周期性获取小区信息的时间间隔，单位毫秒。获取小区信息会增加部分功耗。写0或者不写则是关闭功能\nint 每次搜索小区时最大搜索时间，单位秒。不要超过8秒\nboolean 网络遇到严重故障时尝试自动恢复，和飞行模式/SIM卡切换冲突，true开启，false关闭，开始状态是false，留空则不做改变\nint 设置定时检测网络是否正常并且在检测到长时间无网时通过重启协议栈来恢复，无网恢复时长，单位ms，建议60000以上，为网络搜索网络保留足够的时间，留空则不做更改\n返回值：\nnil 无返回值\n"
            },
            {
                "name": "mobile.apn",
                "snippet": "mobile.apn(${1:index},${2:cid},${3:new_apn_name},${4:user_name},${5:password},${6:ip_type},${7:protocol})",
                "description": "mobile.apn(index, cid, new_apn_name, user_name, password, ip_type, protocol) - 获取或设置APN，设置APN必须在入网前就设置好，比如在SIM卡识别完成前就设置好\n传入值：\nint 编号,默认0. 在支持双卡的模块上才会出现0或1的情况\nint cid, 默认0，如果要用非默认APN来激活，必须>0\nstring 新的APN,不填就是获取APN, 填了就是设置APN, 是否支持设置取决于底层实现\nstring 新的APN的username,如果APN不是空,那必须填写,如果没有留个空字符串\"\"。如果APN是空的，那可以nil\nstring 新的APN的password,如果APN不是空,那必须填写,如果没有留个空字符串\"\"。如果APN是空的，那可以nil\nint 激活APN时的IP TYPE,1=IPV4 2=IPV6 3=IPV4V6,默认是1\nint 激活APN时,如果需要username和password,就要写鉴权协议类型,1~3,默认3,代表1和2都尝试一下。不需要鉴权的写0\nboolean 是否删除APN,true是,其他都否,只有参数3新的APN不是string的时候才有效果\n返回值：\nstring 如果网络注册成功，返回注册用的APN值，反之是nil。设置好不会立刻有返回值，需要等网络注册成功\n例子：\nmobile.apn(0,1,\"cmiot\",\"\",\"\",nil,0) -- 移动公网卡设置APN为cmiot,一般不用设置\nmobile.apn(0,1,\"name\",\"user\",\"password\",nil,3) -- 专网卡设置的demo，name，user，password联系卡商获取\n"
            },
            {
                "name": "mobile.ipv6",
                "snippet": "mobile.ipv6(${1:onff})",
                "description": "mobile.ipv6(onff) - 是否默认开启IPV6功能，必须在LTE网络连接前就设置好\n传入值：\nboolean 开关 true开启 false 关闭\n返回值：\nboolean true 当前是开启的，false 当前是关闭的\n例子：\n-- 注意, 开启ipv6后, 开机联网会慢2~3秒\n"
            },
            {
                "name": "mobile.csq",
                "snippet": "mobile.csq()",
                "description": "mobile.csq() - 获取csq\n返回值：\nint 当前CSQ值, 若失败返回0. 范围 0 - 31, 越大越好\n例子：\n-- 注意, 4G模块的CSQ值仅供参考, rsrp/rsrq才是真正的信号强度指标\n"
            },
            {
                "name": "mobile.rssi",
                "snippet": "mobile.rssi()",
                "description": "mobile.rssi() - 获取rssi\n返回值：\nint 当前rssi值,若失败返回0. 范围 0 到 -114, 越小越好\n"
            },
            {
                "name": "mobile.rsrp",
                "snippet": "mobile.rsrp()",
                "description": "mobile.rsrp() - 获取rsrp,参考信号接收功率\n返回值：\nint 当前rsrp值,若失败返回0. 取值范围: -44 ~ -140 ，值越大越好\n"
            },
            {
                "name": "mobile.rsrq",
                "snippet": "mobile.rsrq()",
                "description": "mobile.rsrq() - 获取rsrq,参考信号发送功率\n返回值：\nint 当前rsrq值,若失败返回0.  取值范围: -3 ~ -19.5 ，值越大越好\n"
            },
            {
                "name": "mobile.snr",
                "snippet": "mobile.snr()",
                "description": "mobile.snr() - 获取snr,信噪比\n返回值：\nint 当前snq值,若失败返回0.范围 0 - 30, 越大越好\n"
            },
            {
                "name": "mobile.eci",
                "snippet": "mobile.eci()",
                "description": "mobile.eci() - 获取当前服务小区的ECI(E-UTRAN Cell Identifier)\n返回值：\nint 当前eci值,若失败返回-1\n"
            },
            {
                "name": "mobile.tac",
                "snippet": "mobile.tac()",
                "description": "mobile.tac() - 获取当前服务小区的TAC或者LAC\n返回值：\nint 当前eci值,若失败返回-1. 如果尚未注册到网络,会返回0\n例子：\n-- 本API于 2023.7.9 新增\n"
            },
            {
                "name": "mobile.enbid",
                "snippet": "mobile.enbid()",
                "description": "mobile.enbid() - 获取当前服务小区的eNBID(eNodeB Identifier)\n返回值：\nint 当前enbid值,若失败返回-1\n"
            },
            {
                "name": "mobile.scell",
                "snippet": "mobile.scell()",
                "description": "mobile.scell() - 获取当前服务小区更详细的信息\n返回值：\ntable 服务小区的信息\n例子：\n-- 本API于 2024.9.12 新增\nlog.info(\"cell\", json.encode(mobile.scell()))\n-- 返回值示例\n{\n    \"mnc\": 11,\n    \"mcc\": 460,\n    \"rssi\": -78,\n    \"pci\": 115,\n    \"rsrp\": -107,\n    \"tac\": 30005,\n    \"eci\": 124045360,\n    \"cid\": 124045360,\n    \"rsrq\": -9,\n    \"snr\": 15,\n    \"earfcn\": 1850\n}\n"
            },
            {
                "name": "mobile.flymode",
                "snippet": "mobile.flymode(${1:index},${2:enable})",
                "description": "mobile.flymode(index, enable) - 进出飞行模式\n传入值：\nint 编号,默认0. 在支持双卡的模块上才会出现0或1的情况\nbool 是否设置为飞行模式,true为设置, false为退出,可选\n返回值：\nbool 原飞行模式的状态\n"
            },
            {
                "name": "mobile.syncTime",
                "snippet": "mobile.syncTime(${1:enable})",
                "description": "mobile.syncTime(enable) - 配置基站同步时间开关，默认开启\n传入值：\nbool 开启,true开启, false关闭, nil不设置\n返回值：\nbool 当前开关状态\n例子：\nmobile.syncTime() --获取当前开关状态\nmobile.syncTime(false) --关闭基站同步时间\n"
            },
            {
                "name": "mobile.status",
                "snippet": "mobile.status()",
                "description": "mobile.status() - 获取网络状态\n返回值：\nint 当前网络状态\n例子：\n-- 状态描述\n-- 0:网络未注册\n-- 1:网络已注册\n-- 2:正在搜网中\n-- 3:网络注册被拒绝\n-- 4:网络状态未知\n-- 5:漫游,且已注册\n-- 6:仅SMS可用\n-- 7:仅SMS可用,且漫游状态\n-- 8:仅紧急呼叫. 注意, 国内不支持此状态,模块也不支持紧急呼叫\n\n-- 不推荐使用本API判断联网状态, 建议使用socket.localIP()来判断\n"
            },
            {
                "name": "mobile.getCellInfo",
                "snippet": "mobile.getCellInfo()",
                "description": "mobile.getCellInfo() - 获取基站信息\n返回值：\ntable 包含基站数据的数组\n例子：\n-- 注意: 从2023.06.20开始, 需要主动请求一次reqCellInfo才会有基站数据.\n\n--示例输出(原始数据是table, 下面是json格式化后的内容)\n--[[\n[\n    {\"rsrq\":-10,\"rssi\":-55,\"cid\":124045360,\"mnc\":17,\"pci\":115,\"earfcn\":1850,\"snr\":15,\"rsrp\":-85,\"mcc\":1120,\"tdd\":0},\n    {\"pci\":388,\"rsrq\":-11,\"mnc\":17,\"earfcn\":2452,\"snr\":5,\"rsrp\":-67,\"mcc\":1120,\"cid\":124045331},\n    {\"pci\":100,\"rsrq\":-9,\"mnc\":17,\"earfcn\":75,\"snr\":17,\"rsrp\":-109,\"mcc\":1120,\"cid\":227096712}\n]\n]]\n\nmobile.reqCellInfo(60)\n-- 订阅\nsys.subscribe(\"CELL_INFO_UPDATE\", function()\n    log.info(\"cell\", json.encode(mobile.getCellInfo()))\nend)\n\n-- 定期轮训式\nsys.taskInit(function()\n    sys.wait(3000)\n    while 1 do\n        mobile.reqCellInfo(15)\n        sys.waitUntil(\"CELL_INFO_UPDATE\", 15000)\n        log.info(\"cell\", json.encode(mobile.getCellInfo()))\n    end\nend)\n"
            },
            {
                "name": "mobile.reqCellInfo",
                "snippet": "mobile.reqCellInfo(${1:timeout})",
                "description": "mobile.reqCellInfo(timeout) - 发起基站信息查询,含临近小区\n传入值：\nint 超时时长,单位秒,默认15. 最少5, 最高60\n返回值：\nnil 无返回值\n例子：\n-- 参考 mobile.getCellInfo 函数\n"
            },
            {
                "name": "mobile.lockCell",
                "snippet": "mobile.lockCell(${1:mode},${2:earfcn},${3:pci})",
                "description": "mobile.lockCell(mode, earfcn, pci) - 锁定/解锁小区，仅用于外场测试，没接触过的，或者生产环境中请勿使用\n传入值：\nint 操作码 0删除优先的频点，1设置优先频点，2锁定小区，3解锁小区\nint 下行频点\nint phycellid\n返回值：\nbool 成功true 失败false\n例子：\nmobile.lockCell(2,1860,32)    --锁定小区\nmobile.lockCell(3)            --解锁小区\n"
            },
            {
                "name": "mobile.reset",
                "snippet": "mobile.reset()",
                "description": "mobile.reset() - 重启协议栈\n返回值：\nnil 无返回值\n例子：\n-- 重启LTE协议栈\nmobile.reset()\n"
            },
            {
                "name": "mobile.dataTraffic",
                "snippet": "mobile.dataTraffic(${1:clearUplink},${2:clearDownlink})",
                "description": "mobile.dataTraffic(clearUplink, clearDownlink) - 数据量流量处理\n传入值：\nboolean 清空上行流量累计值，true清空，其他忽略\nboolean 清空下行流量累计值，true清空，其他忽略\n返回值：\nint 上行流量GB\nint 上行流量B\nint 下行流量GB\nint 下行流量B\n例子：\n-- 获取上下行流量累计值\n-- 上行流量值Byte = uplinkGB * 1024 * 1024 * 1024 + uplinkB\n-- 下行流量值Byte = downlinkGB * 1024 * 1024 * 1024 + downlinkB\nlocal uplinkGB, uplinkB, downlinkGB, downlinkB = mobile.dataTraffic()\n\n-- 清空上下行流量累计值\nmobile.dataTraffic(true, true)\n\n-- 仅记录开机后的流量,复位/重启会归零\n"
            },
            {
                "name": "mobile.config",
                "snippet": "mobile.config(${1:item},${2:value})",
                "description": "mobile.config(item, value) - 网络特殊配置\n传入值：\nint 配置项目，看mobile.CONF_XXX\nint 配置值,根据具体配置的item决定\n返回值：\nboolean 是否成功\n例子：\n--针对不同平台有不同的配置，谨慎使用，目前只有EC618/EC718系列\n\n-- EC618配置小区重选信号差值门限，不能大于15dbm，必须在飞行模式下才能用\nmobile.flymode(0,true)\nmobile.config(mobile.CONF_RESELTOWEAKNCELL, 15)\nmobile.config(mobile.CONF_STATICCONFIG, 1) --开启网络静态优化\nmobile.flymode(0,false)\n\n-- EC618设置SIM写入次数的统计\n-- 关闭统计\nmobile.config(mobile.CONF_SIM_WC_MODE, 0)\n-- 开启统计, 默认也是开启的.\nmobile.config(mobile.CONF_SIM_WC_MODE, 1)\n-- 读取统计值,异步, 需要通过系统消息SIM_IND获取\nsys.subscribe(\"SIM_IND\", function(stats, value)\n    log.info(\"SIM_IND\", stats)\n    if stats == \"SIM_WC\" then\n        log.info(\"sim\", \"write counter\", value)\n    end\nend)\nmobile.config(mobile.CONF_SIM_WC_MODE, 2)\n-- 清空统计值\nmobile.config(mobile.CONF_SIM_WC_MODE, 3)\n"
            },
            {
                "name": "mobile.getBand",
                "snippet": "mobile.getBand(${1:band},${2:is_default})",
                "description": "mobile.getBand(band, is_default) - 获取当前使用/支持的band\n传入值：\nzbuff 输出band\nboolean true默认支持，false当前支持的，默认是false，当前是预留功能，不要写true\n返回值：\nboolean 成功返回true，失败放回false\n例子：\nlocal buff = zbuff.create(40)\nmobile.getBand(buff) --输出当前使用的band，band号放在buff内，buff[0]，buff[1]，buff[2] .. buff[buff:used() - 1]\n"
            },
            {
                "name": "mobile.setBand",
                "snippet": "mobile.setBand(${1:band},${2:num})",
                "description": "mobile.setBand(band, num) - 设置使用的band\n传入值：\nzbuff 输入使用的band\nint band数量\n返回值：\nboolean 成功返回true，失败放回false\n例子：\nlocal buff = zbuff.create(40)\nbuff[0] = 3\nbuff[1] = 5\nbuff[2] = 8\nbuff[3] = 40\nmobile.setBand(buff, 4) --设置使用的band一共4个，为3,5,8,40\n"
            },
            {
                "name": "mobile.nstOnOff",
                "snippet": "mobile.nstOnOff(${1:onoff},${2:uart_id})",
                "description": "mobile.nstOnOff(onoff, uart_id) - RF测试开关和配置\n传入值：\nboolean true开启测试模式，false关闭\nint 串口号\n返回值：\nnil 无返回值\n例子：\nmobile.nstOnOff(true, uart.VUART_0)    --打开测试模式，并且用虚拟串口发送结果\nmobile.nstOnOff(false) --关闭测试模式\n"
            },
            {
                "name": "mobile.nstInput",
                "snippet": "mobile.nstInput(${1:data})",
                "description": "mobile.nstInput(data) - RF测试数据输入\n传入值：\nstring or zbuff 用户从串口获取的数据，注意，当获取完所有数据后，需要再传一个nil来作为传输结束\n返回值：\nnil 无返回值\n例子：\nmobile.nstInput(uart_data)\nmobile.nstInput(nil)\n"
            },
            {
                "name": "mobile.vsimInit",
                "snippet": "mobile.vsimInit()",
                "description": "mobile.vsimInit() - 初始化内置默认虚拟卡功能(不可用)\n返回值：\nnil 无返回值\n例子：\nmobile.vsimInit()\n"
            },
            {
                "name": "mobile.vsimOnOff",
                "snippet": "mobile.vsimOnOff(${1:enable})",
                "description": "mobile.vsimOnOff(enable) - 切换内置虚拟卡和外置实体卡，2024年8月13日启用，虚拟卡需要固件支持，否则切换后无网络，需要在飞行模式下切换，或者切换后重启协议栈\n传入值：\nbool 开启,true开启, false关闭\n返回值：\nnil 无返回值\n例子：\nmobile.vsimOnOff(true) --使用内置虚拟卡\nmobile.vsimOnOff(false) --使用外置实体卡\n"
            },
            {
                "name": "mobile.apnTableInit",
                "snippet": "mobile.apnTableInit()",
                "description": "mobile.apnTableInit() - 初始化自定义APN列表，主要用于海外SIM卡\n返回值：\nnil 无返回值\n例子：\nmobile.apnTableInit()\n"
            },
            {
                "name": "mobile.apnTableAdd",
                "snippet": "mobile.apnTableAdd(${1:mcc},${2:mnc},${3:ip_type},${4:protocol},${5:apn_name},${6:user_name},${7:password})",
                "description": "mobile.apnTableAdd(mcc, mnc, ip_type, protocol, apn_name, user_name, password) - 往自定义APN列表添加一条APN信息，主要用于海外SIM卡\n传入值：\nint MCC码,16进制BCD码\nint MNC码,16进制BCD码\nint 激活APN时的IP TYPE,1=IPV4 2=IPV6 3=IPV4V6,默认是1\nint 激活APN时,如果需要username和password,就要写鉴权协议类型,1~3,默认3,代表1和2都尝试一下。不需要鉴权的写0\nstring APN name,不能为空\nstring APN的username\nstring APN的password\n返回值：\nnil 无返回值\n例子：\nmobile.apnTableInit() -- 先初始化，必须放在SIM卡识别完成前加入，最好就是写在开头\nmobile.apnTableAdd(0x460,0x00,3,0,\"cmiot\",\"\",\"\") -- 单独添加一条APN信息，必须放在SIM卡识别完成前加入，最好就是写在开头，移动公网卡设置APN为cmiot（一般不用设置，这里只是举个例子）\n\n"
            },
            {
                "name": "mobile.apnTablePrint",
                "snippet": "mobile.apnTablePrint(${1:mcc},${2:mnc})",
                "description": "mobile.apnTablePrint(mcc, mnc) - 打印自定义APN列表里的一条信息，在没有拿到卡的情况下，测试一下对应的APN信息是否和运营商提供的匹配\n传入值：\nint MCC码,16进制BCD码\nint MNC码,16进制BCD码\n返回值：\nnil 无返回值\n例子：\nmobile.apnTableInit()\nmobile.apnTablePrint(0x202, 0x01)\n"
            },
            {
                "name": "mqttc:subscribe",
                "snippet": "mqttc:subscribe(${1:topic},${2:qos})",
                "description": "mqttc:subscribe(topic, qos) - 订阅主题\n传入值：\nstring/table 主题\nint topic为string时生效 0/1/2 默认0\n返回值：\nint 消息id,当qos为1/2时有效, 若底层返回失败,会返回nil\n例子：\n-- 订阅单个topic, 且qos=0\nmqttc:subscribe(\"/luatos/123456\", 0)\n-- 订阅单个topic, 且qos=1\nmqttc:subscribe(\"/luatos/12345678\", 1)\n-- 订阅多个topic, 且使用不同的qos\nmqttc:subscribe({[\"/luatos/1234567\"]=1,[\"/luatos/12345678\"]=2})\n"
            },
            {
                "name": "mqttc:unsubscribe",
                "snippet": "mqttc:unsubscribe(${1:topic})",
                "description": "mqttc:unsubscribe(topic) - 取消订阅主题\n传入值：\nstring/table 主题\n例子：\nmqttc:unsubscribe(\"/luatos/123456\")\nmqttc:unsubscribe({\"/luatos/1234567\",\"/luatos/12345678\"})\n"
            },
            {
                "name": "mqttc:debug",
                "snippet": "mqttc:debug(${1:onoff})",
                "description": "mqttc:debug(onoff) - 配置是否打开debug信息\n传入值：\nboolean 是否打开debug开关\n返回值：\nnil 无返回值\n"
            },
            {
                "name": "mqtt.create",
                "snippet": "mqtt.create(${1:adapter},${2:host},${3:port},${4:ssl},${5:isipv6})",
                "description": "mqtt.create(adapter,host,port,ssl,isipv6) - mqtt客户端创建\n传入值：\nint 适配器序号, 只能是socket.ETH0, socket.STA, socket.AP,如果不填,会选择平台自带的方式,然后是最后一个注册的适配器\nstring 服务器地址,可以是域名, 也可以是ip\nint 端口号\nbool/table 是否为ssl加密连接,默认不加密,true为无证书最简单的加密，table为有证书的加密 <br>server_cert 服务器ca证书数据 <br>client_cert 客户端证书数据 <br>client_key 客户端私钥加密数据 <br>client_password 客户端私钥口令数据 <br>verify 是否强制校验 0不校验/1可选校验/2强制校验 默认2\nbool/table bool 是否为ipv6，默认不是  table mqtt扩展参数, ipv6 是否为ipv6, rxSize 接收缓冲区大小\n返回值：\nuserdata 若成功会返回mqtt客户端实例,否则返回nil\n例子：\n-- 普通TCP链接\nmqttc = mqtt.create(nil,\"120.55.137.106\", 1884)\n-- 普通TCP链接,mqtt接收缓冲区4096\nmqttc = mqtt.create(nil,\"120.55.137.106\", 1884, nil, {rxSize = 4096})\n-- 加密TCP链接,不验证服务器证书\nmqttc = mqtt.create(nil,\"120.55.137.106\", 8883, true)\n-- 加密TCPTCP链接,单服务器证书验证\nmqttc = mqtt.create(nil,\"120.55.137.106\", 8883, {server_cert=io.readFile(\"/luadb/ca.crt\")})\n-- 加密TCPTCP链接,单服务器证书验证, 但可选认证\nmqttc = mqtt.create(nil,\"120.55.137.106\", 8883, {server_cert=io.readFile(\"/luadb/ca.crt\"), verify=1})\n-- 加密TCPTCP链接,双向证书验证\nmqttc = mqtt.create(nil,\"120.55.137.106\", 8883, {\n                    server_cert=io.readFile(\"/luadb/ca.crt\"),\n                    client_cert=io.readFile(\"/luadb/client.pem\"),\n                    client_key=\"123456\",\n                    client_password=\"123456\",\n                    })\n"
            },
            {
                "name": "mqttc:auth",
                "snippet": "mqttc:auth(${1:client_id},${2:username},${3:password},${4:cleanSession})",
                "description": "mqttc:auth(client_id,username,password,cleanSession) - mqtt三元组配置及cleanSession\n传入值：\nstring 设备识别id,对于同一个mqtt服务器来说, 通常要求唯一,相同client_id会互相踢下线\nstring 账号 可选\nstring 密码 可选\nbool 清除session,默认true,可选\n返回值：\nnil 无返回值\n例子：\n-- 无账号密码登录,仅clientId\nmqttc:auth(\"123456789\")\n-- 带账号密码登录\nmqttc:auth(\"123456789\",\"username\",\"password\")\n-- 额外配置cleanSession,不清除\nmqttc:auth(\"123456789\",\"username\",\"password\", false)\n-- 无clientId模式, 服务器随机生成id, cleanSession不可配置\nmqttc:auth()\n"
            },
            {
                "name": "mqttc:keepalive",
                "snippet": "mqttc:keepalive(${1:time})",
                "description": "mqttc:keepalive(time) - mqtt心跳设置\n传入值：\nint 可选 单位s 默认240s. 最先15,最高600\n返回值：\nnil 无返回值\n例子：\nmqttc:keepalive(30)\n"
            },
            {
                "name": "mqttc:on",
                "snippet": "mqttc:on(${1:cb})",
                "description": "mqttc:on(cb) - 注册mqtt回调\n传入值：\nfunction cb mqtt回调,参数包括mqtt_client, event, data, payload\n返回值：\nnil 无返回值\n例子：\nmqttc:on(function(mqtt_client, event, data, payload, metas)\n    -- 用户自定义代码\n    log.info(\"mqtt\", \"event\", event, mqtt_client, data, payload)\nend)\n--[[\nevent可能出现的值有\n  conack -- 服务器鉴权完成,mqtt连接已经建立, 可以订阅和发布数据了,没有附加数据\n  recv   -- 接收到数据,由服务器下发, data为topic值(string), payload为业务数据(string).metas是元数据(table), 一般不处理. \n             -- metas包含以下内容\n             -- qos 取值范围0,1,2\n             -- retain 取值范围 0,1\n             -- dup 取值范围 0,1\n  sent   -- 发送完成, qos0会马上通知, qos1/qos2会在服务器应答会回调, data为消息id\n  disconnect -- 服务器断开连接,网络问题或服务器踢了客户端,例如clientId重复,超时未上报业务数据\n  pong   -- 收到服务器心跳应答,没有附加数据\n]]\n"
            },
            {
                "name": "mqttc:connect",
                "snippet": "mqttc:connect()",
                "description": "mqttc:connect() - 连接服务器\n返回值：\nboolean 发起成功返回true, 否则返回false\n例子：\n-- 开始建立连接\nmqttc:connect()\n-- 本函数仅代表发起成功, 后续仍需根据ready函数判断mqtt是否连接正常\n"
            },
            {
                "name": "mqttc:disconnect",
                "snippet": "mqttc:disconnect()",
                "description": "mqttc:disconnect() - 断开服务器连接(不会释放资源)\n返回值：\nboolean 发起成功返回true, 否则返回false\n例子：\n-- 断开连接\nmqttc:disconnect()\n"
            },
            {
                "name": "mqttc:autoreconn",
                "snippet": "mqttc:autoreconn(${1:reconnect},${2:reconnect_time})",
                "description": "mqttc:autoreconn(reconnect, reconnect_time) - 自动重连\n传入值：\nbool 是否自动重连\nint 自动重连周期 单位ms 默认3000ms\n例子：\nmqttc:autoreconn(true)\n"
            },
            {
                "name": "mqttc:publish",
                "snippet": "mqttc:publish(${1:topic},${2:data},${3:qos},${4:retain})",
                "description": "mqttc:publish(topic, data, qos, retain) - 发布消息\n传入值：\nstring 主题,必填\nstring 消息,必填,但长度可以是0\nint 消息级别 0/1 默认0\nint 是否存档, 0/1,默认0\n返回值：\nint 消息id, 当qos为1或2时会有效值. 若底层返回是否, 会返回nil\n例子：\nmqttc:publish(\"/luatos/123456\", \"123\")\n"
            },
            {
                "name": "mqttc:close",
                "snippet": "mqttc:close()",
                "description": "mqttc:close() - mqtt客户端关闭(关闭后资源释放无法再使用)\n例子：\nmqttc:close()\n"
            },
            {
                "name": "mqttc:ready",
                "snippet": "mqttc:ready()",
                "description": "mqttc:ready() - mqtt客户端是否就绪\n返回值：\nbool 客户端是否就绪\n例子：\nlocal error = mqttc:ready()\n"
            },
            {
                "name": "mqttc:state",
                "snippet": "mqttc:state()",
                "description": "mqttc:state() - mqtt客户端状态\n返回值：\nnumber 客户端状态\n例子：\nlocal state = mqttc:state()\n-- 已知状态:\n-- 0: MQTT_STATE_DISCONNECT\n-- 1: MQTT_STATE_CONNECTING\n-- 2: MQTT_STATE_CONNECTED\n-- 3: MQTT_STATE_READY\n-- 4: MQTT_STATE_ERROR\n"
            },
            {
                "name": "mqttc:will",
                "snippet": "mqttc:will(${1:topic},${2:payload},${3:qos},${4:retain})",
                "description": "mqttc:will(topic, payload, qos, retain) - 设置遗嘱消息\n传入值：\nstring 遗嘱消息的topic\nstring 遗嘱消息的payload\nstring 遗嘱消息的qos, 默认0, 可以不填\nstring 遗嘱消息的retain, 默认0, 可以不填\n返回值：\nbool 成功返回true,否则返回false\n例子：\n-- 要在connect之前调用\nmqttc:will(\"/xxx/xxx\", \"xxxxxx\")\n"
            },
            {
                "name": "napt.init",
                "snippet": "napt.init(${1:adapter})",
                "description": "napt.init(adapter) - 初始化NAPT\n传入值：\nint adapter 目标网卡索引, 默认是socket.LWIP_AP, 这里指内网\n返回值：\nnil 无返回值\n"
            },
            {
                "name": "napt.rebuild",
                "snippet": "napt.rebuild(${1:buff},${2:is_inet},${3:adapter})",
                "description": "napt.rebuild(buff, is_inet, adapter) - 重建MAC包\n传入值：\nuserdata 待处理的MAC包,必须是zbuff对象\nbool 来源是不是内网\nint 目标网络适配器的索引, 例如socket.LWIP_GP\n返回值：\nbool 成功返回true,失败返回false\n"
            },
            {
                "name": "napt.check",
                "snippet": "napt.check()",
                "description": "napt.check() - 检查和清理NAT表\n传入值：\nreturn nil\n例子：\n-- 两次check之间没有数据包的映射记录,会被清理\n"
            },
            {
                "name": "nes.init",
                "snippet": "nes.init(${1:file_path})",
                "description": "nes.init(file_path) - nes模拟器初始化\n传入值：\nstring file_path 文件路径\n返回值：\nbool 成功返回true,否则返回false\n例子：\nnes.init(\"/luadb/super_mario.nes\")\n"
            },
            {
                "name": "nes.key",
                "snippet": "nes.key(${1:key},${2:val})",
                "description": "nes.key(key,val) - nes模拟器初始化\n传入值：\nnumber key 按键\nnumber val 状态 1按下 0抬起\n返回值：\nbool 成功返回true,否则返回false\n例子：\nnes.init(\"/luadb/super_mario.nes\")\n"
            },
            {
                "name": "nimble.init",
                "snippet": "nimble.init(${1:name})",
                "description": "nimble.init(name) - 初始化BLE上下文,开始对外广播/扫描\n传入值：\nstring 蓝牙设备名称,可选,建议填写\n返回值：\nbool 成功与否\n例子：\n-- 参考 demo/nimble\n-- 本函数对所有模式都适用\n"
            },
            {
                "name": "nimble.deinit",
                "snippet": "nimble.deinit()",
                "description": "nimble.deinit() - 关闭BLE上下文\n返回值：\nbool 成功与否\n例子：\n-- 仅部分设备支持,当前可能都不支持\n-- 本函数对所有模式都适用\n"
            },
            {
                "name": "nimble.mode",
                "snippet": "nimble.mode(${1:tp})",
                "description": "nimble.mode(tp) - 设置模式\n传入值：\nint 模式, 默认server/peripheral, 可选 client/central模式 nimble.MODE_BLE_CLIENT\n返回值：\nbool 成功与否\n例子：\n-- 参考 demo/nimble\n-- 必须在nimble.init()之前调用\n-- nimble.mode(nimble.MODE_BLE_CLIENT) -- 简称从机模式,未完善\n"
            },
            {
                "name": "nimble.connok",
                "snippet": "nimble.connok()",
                "description": "nimble.connok() - 是否已经建立连接\n返回值：\nbool 已连接返回true,否则返回false\n例子：\nlog.info(\"ble\", \"connected?\", nimble.connok())\n-- 从机peripheral模式, 设备是否已经被连接\n-- 主机central模式, 是否已经连接到设备\n-- ibeacon模式, 无意义\n"
            },
            {
                "name": "nimble.send_msg",
                "snippet": "nimble.send_msg(${1:conn},${2:handle},${3:data})",
                "description": "nimble.send_msg(conn, handle, data) - 发送信息\n传入值：\nint 连接id, 当前固定填1\nint 处理id, 当前固定填0\nstring 数据字符串,可包含不可见字符\n返回值：\nbool 成功与否\n例子：\n-- 参考 demo/nimble\n-- 本函数对peripheral/从机模式适用\n"
            },
            {
                "name": "nimble.setUUID",
                "snippet": "nimble.setUUID(${1:tp},${2:addr})",
                "description": "nimble.setUUID(tp, addr) - 设置server/peripheral的UUID\n传入值：\nstring 配置字符串,后面的示例有说明\nstring 地址字符串\n返回值：\nbool 成功与否\n例子：\n-- 参考 demo/nimble, 2023-02-25之后编译的固件支持本API\n-- 必须在nimble.init()之前调用\n-- 本函数对peripheral/从机模式适用\n\n-- 设置SERVER/Peripheral模式下的UUID, 支持设置3个\n-- 地址支持 2/4/16字节, 需要二进制数据\n-- 2字节地址示例: AABB, 写 string.fromHex(\"AABB\") ,或者 string.char(0xAA, 0xBB)\n-- 4字节地址示例: AABBCCDD , 写 string.fromHex(\"AABBCCDD\") ,或者 string.char(0xAA, 0xBB, 0xCC, 0xDD)\nnimble.setUUID(\"srv\", string.fromHex(\"380D\"))      -- 服务主UUID         ,  默认值 180D\nnimble.setUUID(\"write\", string.fromHex(\"FF31\"))    -- 往本设备写数据的UUID,  默认值 FFF1\nnimble.setUUID(\"indicate\", string.fromHex(\"FF32\")) -- 订阅本设备的数据的UUID,默认值 FFF2\n"
            },
            {
                "name": "nimble.mac",
                "snippet": "nimble.mac(${1:mac})",
                "description": "nimble.mac(mac) - 获取蓝牙MAC\n传入值：\nstring 待设置的MAC地址, 6字节, 不传就是单获取\n返回值：\nstring 蓝牙MAC地址,6字节\n例子：\n-- 参考 demo/nimble, 2023-02-25之后编译的固件支持本API\n-- 本函数对所有模式都适用\nlocal mac = nimble.mac()\nlog.info(\"ble\", \"mac\", mac and mac:toHex() or \"Unknwn\")\n\n-- 修改MAC地址, 2024.06.05 新增, 当前仅Air601支持, 修改后重启生效\nnimble.mac(string.fromHex(\"1234567890AB\"))\n"
            },
            {
                "name": "nimble.sendNotify",
                "snippet": "nimble.sendNotify(${1:srv_uuid},${2:chr_uuid},${3:data})",
                "description": "nimble.sendNotify(srv_uuid, chr_uuid, data) - 发送notify\n传入值：\nstring 服务的UUID,预留,当前填nil就行\nstring 特征的UUID,必须填写\nstring 数据, 必填, 跟MTU大小相关, 一般不要超过256字节\n返回值：\nbool 成功返回true,否则返回false\n例子：\n-- 本API于 2023.07.31 新增\n-- 本函数对peripheral模式适用\nnimble.sendNotify(nil, string.fromHex(\"FF01\"), string.char(0x31, 0x32, 0x33, 0x34, 0x35))\n"
            },
            {
                "name": "nimble.sendIndicate",
                "snippet": "nimble.sendIndicate(${1:srv_uuid},${2:chr_uuid},${3:data})",
                "description": "nimble.sendIndicate(srv_uuid, chr_uuid, data) - 发送indicate\n传入值：\nstring 服务的UUID,预留,当前填nil就行\nstring 特征的UUID,必须填写\nstring 数据, 必填, 跟MTU大小相关, 一般不要超过256字节\n返回值：\nbool 成功返回true,否则返回false\n例子：\n-- 本API于 2023.07.31 新增\n-- 本函数对peripheral模式适用\nnimble.sendIndicate(nil, string.fromHex(\"FF01\"), string.char(0x31, 0x32, 0x33, 0x34, 0x35))\n"
            },
            {
                "name": "nimble.advParams",
                "snippet": "nimble.advParams(${1:conn_mode},${2:disc_mode},${3:itvl_min},${4:itvl_max},${5:channel_map},${6:filter_policy},${7:high_duty_cycle})",
                "description": "nimble.advParams(conn_mode, disc_mode, itvl_min, itvl_max, channel_map, filter_policy, high_duty_cycle) - 设置广播参数\n传入值：\nint 广播模式, 0 - 不可连接, 1 - 定向连接, 2 - 未定向连接, 默认0\nint 发现模式, 0 - 不可发现, 1 - 限制发现, 3 - 通用发现, 默认0\nint 最小广播间隔, 0 - 使用默认值, 范围 1 - 65535, 单位0.625ms, 默认0\nint 最大广播间隔, 0 - 使用默认值, 范围 1 - 65535, 单位0.625ms, 默认0\nint 广播通道, 默认0, 一般不需要设置\nint 过滤规则, 默认0, 一般不需要设置\nint 当广播模式为\"定向连接\"时,是否使用高占空比模式, 默认0, 可选1\n返回值：\nnil 无返回值\n例子：\n-- 当前仅ibeacon模式/peripheral/从机可使用\n-- 例如设置 不可连接 + 限制发现\n-- 需要在nimble.init之前设置好\nnimble.advParams(0, 1)\n-- 注意peripheral模式下自动配置 conn_mode 和 disc_mode\n"
            },
            {
                "name": "nimble.setChr",
                "snippet": "nimble.setChr(${1:index},${2:uuid},${3:flags})",
                "description": "nimble.setChr(index, uuid, flags) - 设置chr的特征\n传入值：\nint chr的索引, 默认0-3\nint chr的UUID, 可以是2/4/16字节\nint chr的FLAGS, 请查阅常量表\n返回值：\nnil 无返回值\n例子：\n-- 仅peripheral/从机可使用\nnimble.setChr(0, string.fromHex(\"FF01\"), nimble.CHR_F_WRITE_NO_RSP | nimble.CHR_F_NOTIFY)\nnimble.setChr(1, string.fromHex(\"FF02\"), nimble.CHR_F_READ | nimble.CHR_F_NOTIFY)\nnimble.setChr(2, string.fromHex(\"FF03\"), nimble.CHR_F_WRITE_NO_RSP)\n-- 可查阅 demo/nimble/kt6368a\n"
            },
            {
                "name": "nimble.config",
                "snippet": "nimble.config(${1:id},${2:value})",
                "description": "nimble.config(id, value) - 设置chr的特征\n传入值：\nint 配置的id,请查阅常量表\nany 根据配置的不同, 有不同的可选值\n返回值：\nnil 无返回值\n例子：\n-- 本函数在任意模式可用\n-- 本API于 2023.07.31 新增\n-- 例如设置地址转换的大小端, 默认是0, 兼容老的代码\n-- 设置成1, 服务UUID和chr的UUID更直观\nnimble.config(nimble.CFG_ADDR_ORDER, 1)\n"
            },
            {
                "name": "nimble.ibeacon",
                "snippet": "nimble.ibeacon(${1:data},${2:major},${3:minor},${4:measured_power})",
                "description": "nimble.ibeacon(data, major, minor, measured_power) - 配置iBeacon的参数,仅iBeacon模式可用\n传入值：\nstring 数据, 必须是16字节\nint 主版本号,默认2, 可选, 范围 0 ~ 65536\nint 次版本号,默认10,可选, 范围 0 ~ 65536\nint 名义功率, 默认0, 范围 -126 到 20 \n返回值：\nbool 成功返回true,否则返回false\n例子：\n-- 参考 demo/nimble, 2023-02-25之后编译的固件支持本API\n-- 本函数对ibeacon模式适用\nnimble.ibeacon(data, 2, 10, 0)\nnimble.init()\n"
            },
            {
                "name": "nimble.advData",
                "snippet": "nimble.advData(${1:data},${2:flags})",
                "description": "nimble.advData(data, flags) - 配置广播数据,仅iBeacon模式可用\n传入值：\nstring 广播数据, 当前最高128字节\nint 广播标识, 可选, 默认值是 0x06,即 不支持传统蓝牙(0x04) + 普通发现模式(0x02)\n返回值：\nbool 成功返回true,否则返回false\n例子：\n-- 参考 demo/nimble/adv_free, 2023-03-18之后编译的固件支持本API\n-- 本函数对ibeacon模式适用\n-- 数据来源可以多种多样\nlocal data = string.fromHex(\"123487651234876512348765123487651234876512348765\")\n-- local data = crypto.trng(25)\n-- local data = string.char(0x11, 0x13, 0xA3, 0x5A, 0x11, 0x13, 0xA3, 0x5A, 0x11, 0x13, 0xA3, 0x5A, 0x11, 0x13, 0xA3, 0x5A)\nnimble.advData(data)\nnimble.init()\n\n-- nimble支持在init之后的任意时刻再次调用, 以实现数据更新\n-- 例如 1分钟变一次\nwhile 1 do\n    sys.wait(60000)\n    local data = crypto.trng(25)\n    nimble.advData(data)\nend\n"
            },
            {
                "name": "nimble.scan",
                "snippet": "nimble.scan(${1:timeout})",
                "description": "nimble.scan(timeout) - 扫描从机\n传入值：\nint 超时时间,单位秒,默认28秒\n返回值：\nbool 启动扫描成功与否\n例子：\n-- 参考 demo/nimble/scan\n-- 本函数对central/主机模式适用\n-- 本函数会直接返回, 然后通过异步回调返回结果\n\n-- 调用本函数前, 需要先确保已经nimble.init()\nnimble.scan()\n-- timeout参数于 2023.7.11 添加\n"
            },
            {
                "name": "nimble.connect",
                "snippet": "nimble.connect(${1:mac})",
                "description": "nimble.connect(mac) - 连接到从机\n传入值：\nstring 设备的MAC地址\n返回值：\nbool 启动连接成功与否\n例子：\n-- 本函数对central/主机模式适用\n-- 本函数会直接返回, 然后通过异步回调返回结果\n"
            },
            {
                "name": "nimble.disconnect",
                "snippet": "nimble.disconnect()",
                "description": "nimble.disconnect() - 断开与从机的连接\n返回值：\nnil 无返回值\n例子：\n-- 本函数对central/主机模式适用\n-- 本函数会直接返回\n"
            },
            {
                "name": "nimble.discSvr",
                "snippet": "nimble.discSvr()",
                "description": "nimble.discSvr() - 扫描从机的服务列表\n返回值：\nnil 无返回值\n例子：\n-- 本函数对central/主机模式适用\n-- 本函数会直接返回,然后异步返回结果\n-- 这个API通常不需要调用, 在连接从机完成后,会主动调用一次\n"
            },
            {
                "name": "nimble.listSvr",
                "snippet": "nimble.listSvr()",
                "description": "nimble.listSvr() - 获取从机的服务列表\n返回值：\ntable 服务UUID的数组\n例子：\n-- 本函数对central/主机模式适用\n"
            },
            {
                "name": "nimble.discChr",
                "snippet": "nimble.discChr(${1:svr_uuid})",
                "description": "nimble.discChr(svr_uuid) - 扫描从机的指定服务的特征值\n传入值：\nstring 指定服务的UUID值\n返回值：\nboolean 成功启动扫描与否\n例子：\n-- 本函数对central/主机模式适用\n"
            },
            {
                "name": "nimble.listChr",
                "snippet": "nimble.listChr(${1:svr_uuid})",
                "description": "nimble.listChr(svr_uuid) - 获取从机的指定服务的特征值列表\n传入值：\nstring 指定服务的UUID值\n返回值：\ntable 特征值列表,包含UUID和flags\n例子：\n-- 本函数对central/主机模式适用\n"
            },
            {
                "name": "nimble.discDsc",
                "snippet": "nimble.discDsc(${1:svr_uuid},${2:chr_uuid})",
                "description": "nimble.discDsc(svr_uuid, chr_uuid) - 扫描从机的指定服务的特征值的其他属性\n传入值：\nstring 指定服务的UUID值\nstring 特征值的UUID值\n返回值：\nboolean 成功启动扫描与否\n例子：\n-- 本函数对central/主机模式适用\n"
            },
            {
                "name": "nimble.writeChr",
                "snippet": "nimble.writeChr(${1:svr_uuid},${2:chr_uuid},${3:data})",
                "description": "nimble.writeChr(svr_uuid, chr_uuid, data) - 往指定的服务的指定特征值写入数据\n传入值：\nstring 指定服务的UUID值\nstring 指定特征值的UUID值\nstring 待写入的数据\n返回值：\nboolean 成功启动写入与否\n例子：\n-- 本函数对central/主机模式适用\n"
            },
            {
                "name": "nimble.readChr",
                "snippet": "nimble.readChr(${1:svr_uuid},${2:chr_uuid})",
                "description": "nimble.readChr(svr_uuid, chr_uuid) - 从指定的服务的指定特征值读取数据(异步)\n传入值：\nstring 指定服务的UUID值\nstring 指定特征值的UUID值\n返回值：\nboolean 成功启动写入与否\n例子：\n-- 本函数对central/主机模式适用\n-- 详细用法请参数 demo/nimble/central\n"
            },
            {
                "name": "nimble.subChr",
                "snippet": "nimble.subChr(${1:svr_uuid},${2:chr_uuid})",
                "description": "nimble.subChr(svr_uuid, chr_uuid) - 订阅指定的服务的指定特征值\n传入值：\nstring 指定服务的UUID值\nstring 指定特征值的UUID值\n返回值：\nboolean 成功启动订阅与否\n例子：\n-- 本函数对central/主机模式适用\n-- 详细用法请参数 demo/nimble/central\n"
            },
            {
                "name": "nimble.unsubChr",
                "snippet": "nimble.unsubChr(${1:svr_uuid},${2:chr_uuid})",
                "description": "nimble.unsubChr(svr_uuid, chr_uuid) - 取消订阅指定的服务的指定特征值\n传入值：\nstring 指定服务的UUID值\nstring 指定特征值的UUID值\n返回值：\nboolean 成功启动取消订阅与否\n例子：\n-- 本函数对central/主机模式适用\n-- 详细用法请参数 demo/nimble/central\n"
            },
            {
                "name": "onewire.ds18b20",
                "snippet": "onewire.ds18b20(${1:mode},${2:pin},${3:check})",
                "description": "onewire.ds18b20(mode, pin, check) - 读取DS18B20\n传入值：\nint GPIO模式对应GPIO编号, HW模式根据实际硬件来确定\nboolean 是否检查数据的CRC值,可选\nint 模式, 只能是 onewire.GPIO 或者 onewire.HW,可选\n返回值：\nnumber 成功返回温度值,否则返回nil.单位 0.1摄氏度\n例子：\n\n-- GPIO模式,接 GPIO 9\nlocal temp = onewire.ds18b20(9, true, onewire.GPIO)\nif temp then\n    log.info(\"读取到的温度值\", temp)\nelse\n    log.info(\"读取失败\")\nend\n\n"
            },
            {
                "name": "onewire.dht1x",
                "snippet": "onewire.dht1x(${1:mode},${2:pin},${3:check})",
                "description": "onewire.dht1x(mode, pin, check) - 读取DHT11\n传入值：\nint GPIO模式对应GPIO编号, HW模式根据实际硬件来确定\nboolean 是否检查数据的CRC值,可选\nint 模式, 只能是 onewire.GPIO 或者 onewire.HW,可选\n返回值：\nnumber 成功返回温度值,否则返回nil.单位 0.01摄氏度\nnumber 成功返回相对湿度,否则返回nil.单位 0.01%\n例子：\n\n-- GPIO模式,接 GPIO 9\nlocal temp = onewire.dht1x(onewire.GPIO, 9, true)\nif temp then\n    log.info(\"读取到的温度值\", temp)\nelse\n    log.info(\"读取失败\")\nend\n\n"
            },
            {
                "name": "otp.read",
                "snippet": "otp.read(${1:zone},${2:offset},${3:len})",
                "description": "otp.read(zone, offset, len) - 读取指定OTP区域读取数据\n传入值：\nint 区域, 通常为0/1/2/3, 与具体硬件相关\nint 偏移量\nint 读取长度, 单位字节, 必须是4的倍数, 不能超过4096字节\n返回值：\nstring 成功返回字符串, 否则返回nil\n例子：\n\nlocal otpdata = otp.read(0, 0, 64)\nif otpdata then\n    log.info(\"otp\", otpdata:toHex())\nend\n"
            },
            {
                "name": "otp.write",
                "snippet": "otp.write(${1:zone},${2:data},${3:offset})",
                "description": "otp.write(zone, data, offset) - 往指定OTP区域写入数据\n传入值：\nint 区域, 通常为0/1/2/3, 与具体硬件相关\nstring 数据, 长度必须是4个倍数\nint 偏移量\n返回值：\nbooL 成功返回true,否则返回false\n"
            },
            {
                "name": "otp.erase",
                "snippet": "otp.erase(${1:zone})",
                "description": "otp.erase(zone) - 擦除指定OTP区域\n传入值：\nint 区域, 通常为0/1/2/3, 与具体硬件相关\n返回值：\nbool 成功返回true,否则返回false\n"
            },
            {
                "name": "otp.lock",
                "snippet": "otp.lock(${1:zone})",
                "description": "otp.lock(zone) - 锁定OTP区域. 特别注意!!一旦加锁即无法解锁,OTP变成只读!!!\n返回值：\nbool 成功返回true,否则返回false\n"
            },
            {
                "name": "pack.unpack",
                "snippet": "pack.unpack(${1:string},${2:format},${3:init})",
                "description": "pack.unpack( string, format, init) - 解包字符串\n传入值：\nstring 需解包的字符串\nstring 格式化符号\nint 默认值为1，标记解包开始的位置\n返回值：\nint 字符串标记的位置\nany 第一个解包的值, 根据format值,可能有N个返回值\n例子：\nlocal _,a = pack.unpack(x,\">h\") --解包成short (2字节)\n"
            },
            {
                "name": "pack.pack",
                "snippet": "pack.pack(${1:format},${2:val1},${3:val2},${4:val3},${5:valn})",
                "description": "pack.pack( format, val1, val2, val3, valn ) - 打包字符串的值\n传入值：\nstring format 格式化符号\nany 第一个需打包的值\nany 第二个需打包的值\nany 第二个需打包的值\nany 第n个需打包的值\n返回值：\nstring 一个包含所有格式化变量的字符串\n例子：\nlocal data = pack.pack('<h', crypto.crc16(\"MODBUS\", val))\nlog.info(\"data\", data, data:toHex())\n"
            },
            {
                "name": "pin.get",
                "snippet": "pin.get(${1:name})",
                "description": "pin.get(name) - 获取管脚对应的GPIO号, 可简写为  pin.PA01 , 推荐使用简写\n传入值：\nname 管脚的名称, 例如PA01, PB12\n返回值：\nint 对应的GPIO号,如果不存在则返回-1,并打印警告信息\n例子：\n-- 以下三个语句完全等价, 若提示pin这个库不存在,要么固件版本低,请升级底层固件, 要么就是不需要这个库\n-- PA12, GPIO12, 设置为输出, 而且低电平.\ngpio.setup(12, 0)\ngpio.setup(pin.PA12, 0) -- 推荐使用\ngpio.setup(pin.get(\"PA12\"), 0) -- 不推荐, 太长^_^\n"
            },
            {
                "name": "pm.request",
                "snippet": "pm.request(${1:mode})",
                "description": "pm.request(mode) - 请求进入指定的休眠模式\n传入值：\nint 休眠模式,例如pm.IDLE/LIGHT/DEEP/HIB.\n返回值：\nboolean 处理结果,即使返回成功,也不一定会进入, 也不会马上进入\n例子：\n-- 请求进入休眠模式\n--[[\nIDLE   正常运行,就是无休眠\nLIGHT  轻休眠, CPU停止, RAM保持, 外设保持, 可中断唤醒. 部分型号支持从休眠处继续运行\nDEEP   深休眠, CPU停止, RAM掉电, 仅特殊引脚保持的休眠前的电平, 大部分管脚不能唤醒设备.\nHIB    彻底休眠, CPU停止, RAM掉电, 仅复位/特殊唤醒管脚可唤醒设备.\n]]\n\npm.request(pm.HIB)\n"
            },
            {
                "name": "pm.dtimerStart",
                "snippet": "pm.dtimerStart(${1:id},${2:timeout})",
                "description": "pm.dtimerStart(id, timeout) - 启动底层定时器,在休眠模式下依然生效. 只触发一次，关机状态下无效\n传入值：\nint 定时器id,通常是0-5\nint 定时时长,单位毫秒\n返回值：\nboolean 处理结果\n例子：\n-- 添加底层定时器\npm.dtimerStart(0, 300 * 1000) -- 5分钟后唤醒\n-- 移芯CAT1平台系列(Air780E/Air700E/Air780EP等等)\n-- id = 0 或者 id = 1 是, 最大休眠时长是2.5小时\n-- id >= 2是, 最大休眠时长是740小时\n"
            },
            {
                "name": "pm.dtimerStop",
                "snippet": "pm.dtimerStop(${1:id})",
                "description": "pm.dtimerStop(id) - 关闭底层定时器\n传入值：\nint 定时器id\n例子：\n-- 关闭底层定时器\npm.dtimerStop(0) -- 关闭id=0的底层定时器\n"
            },
            {
                "name": "pm.dtimerCheck",
                "snippet": "pm.dtimerCheck(${1:id})",
                "description": "pm.dtimerCheck(id) - 检查底层定时器是不是在运行\n传入值：\nint 定时器id\n返回值：\nboolean 处理结果,true还在运行，false不在运行\nnumber 如果运行,运行剩余时间,单位毫秒(需bsp支持)\n例子：\n-- 检查底层定时器是不是在运行\npm.dtimerCheck(0) -- 检查id=0的底层定时器\n"
            },
            {
                "name": "dtimerWkId",
                "snippet": "dtimerWkId()",
                "description": "dtimerWkId() - 检查定时唤醒是哪一个定时器，如果不是定时唤醒的，返回-1\n返回值：\nint 处理结果 >=0 是本次定时唤醒的定时器ID，其他错误，说明不是定时唤醒的\n例子：\nlocal timer_id = pm.dtimerWkId()\n"
            },
            {
                "name": "pm.lastReson",
                "snippet": "pm.lastReson()",
                "description": "pm.lastReson() - 开机原因,用于判断是从休眠模块开机,还是电源/复位开机\n返回值：\nint 0-上电/复位开机, 1-RTC开机, 2-WakeupIn/Pad/IO开机, 3-未知原因(Wakeup/RTC皆有可能)开机,目前只有air101,air103会有这个返回值\nint 0-普通开机(上电/复位),3-深睡眠开机,4-休眠开机\nint 复位开机详细原因：0-powerkey或者上电开机 1-充电或者AT指令下载完成后开机 2-闹钟开机 3-软件重启 4-未知原因 5-RESET键 6-异常重启 7-工具控制重启 8-内部看门狗重启 9-外部重启 10-充电开机\n例子：\n-- 是哪种方式开机呢\nlog.info(\"pm\", \"last power reson\", pm.lastReson())\n"
            },
            {
                "name": "pm.force",
                "snippet": "pm.force(${1:mode})",
                "description": "pm.force(mode) - 强制进入指定的休眠模式，忽略某些外设的影响，比如USB\n传入值：\nint 休眠模式\n返回值：\nboolean 处理结果,若返回成功,大概率会马上进入该休眠模式\n例子：\n-- 请求进入休眠模式\npm.force(pm.HIB)\n-- 移芯CAT1平台系列(Air780E/Air700E/Air780EP等等), 该操作会关闭USB通信\n-- 唤醒后如需开启USB, 请打开USB电压\n--pm.power(pm.USB, true)\n"
            },
            {
                "name": "pm.check",
                "snippet": "pm.check()",
                "description": "pm.check() - 检查休眠状态\n返回值：\nboolean 处理结果,如果能顺利进入休眠,返回true,否则返回false\nint 底层返回值,0代表能进入最底层休眠,其他值代表最低可休眠级别\n例子：\n-- 请求进入休眠模式,然后检查是否能真的休眠\npm.request(pm.HIB)\nif pm.check() then\n    log.info(\"pm\", \"it is ok to hib\")\nelse\n    -- 移芯CAT1平台系列(Air780E/Air700E/Air780EP等等), 该操作会关闭USB通信\n    pm.force(pm.HIB) -- 强制休眠\n    -- 唤醒后如需开启USB, 请打开USB电压\n    --sys.wait(100)\n    --pm.power(pm.USB, true)\nend\n"
            },
            {
                "name": "pm.shutdown",
                "snippet": "pm.shutdown()",
                "description": "pm.shutdown() - 关机\n返回值：\nnil 无返回值\n例子：\n-- 当前支持移芯CAT1平台系列(Air780E/Air700E/Air780EP等等)\n-- 需要2022-12-22之后编译的固件\npm.shutdown()\n"
            },
            {
                "name": "pm.reboot",
                "snippet": "pm.reboot()",
                "description": "pm.reboot() - 重启\n返回值：\nnil 无返回值\n"
            },
            {
                "name": "pm.power",
                "snippet": "pm.power(${1:id},${2:onoff})",
                "description": "pm.power(id, onoff) - 开启内部的电源控制，注意不是所有的平台都支持，可能部分平台支持部分选项，看硬件\n传入值：\nint 电源控制id,pm.USB pm.GPS之类\nboolean or int 开关true/1开，false/0关，默认关，部分选项支持数值\n返回值：\nboolean 处理结果true成功，false失败\n例子：\n-- 关闭USB电源, 反之开启就是传true\npm.power(pm.USB, false) \n\n-- Air780EG,为内置的GPS芯片上电. 注意, Air780EG的GPS和GPS_ANT是一起控制的,所以合并了.\npm.power(pm.GPS, true)\n\n-- 移芯CAT1平台系列(Air780E/Air700E/Air780EP等等)开启pwrkey开机防抖\n-- 注意: 开启后, 复位键就变成关机了!!! pwrkey要长按2秒才能开机\n-- pm.power(pm.PWK_MODE, true)\n\n-- 移芯CAT1平台系列(Air780E/Air700E/Air780EP等等)PSM+低功耗设置\n-- 移芯CAT1平台系列(Air780E/Air700E/Air780EP等等)节能模式，0~3，0完全关闭，1性能优先，2平衡，3极致功耗\n-- 详情访问: https://airpsm.cn\n-- pm.power(pm.WORK_MODE, 1)\n"
            },
            {
                "name": "pm.ioVol",
                "snippet": "pm.ioVol(${1:id},${2:val})",
                "description": "pm.ioVol(id, val) - IO高电平电压控制\n传入值：\nint 电平id,目前只有pm.IOVOL_ALL_GPIO\nint 电平值,单位毫伏\n返回值：\nboolean 处理结果true成功，false失败\n例子：\n-- 移芯CAT1平台系列(Air780E/Air700E/Air780EP等等)设置IO电平, 范围 1650 ~ 2000，2650~3400 , 单位毫伏, 步进50mv\n-- 注意, 这里的设置优先级会高于硬件IOSEL脚的配置\n-- 但开机时依然先使用硬件配置,直至调用本API进行配置, 所以io电平会变化\n-- pm.ioVol(pm.IOVOL_ALL_GPIO, 3300)    -- 所有GPIO高电平输出3.3V\n-- pm.ioVol(pm.IOVOL_ALL_GPIO, 1800)    -- 所有GPIO高电平输出1.8V\n"
            },
            {
                "name": "pm.wakeupPin",
                "snippet": "pm.wakeupPin(${1:pin},${2:level})",
                "description": "pm.wakeupPin(pin,level) - 配置唤醒引脚 (当前仅仅esp系列可用)\n传入值：\nint/table gpio引脚\nint 唤醒电压 可选,默认低电平唤醒\n返回值：\nboolean 处理结果\n例子：\npm.wakeupPin(8,0)\n"
            },
            {
                "name": "protobuf.load",
                "snippet": "protobuf.load(${1:pbdata})",
                "description": "protobuf.load(pbdata) - 加载pb二进制定义数据\n传入值：\nstring 通过protoc.exe程序转换得到的数据,通常从文件读取得到\n返回值：\nbool 成功与否\nint 读取了多长, 调试用\n例子：\n-- 注意, 同一个文件只需要加载一次, 除非调用过protobuf.clear()\nprotobuf.load(io.readFile(\"/luadb/person.pb\"))\n"
            },
            {
                "name": "protobuf.clear",
                "snippet": "protobuf.clear()",
                "description": "protobuf.clear() - 清除已加载的二进制定义数据\n返回值：\nnil 无返回值, 总是成功\n例子：\n-- 清除所有已加载的定义数据\nprotobuf.clear()\n"
            },
            {
                "name": "protobuf.encode",
                "snippet": "protobuf.encode(${1:tpname},${2:data})",
                "description": "protobuf.encode(tpname, data) - 编码protobuffs数据包\n传入值：\nstring 数据类型名称, 定义在pb文件中, 由protobuf.load加载\ntable 待编码数据, 必须是table, 内容符合pb文件里的定义\n返回值：\nstring 编码后的数据,若失败会返回nil\n例子：\n-- 数据编码\nlocal tb = {\n    name = \"wendal\"\n}\nlocal pbdata = protobuf.encode(\"Person\", tb)\nif pbdata then\n    -- 注意, 编码后的数据通常带不可见字符\n    log.info(\"protobuf\", #pbdata, pbdata:toHex())\nend\n"
            },
            {
                "name": "protobuf.decode",
                "snippet": "protobuf.decode(${1:tpname},${2:data})",
                "description": "protobuf.decode(tpname, data) - 解码protobuffs数据包\n传入值：\nstring 数据类型名称, 定义在pb文件中, 由protobuf.load加载\nstring 待编码数据\n返回值：\ntable 解码后的数据\n例子：\n-- 数据编码\nlocal tb = {\n    name = \"wendal\"\n}\nlocal pbdata = protobuf.encode(\"Person\", tb)\nif pbdata then\n    -- 注意, 编码后的数据通常带不可见字符\n    log.info(\"protobuf\", #pbdata, pbdata:toHex())\nend\n"
            },
            {
                "name": "pwm.open",
                "snippet": "pwm.open(${1:channel},${2:period},${3:pulse},${4:pnum},${5:precision})",
                "description": "pwm.open(channel, period, pulse, pnum, precision) - 开启指定的PWM通道\n传入值：\nint PWM通道\nint 频率, 1-1000000hz\nint 占空比 0-分频精度\nint 输出周期 0为持续输出, 1为单次输出, 其他为指定脉冲数输出\nint 分频精度, 100/256/1000, 默认为100, 若设备不支持会有日志提示\n返回值：\nboolean 处理结果,成功返回true,失败返回false\n例子：\n-- 打开PWM5, 频率1kHz, 占空比50%\npwm.open(5, 1000, 50)\n-- 打开PWM5, 频率10kHz, 分频为 31/256\npwm.open(5, 10000, 31, 0, 256)\n"
            },
            {
                "name": "pwm.close",
                "snippet": "pwm.close(${1:channel})",
                "description": "pwm.close(channel) - 关闭指定的PWM通道\n传入值：\nint PWM通道\n返回值：\nnil 无处理结果\n例子：\n-- 关闭PWM5\npwm.close(5)\n"
            },
            {
                "name": "pwm.capture",
                "snippet": "pwm.capture(${1:channel})",
                "description": "pwm.capture(channel) - PWM捕获\n传入值：\nint PWM通道\nint 捕获频率\n返回值：\nboolean 处理结果,成功返回true,失败返回false\n例子：\n-- PWM0捕获\nwhile 1 do\n    pwm.capture(0,1000)\n    local ret,channel,pulse,pwmH,pwmL  = sys.waitUntil(\"PWM_CAPTURE\", 2000)\n    if ret then\n        log.info(\"PWM_CAPTURE\",\"channel\"..channel,\"pulse\"..pulse,\"pwmH\"..pwmH,\"pwmL\"..pwmL)\n    end\nend\n"
            },
            {
                "name": "repl.enable",
                "snippet": "repl.enable(${1:re})",
                "description": "repl.enable(re) - 启用或禁用REPL功能\n传入值：\nbool 启用与否,默认是启用\nreturn 之前的设置状态\n例子：\n-- 若固件支持REPL,即编译时启用了REPL,是默认启用REPL功能的\n-- 本函数是提供关闭REPL的途径\nrepl.enable(false)\n"
            },
            {
                "name": "repl.push",
                "snippet": "repl.push(${1:data})",
                "description": "repl.push(data) - 主动推送待处理的数据到底层\n传入值：\nstring 待处理的数据,通常从串口来\n返回值：\nnil 无返回值\n例子：\n-- 虚拟串口的设备才需要这个函数\n"
            },
            {
                "name": "rsa.encrypt",
                "snippet": "rsa.encrypt(${1:key},${2:data})",
                "description": "rsa.encrypt(key, data) - RSA加密\n传入值：\nstring 公钥数据,仅支持PEM格式\nstring 待加密数据, 不能超过公钥位数的一半, 例如 2048bit的公钥, 只能加密128字节的数据\n返回值：\nstring 加密成功后的数据,若失败会返回nil\n例子：\n-- 下面代码中的 \"abc\" 是待加密数据\nlocal res = rsa.encrypt((io.readFile(\"/luadb/public.pem\")), \"abc\")\n-- 打印结果\nlog.info(\"rsa\", \"encrypt\", res and #res or 0, res and res:toHex() or \"\")\n"
            },
            {
                "name": "rsa.decrypt",
                "snippet": "rsa.decrypt(${1:key},${2:data},${3:pwd})",
                "description": "rsa.decrypt(key, data, pwd) - RSA解密\n传入值：\nstring 私钥数据,仅支持PEM格式\nstring 待解密数据\nstring 私钥的密码,可选\n返回值：\nstring 解密成功后的数据,若失败会返回nil\n例子：\n-- 注意, 解密通常很慢, 建议在服务器端进行\n-- res 是待解密的数据\nlocal dst = rsa.decrypt((io.readFile(\"/luadb/privkey.pem\")), res, \"\")\nlog.info(\"rsa\", \"decrypt\", dst and #dst or 0, dst and dst:toHex() or \"\")\n"
            },
            {
                "name": "rsa.verify",
                "snippet": "rsa.verify(${1:key},${2:md},${3:hash},${4:sig})",
                "description": "rsa.verify(key, md, hash, sig) - RSA验签\n传入值：\nstring 公钥数据,仅支持PEM格式\nint 签名模式, 例如 rsa.MD_SHA1 , rsa.MD_SHA256\nstring hash数据, 如果是HEX字符串,记得fromHex转二进制数据\nstring sig数据, 如果是HEX字符串,记得fromHex转二进制数据\n返回值：\nbool 有效返回true,否则为false,出错返回nil\n例子：\nlocal ret = rsa.verify((io.readFile(\"/luadb/public.pem\")), rsa.MD_SHA1, hash, sig)\nlog.info(\"rsa\", \"verify\", ret)\n"
            },
            {
                "name": "rsa.sign",
                "snippet": "rsa.sign(${1:key},${2:md},${3:hash},${4:pwd})",
                "description": "rsa.sign(key, md, hash, pwd) - RSA签名\n传入值：\nstring 私钥数据,仅支持PEM格式\nint 签名模式, 例如 rsa.MD_SHA1 , rsa.MD_SHA256\nstring hash数据, 如果是HEX字符串,记得fromHex转二进制数据\nstring 私钥密码, 可选\n返回值：\nstring 成功返回sig数据, 否则返回nil\n例子：\nlocal sig = rsa.sign((io.readFile(\"/luadb/privkey.pem\")), rsa.MD_SHA1, hash, \"\")\nlog.info(\"rsa\", \"sign\", sig and #sig or 0, sig and sig:toHex() or \"\")\n"
            },
            {
                "name": "rtc.set",
                "snippet": "rtc.set(${1:tab})",
                "description": "rtc.set(tab) - 设置时钟\n传入值：\ntable or int 时钟参数,见示例\n返回值：\nbool 成功返回true,否则返回nil或false\n例子：\nrtc.set({year=2021,mon=8,day=31,hour=17,min=8,sec=43})\nrtc.set(1652230554)\n"
            },
            {
                "name": "rtc.get",
                "snippet": "rtc.get()",
                "description": "rtc.get() - 获取时钟\n返回值：\ntable 时钟参数,见示例\n例子：\nlocal t = rtc.get()\n-- {year=2021,mon=8,day=31,hour=17,min=8,sec=43}\nlog.info(\"rtc\", json.encode(t))\n"
            },
            {
                "name": "rtc.timerStart",
                "snippet": "rtc.timerStart(${1:id},${2:tab})",
                "description": "rtc.timerStart(id, tab) - 设置RTC唤醒时间\n传入值：\nint 时钟id,通常只支持0\ntable 时钟参数,见示例\n返回值：\nbool 成功返回true,否则返回nil或false\n例子：\n-- 目前该接口不适用于移芯模块780E/700E/780EP系列，需要定时唤醒可使用pm.dtimerStart()\n-- 使用前建议先rtc.set设置为正确的时间\nrtc.timerStart(0, {year=2021,mon=9,day=1,hour=17,min=8,sec=43})\n"
            },
            {
                "name": "rtc.timerStop",
                "snippet": "rtc.timerStop(${1:id})",
                "description": "rtc.timerStop(id) - 取消RTC唤醒时间\n传入值：\nint 时钟id,通常只支持0\n返回值：\nbool 成功返回true,否则返回nil或false\n例子：\nrtc.timerStop(0)\n"
            },
            {
                "name": "rtc.setBaseYear",
                "snippet": "rtc.setBaseYear(${1:Base_year})",
                "description": "rtc.setBaseYear(Base_year) - 设置RTC基准年,不推荐\n传入值：\nint 基准年Base_year,通常1900\n例子：\nrtc.setBaseYear(1900)\n"
            },
            {
                "name": "rtc.timezone",
                "snippet": "rtc.timezone(${1:tz})",
                "description": "rtc.timezone(tz) - 读取或设置时区\n传入值：\nint 时区值,注意单位是1/4时区.例如东八区是 32,而非8. 可以不传\nreturn 当前/设置后的时区值\n例子：\n-- 设置为东8区\nrtc.timezone(32)\n-- 设置为东3区\nrtc.timezone(12)\n-- 设置为西4区\nrtc.timezone(-16)\n-- 注意: 无论设置时区是多少, rtc.get/set总是UTC时间\n-- 时区影响的是 os.date/os.time 函数\n-- 只有部分模块支持设置时区, 且默认值一般为32, 即东八区\n"
            },
            {
                "name": "rtos.receive",
                "snippet": "rtos.receive(${1:timeout})",
                "description": "rtos.receive(timeout)    - 接受并处理底层消息队列.\n传入值：\nint 超时时长,通常是-1,永久等待\n返回值：\nmsgid 如果是定时器消息,会返回定时器消息id及附加信息, 其他消息由底层决定,不向lua层进行任何保证.\n"
            },
            {
                "name": "rtos.timer_start",
                "snippet": "rtos.timer_start(${1:id},${2:timeout},${3:_repeat})",
                "description": "rtos.timer_start(id,timeout,_repeat)    - 启动一个定时器\n传入值：\nint 定时器id\nint 超时时长,单位毫秒\nint 重复次数,默认是0\n返回值：\nid 如果是定时器消息,会返回定时器消息id及附加信息, 其他消息由底层决定,不向lua层进行任何保证.\n例子：\n-- 用户代码请使用 sys.timerStart\n-- 启动一个3秒的循环定时器\nrtos.timer_start(10000, 3000, -1)\n"
            },
            {
                "name": "rtos.timer_stop",
                "snippet": "rtos.timer_stop(${1:id})",
                "description": "rtos.timer_stop(id)    - 关闭并释放一个定时器\n传入值：\nint 定时器id\n返回值：\nnil 无返回值\n例子：\n-- 用户代码请使用sys.timerStop\nrtos.timer_stop(id)\n"
            },
            {
                "name": "rtos.reboot",
                "snippet": "rtos.reboot()",
                "description": "rtos.reboot()    - 设备重启\n返回值：\nnil 无返回值\n"
            },
            {
                "name": "rtos.buildDate",
                "snippet": "rtos.buildDate()",
                "description": "rtos.buildDate() - 获取固件编译日期\n返回值：\nstring 固件编译日期\n例子：\n-- 获取编译日期\nlocal d = rtos.buildDate()\n"
            },
            {
                "name": "rtos.bsp",
                "snippet": "rtos.bsp()",
                "description": "rtos.bsp() - 获取硬件bsp型号\n返回值：\nstring 硬件bsp型号\n例子：\n-- 获取硬件bsp型号\nlocal bsp = rtos.bsp()\n"
            },
            {
                "name": "rtos.version",
                "snippet": "rtos.version()",
                "description": "rtos.version()         - 获取固件版本号\n返回值：\nstring 固件版本号,例如\"V0001\"\n例子：\n-- 读取版本号\nlocal luatos_version = rtos.version()\n"
            },
            {
                "name": "rtos.standy",
                "snippet": "rtos.standy(${1:timeout})",
                "description": "rtos.standy(timeout) - 进入待机模式, 仅部分设备可用, 本API已废弃, 推荐使用pm库\n传入值：\nint 休眠时长,单位毫秒\n返回值：\nnil 无返回值\n例子：\n-- 进入待机模式\nrtos.standby(5000)\n"
            },
            {
                "name": "rtos.meminfo",
                "snippet": "rtos.meminfo(${1:type})",
                "description": "rtos.meminfo(type) - 获取内存信息\n传入值：\ntype \"sys\"系统内存, \"lua\"虚拟机内存,\"psram\"psram内存, 默认为lua虚拟机内存\n返回值：\nint 总内存大小,单位字节\nint 当前已使用的内存大小,单位字节\nint 历史最高已使用的内存大小,单位字节\n例子：\n-- 打印内存占用\nlog.info(\"mem.lua\", rtos.meminfo())\nlog.info(\"mem.sys\", rtos.meminfo(\"sys\"))\n"
            },
            {
                "name": "rtos.firmware",
                "snippet": "rtos.firmware()",
                "description": "rtos.firmware() - 返回底层描述信息,格式为 LuatOS_$VERSION_$BSP,可用于OTA升级判断底层信息\n返回值：\nstring 底层描述信息\n例子：\n-- 打印底层描述信息\nlog.info(\"firmware\", rtos.firmware())\n"
            },
            {
                "name": "rtos.setPaths",
                "snippet": "rtos.setPaths(${1:pathA},${2:pathB},${3:pathC},${4:pathD})",
                "description": "rtos.setPaths(pathA, pathB, pathC, pathD) - 设置自定义lua脚本搜索路径,优先级高于内置路径\n传入值：\nstring 路径A, 例如 \"/sdcard/%s.luac\",若不传值,将默认为\"\",另外,最大长度不能超过23字节\nstring 路径B, 例如 \"/sdcard/%s.lua\"\nstring 路径C, 例如 \"/lfs2/%s.luac\"\nstring 路径D, 例如 \"/lfs2/%s.lua\"\n例子：\n-- 挂载sd卡或者spiflash后\nrtos.setPaths(\"/sdcard/user/%s.luac\", \"/sdcard/user/%s.lua\")\nrequire(\"sd_user_main\") -- 将搜索并加载 /sdcard/user/sd_user_main.luac 和 /sdcard/user/sd_user_main.lua\n"
            },
            {
                "name": "rtos.nop",
                "snippet": "rtos.nop()",
                "description": "rtos.nop() - 空函数,什么都不做\n返回值：\nnil 无返回值\n例子：\n-- 这个函数单纯就是 lua -> c -> lua 走一遍\n-- 没有参数,没有返回值,没有逻辑处理\n-- 在绝大多数情况下,不会遇到这个函数的调用\n-- 它通常只会出现在性能测试的代码里, 因为它什么都不干.\nrtos.nop()\n"
            },
            {
                "name": "rtos.autoCollectMem",
                "snippet": "rtos.autoCollectMem(${1:period},${2:warning_level},${3:force_level})",
                "description": "rtos.autoCollectMem(period, warning_level, force_level) - 内存自动收集配置，是lua本身收集机制的一种补充，不是必要的，而且只在luavm空闲时触发\n传入值：\nint 自动收集的周期，等同于receive调用次数，0~60000。如果是0，则关闭自动收集功能，默认是100\nint 内存使用警戒水位线，是总luavm内存量的百分比，50~95，内存达到(>=)警戒线时才会开始判断是否要收集。默认是80\nint 内存使用强制收集水位线，是总luavm内存量的百分比，50~95，内存达到(>=)强制收集线时会强制收集。默认是90，必须比警戒水位线大\n返回值：\nnil 无返回值\n例子：\nrtos.autoCollectMem(100, 80, 90)\n"
            },
            {
                "name": "sdio.init",
                "snippet": "sdio.init(${1:id})",
                "description": "sdio.init(id) - 初始化sdio\n传入值：\nint 通道id,与具体设备有关,通常从0开始,默认0\n返回值：\nboolean 打开结果\n"
            },
            {
                "name": "sdio.sd_read",
                "snippet": "sdio.sd_read(${1:id},${2:offset},${3:len})",
                "description": "sdio.sd_read(id, offset, len) - 直接读写sd卡上的数据\n传入值：\nint sdio总线id\nint 偏移量,必须是512的倍数\nint 长度,必须是512的倍数\n返回值：\nstring 若读取成功,返回字符串,否则返回nil\n例子：\n-- 初始化sdio并直接读取sd卡数据\nsdio.init(0)\nlocal t = sdio.sd_read(0, 0, 1024)\nif t then\n    --- xxx\nend\n"
            },
            {
                "name": "sdio.sd_write",
                "snippet": "sdio.sd_write(${1:id},${2:data},${3:offset})",
                "description": "sdio.sd_write(id, data, offset) - 直接写sd卡\n传入值：\nint sdio总线id\nstring 待写入的数据,长度必须是512的倍数\nint 偏移量,必须是512的倍数\n返回值：\nbool 若读取成功,返回true,否则返回false\n例子：\n-- 初始化sdio并直接读取sd卡数据\nsdio.init(0)\nlocal t = sdio.sd_write(0, data, 0)\nif t then\n    --- xxx\nend\n"
            },
            {
                "name": "sensor.ds18b20",
                "snippet": "sensor.ds18b20(${1:pin},${2:check_crc})",
                "description": "sensor.ds18b20(pin, check_crc) - 获取DS18B20的温度数据\n传入值：\nint gpio端口号\nboolean 是否校验crc值,默认为true. 不校验crc值能提高读取成功的概率,但可能会读取到错误的值\n返回值：\nint 温度数据,单位0.1摄氏度，读取失败时返回错误码\nboolean 成功返回true,否则返回false\n例子：\nwhile 1 do\n    sys.wait(5000)\n    local val,result = sensor.ds18b20(17, true) -- GPIO17且校验CRC值\n    -- val 301 == 30.1摄氏度\n    -- result true 读取成功\n    log.info(\"ds18b20\", val, result)\nend\n"
            },
            {
                "name": "sensor.w1_reset",
                "snippet": "sensor.w1_reset(${1:pin})",
                "description": "sensor.w1_reset(pin) - 单总线协议,复位设备\n传入值：\nint gpio端口号\n返回值：\nnil 无返回\n"
            },
            {
                "name": "sensor.w1_connect",
                "snippet": "sensor.w1_connect(${1:pin})",
                "description": "sensor.w1_connect(pin) - 单总线协议,连接设备\n传入值：\nint gpio端口号\n返回值：\nboolean 成功返回true,失败返回false\n"
            },
            {
                "name": "sensor.w1_write",
                "snippet": "sensor.w1_write(${1:pin},${2:data1},${3:data2})",
                "description": "sensor.w1_write(pin, data1,data2) - 单总线协议,往总线写入数据\n传入值：\nint gpio端口号\nint 第一个数据\nint 第二个数据, 可以写N个数据\n返回值：\nnil 无返回值\n"
            },
            {
                "name": "sensor.w1_read",
                "snippet": "sensor.w1_read(${1:pin},${2:len})",
                "description": "sensor.w1_read(pin, len) - 单总线协议,从总线读取数据\n传入值：\nint gpio端口号\nint 读取的长度\n返回值：\nint 按读取的长度返回N个整数\n"
            },
            {
                "name": "sensor.hx711",
                "snippet": "sensor.hx711(${1:pin_date},${2:pin_clk})",
                "description": "sensor.hx711(pin_date,pin_clk) - 获取Hx711的压力传感数据\n传入值：\nint 数据的gpio端口号\nint 时钟的gpio端口号\n返回值：\nint hx711读到的数据\n例子：\n--  如果设备不存在会卡在读取接口\nsys.taskInit(\n    function()\n        sys.wait(1000)\n        local maopi = sensor.hx711(0,7)\n        while true do\n            sys.wait(2000)\n            a = sensor.hx711(0,7) - maopi\n            if a > 0 then\n                log.info(\"tag\", a / 4.6)\n            end\n        end\n    end\n)\n"
            },
            {
                "name": "sensor.cs1237",
                "snippet": "sensor.cs1237(${1:pin_date},${2:pin_clk})",
                "description": "sensor.cs1237(pin_date,pin_clk) - 获取cs1237传感数据\n传入值：\nint 数据的gpio端口号\nint 时钟的gpio端口号\n返回值：\nint cs1237读到的数据\n例子：\n--  如果设备不存在会卡在读取接口\nsys.taskInit(\n    function()\n        sys.wait(1000)\n        local cs1237_data = sensor.cs1237(0,7)\n        while true do\n            sys.wait(2000)\n            cs1237_data = sensor.cs1237(0,7) - maopi\n            log.info(\"cs1237_data:\", cs1237_data)--得到原始数据\n        end\n    end\n)\n"
            },
            {
                "name": "sensor.ws2812b",
                "snippet": "sensor.ws2812b(${1:pin},${2:data},${3:T0H},${4:T0L},${5:T1H},${6:T1L})",
                "description": "sensor.ws2812b(pin,data,T0H,T0L,T1H,T1L) - 设置ws2812b输出(gpio驱动方式)\n传入值：\nint ws2812b的gpio端口号\nstring/zbuff 待发送的数据（如果为zbuff数据，则会无视指针位置始终从0偏移开始）\nint T0H时间，表示延时多少个nop，每个型号不一样，自己调\nint T0L时间，表示延时多少个nop\nint T1H时间，表示延时多少个nop\nint T1L时间，表示延时多少个nop\n例子：\nlocal buff = zbuff.create({8,8,24})\nbuff:drawLine(1,2,5,6,0x00ffff)\nsensor.ws2812b(7,buff,300,700,700,700)\n"
            },
            {
                "name": "sensor.ws2812b_pwm",
                "snippet": "sensor.ws2812b_pwm(${1:pin},${2:data})",
                "description": "sensor.ws2812b_pwm(pin,data) - 设置ws2812b输出(pwm驱动方式,需要pwm能输出800k频率，否则无法使用此方法)\n传入值：\nint pwm端口号\nstring/zbuff 待发送的数据（如果为zbuff数据，则会无视指针位置始终从0偏移开始）\n例子：\nlocal buff = zbuff.create({8,8,24})\nbuff:setFrameBuffer(8,8,24,0x0000ff)\nsensor.ws2812b_pwm(7,buff)\n"
            },
            {
                "name": "sensor.ws2812b_spi",
                "snippet": "sensor.ws2812b_spi(${1:pin},${2:data})",
                "description": "sensor.ws2812b_spi(pin,data) - 设置ws2812b输出(spi驱动方式,需要spi能输出5M频率，否则无法使用此方法)\n传入值：\nint spi端口号\nstring/zbuff 待发送的数据（如果为zbuff数据，则会无视指针位置始终从0偏移开始）\n例子：\nlocal buff = zbuff.create({8,8,24})\nbuff:setFrameBuffer(8,8,24,0x0000ff)\nsensor.ws2812b_spi(2,buff)\n"
            },
            {
                "name": "sensor.dht1x",
                "snippet": "sensor.dht1x(${1:pin})",
                "description": "sensor.dht1x(pin) - 获取DHT11/DHT12的温湿度数据\n传入值：\nint gpio端口号\nboolean 是否校验crc值,默认为true. 不校验crc值能提高读取成功的概率,但可能会读取到错误的值\n返回值：\nint 湿度数据,单位0.01%，读取失败时返回错误值\nint 温度数据,单位0.01摄氏度，读取失败时返回错误值\nboolean 成功返回true,否则返回false\n例子：\nwhile 1 do\n    sys.wait(1000)\n    local h,t,r = sensor.dht1x(17, true) -- GPIO17且校验CRC值\n    log.info(\"dht11\", h/100,t/100,r)--90.1 23.22\nend\n"
            },
            {
                "name": "sensor.sc12a",
                "snippet": "sensor.sc12a(${1:sda},${2:scl})",
                "description": "sensor.sc12a(sda,scl) - 获取sc12a被触摸的通道数据\n传入值：\nint 数据的gpio端口号\nint 时钟的gpio端口号\n返回值：\nint 读取成功返回整形数据，读取失败时返回错误值\n例子：\nwhile true do\n  local temp1=sensor.sc12a(4,7)\n  if bit.rshift(bit.band( temp1, 0x8000), 15 )==0x01 then\n    log.info(\"被按下的有通道0\")\n  end\n  if bit.rshift(bit.band( temp1, 0x4000), 14 )==0x01 then\n    log.info(\"被按下的有通道1\")\n  end\n  if bit.rshift(bit.band( temp1, 0x2000), 13 )==0x01 then\n    log.info(\"被按下的有通道2\")\n  end\n  if bit.rshift(bit.band( temp1, 0x1000), 12 )==0x01 then\n    log.info(\"被按下的有通道3\")\n  end\n  if bit.rshift(bit.band( temp1, 0x800), 11 )==0x01 then\n    log.info(\"被按下的有通道4\")\n  end\n  if bit.rshift(bit.band( temp1, 0x400), 10 )==0x01 then\n    log.info(\"被按下的有通道5\")\n  end\n  if bit.rshift(bit.band( temp1, 0x200), 9 )==0x01 then\n    log.info(\"被按下的有通道6\")\n  end\n  if bit.rshift(bit.band( temp1, 0x100), 8 )==0x01 then\n    log.info(\"被按下的有通道7\")\n  end\n  if bit.rshift(bit.band( temp1, 0x80), 7 )==0x01 then\n    log.info(\"被按下的有通道8\")\n  end\n  if bit.rshift(bit.band( temp1, 0x40), 6 )==0x01 then\n    log.info(\"被按下的有通道9\")\n  end\n  if bit.rshift(bit.band( temp1, 0x20), 5 )==0x01 then\n    log.info(\"被按下的有通道10\")\n  end\n  if bit.rshift(bit.band( temp1, 0x10), 4 )==0x01 then\n    log.info(\"被按下的有通道11\")\n  end\n  sys.wait(200)\nend\n"
            },
            {
                "name": "sensor.yhm27xxx",
                "snippet": "sensor.yhm27xxx(${1:pin},${2:chip_id},${3:reg},${4:data})",
                "description": "sensor.yhm27xxx(pin, chip_id, reg, data) - 单总线命令读写YHM27XX\n传入值：\nint gpio端口号\nint 芯片ID\nint 寄存器地址\nint 要写入的数据，如果没填，则表示从寄存器读取数据\n返回值：\nboolean 成功返回true,失败返回false\nint 读取成功返回寄存器值，写入成功无返回\n例子：\nwhile 1 do\n    sys.wait(1000)\n    local result, data = sensor.yhm27xxx(15, 0x04, 0x05)\n    log.info(\"yhm27xxx\", result, data)\nend\n"
            },
            {
                "name": "sfd.init",
                "snippet": "sfd.init(${1:type},${2:spi_id},${3:spi_cs})",
                "description": "sfd.init(type, spi_id, spi_cs) - 初始化spi flash\n传入值：\nstring 类型, 可以是\"spi\", 也可以是\"zbuff\", 或者\"onchip\"\nint SPI总线的id, 或者 zbuff实例\nint SPI FLASH的片选脚对应的GPIO, 当类型是spi时才需要传\n返回值：\nuserdata 成功返回一个数据结构,否则返回nil\n例子：\nlocal drv = sfd.init(\"spi\", 0, 17)\nif drv then\n    log.info(\"sfd\", \"chip id\", sfd.id(drv):toHex())\nend\n-- 2023.01.15之后的固件支持onchip类型, 支持直接读写片上flash的一小块区域,一般是64k\n-- 这块区域通常是fdb/fskv库所在的区域, 所以不要混着用\nlocal onchip = sfd.init(\"onchip\")\nlocal data = sfd.read(onchip, 0x100, 256)\nsfd.erase(onchip, 0x100)\nsfd.write(onchip, 0x100, data or \"Hi\")\n\n"
            },
            {
                "name": "sfd.status",
                "snippet": "sfd.status(${1:drv})",
                "description": "sfd.status(drv) - 检查spi flash状态\n传入值：\nuserdata sfd.init返回的数据结构\n返回值：\nint 状态值, 0 未初始化成功,1初始化成功且空闲,2正忙\n例子：\nlocal drv = sfd.init(\"spi\", 0, 17)\nif drv then\n    log.info(\"sfd\", \"status\", sfd.status(drv))\nend\n"
            },
            {
                "name": "sfd.read",
                "snippet": "sfd.read(${1:drv},${2:offset},${3:len})",
                "description": "sfd.read(drv, offset, len) - 读取数据\n传入值：\nuserdata sfd.init返回的数据结构\nint 起始偏移量\nint 读取长度,当前限制在256以内\n返回值：\nstring 数据\n例子：\nlocal drv = sfd.init(\"spi\", 0, 17)\nif drv then\n    log.info(\"sfd\", \"read\", sfd.read(drv, 0x100, 256))\nend\n"
            },
            {
                "name": "sfd.write",
                "snippet": "sfd.write(${1:drv},${2:offset},${3:data})",
                "description": "sfd.write(drv, offset, data) - 写入数据\n传入值：\nuserdata sfd.init返回的数据结构\nint 起始偏移量\nstring 需要写入的数据,当前支持256字节及以下\n返回值：\nboolean 成功返回true,失败返回false\n例子：\nlocal drv = sfd.init(\"spi\", 0, 17)\nif drv then\n    log.info(\"sfd\", \"write\", sfd.write(drv, 0x100, \"hi,luatos\"))\nend\n"
            },
            {
                "name": "sfd.erase",
                "snippet": "sfd.erase(${1:drv},${2:offset})",
                "description": "sfd.erase(drv, offset) - 擦除数据\n传入值：\nuserdata sfd.init返回的数据结构\nint 起始偏移量\n返回值：\nboolean 成功返回true,失败返回false\n例子：\nlocal drv = sfd.init(\"spi\", 0, 17)\nif drv then\n    log.info(\"sfd\", \"write\", sfd.erase(drv, 0x100))\nend\n"
            },
            {
                "name": "sfd.id",
                "snippet": "sfd.id(${1:drv})",
                "description": "sfd.id(drv) - 芯片唯一id\n传入值：\nuserdata sfd.init返回的数据结构\n返回值：\nstring 8字节(64bit)的芯片id\n例子：\nlocal drv = sfd.init(\"spi\", 0, 17)\nif drv then\n    log.info(\"sfd\", \"chip id\", sfd.id(drv))\nend\n"
            },
            {
                "name": "sfud.init",
                "snippet": "sfud.init(${1:spi_id},${2:spi_cs},${3:spi_bandrate)/sfud.init(spi_device})",
                "description": "sfud.init(spi_id, spi_cs, spi_bandrate)/sfud.init(spi_device) - 初始化sfud\n传入值：\nint spi_id SPI的ID/userdata spi_device\nint spi_cs SPI的片选\nint spi_bandrate SPI的频率\n返回值：\nbool 成功返回true,否则返回false\n例子：\n--spi\nlog.info(\"sfud.init\",sfud.init(0,20,20 * 1000 * 1000))\n--spi_device\nlocal spi_device = spi.deviceSetup(0,17,0,0,8,2000000,spi.MSB,1,0)\nlog.info(\"sfud.init\",sfud.init(spi_device))\n"
            },
            {
                "name": "sfud.getDeviceNum",
                "snippet": "sfud.getDeviceNum()",
                "description": "sfud.getDeviceNum() - 获取flash设备信息表中的设备总数\n返回值：\nint 返回设备总数\n例子：\nlog.info(\"sfud.getDeviceNum\",sfud.getDeviceNum())\n"
            },
            {
                "name": "sfud.getDevice",
                "snippet": "sfud.getDevice(${1:index})",
                "description": "sfud.getDevice(index) - 通过flash信息表中的索引获取flash设备\n传入值：\nint index flash信息表中的索引\n返回值：\nuserdata 成功返回一个数据结构,否则返回nil\n例子：\nlocal sfud_device = sfud.getDevice(1)\n"
            },
            {
                "name": "sfud.getDeviceTable",
                "snippet": "sfud.getDeviceTable()",
                "description": "sfud.getDeviceTable() - 获取flash设备信息表\n返回值：\nuserdata 成功返回一个数据结构,否则返回nil\n例子：\nlocal sfud_device = sfud.getDeviceTable()\n"
            },
            {
                "name": "sfud.chipErase",
                "snippet": "sfud.chipErase(${1:flash})",
                "description": "sfud.chipErase(flash) - 擦除 Flash 全部数据\n传入值：\nuserdata flash Flash 设备对象 sfud.get_device_table()返回的数据结构\n返回值：\nint 成功返回0\n例子：\nsfud.chipErase(flash)\n"
            },
            {
                "name": "sfud.erase",
                "snippet": "sfud.erase(${1:flash},${2:add},${3:size})",
                "description": "sfud.erase(flash,add,size) - 擦除 Flash 指定地址指定大小，按照flash block大小进行擦除\n传入值：\nuserdata flash Flash 设备对象 sfud.get_device_table()返回的数据结构\nnumber add 擦除地址\nnumber size 擦除大小\n返回值：\nint 成功返回0\n例子：\nsfud.erase(flash,add,size)\n"
            },
            {
                "name": "sfud.read",
                "snippet": "sfud.read(${1:flash},${2:addr},${3:size})",
                "description": "sfud.read(flash, addr, size) - 读取 Flash 数据\n传入值：\nuserdata flash Flash 设备对象 sfud.get_device_table()返回的数据结构\nint addr 起始地址\nint size 从起始地址开始读取数据的总大小\n返回值：\nstring data 读取到的数据\n例子：\nlog.info(\"sfud.read\",sfud.read(sfud_device,1024,4))\n"
            },
            {
                "name": "sfud.write",
                "snippet": "sfud.write(${1:flash},${2:addr},${3:data})",
                "description": "sfud.write(flash, addr,data) - 向 Flash 写数据\n传入值：\nuserdata flash Flash 设备对象 sfud.get_device_table()返回的数据结构\nint addr 起始地址\nstring data 待写入的数据\n返回值：\nint 成功返回0\n例子：\nlog.info(\"sfud.write\",sfud.write(sfud_device,1024,\"sfud\"))\n"
            },
            {
                "name": "sfud.eraseWrite",
                "snippet": "sfud.eraseWrite(${1:flash},${2:addr},${3:data})",
                "description": "sfud.eraseWrite(flash, addr,data) - 先擦除再往 Flash 写数据\n传入值：\nuserdata flash Flash 设备对象 sfud.get_device_table()返回的数据结构\nint addr 起始地址\nstring data 待写入的数据\n返回值：\nint 成功返回0\n例子：\nlog.info(\"sfud.eraseWrite\",sfud.eraseWrite(sfud_device,1024,\"sfud\"))\n"
            },
            {
                "name": "sfud.getInfo",
                "snippet": "sfud.getInfo(${1:flash})",
                "description": "sfud.getInfo(flash) - 获取 Flash 容量和page大小\n传入值：\nuserdata flash Flash 设备对象 sfud.get_device_table()返回的数据结构\n返回值：\nint Flash 容量\nint page 页大小\n例子：\nlog.info(\"sfud.getInfo\",sfud.getInfo(sfud_device))\n"
            },
            {
                "name": "sfud.mount",
                "snippet": "sfud.mount(${1:flash},${2:mount_point},${3:offset},${4:maxsize})",
                "description": "sfud.mount(flash, mount_point, offset, maxsize) - 挂载sfud lfs文件系统\n传入值：\nuserdata flash Flash 设备对象 sfud.get_device_table()返回的数据结构\nstring mount_point 挂载目录名\nint 起始偏移量,默认0\nint 总大小, 默认是整个flash\n返回值：\nbool 成功返回true\n例子：\nlog.info(\"sfud.mount\",sfud.mount(sfud_device,\"/sfud\"))\nlog.info(\"fsstat\", fs.fsstat(\"/\"))\nlog.info(\"fsstat\", fs.fsstat(\"/sfud\"))\n"
            },
            {
                "name": "sms.send",
                "snippet": "sms.send(${1:phone},${2:msg},${3:auto_phone_fix})",
                "description": "sms.send(phone, msg, auto_phone_fix) - 发送短信\n传入值：\nstring 电话号码,必填\nstring 短信内容,必填\nbool 是否自动处理电话号号码的格式,默认是按短信内容和号码格式进行自动判断, 设置为false可禁用\n返回值：\nbool 成功返回true,否则返回false或nil\n"
            },
            {
                "name": "sms.setNewSmsCb",
                "snippet": "sms.setNewSmsCb(${1:func})",
                "description": "sms.setNewSmsCb(func) - 设置新SMS的回调函数\n传入值：\nfunction 回调函数, 3个参数, num, txt, metas\n返回值：\nnil 传入是函数就能成功,无返回值\n例子：\n\nsms.setNewSmsCb(function(num, txt, metas)\n    -- num 手机号码\n    -- txt 文本内容\n    -- metas 短信的元数据,例如发送的时间,长短信编号\n    -- 注意, 长短信会自动合并成一条txt\n    log.info(\"sms\", num, txt, metas and json.encode(metas) or \"\")\nend)\n"
            },
            {
                "name": "sms.autoLong",
                "snippet": "sms.autoLong(${1:mode})",
                "description": "sms.autoLong(mode) - 设置长短信的自动合并功能\n传入值：\nbool 是否自动合并,true为自动合并,为默认值\n返回值：\nbool 设置后的值\n例子：\n-- 禁用长短信的自动合并, 一般不需要禁用\nsms.autoLong(false)\n"
            },
            {
                "name": "sms.clearLong",
                "snippet": "sms.clearLong()",
                "description": "sms.clearLong() - 清除长短信缓存\n返回值：\nint 清理掉的片段数量\n例子：\nsms.clearLong()\n"
            },
            {
                "name": "socket.sntp",
                "snippet": "socket.sntp(${1:sntp_server})",
                "description": "socket.sntp(sntp_server) - sntp时间同步\n传入值：\nstring/table sntp服务器地址 选填\nint 适配器序号， 只能是socket.ETH0（外置以太网），socket.LWIP_ETH（内置以太网），socket.LWIP_STA（内置WIFI的STA），socket.LWIP_AP（内置WIFI的AP），socket.LWIP_GP（内置蜂窝网络的GPRS），socket.USB（外置USB网卡），如果不填，优先选择soc平台自带能上外网的适配器，若仍然没有，选择最后一个注册的适配器\n例子：\nsocket.sntp()\n--socket.sntp(\"ntp.aliyun.com\") --自定义sntp服务器地址\n--socket.sntp({\"ntp.aliyun.com\",\"ntp1.aliyun.com\",\"ntp2.aliyun.com\"}) --sntp自定义服务器地址\n--socket.sntp(nil, socket.ETH0) --sntp自定义适配器序号\nsys.subscribe(\"NTP_UPDATE\", function()\n    log.info(\"sntp\", \"time\", os.date())\nend)\nsys.subscribe(\"NTP_ERROR\", function()\n    log.info(\"socket\", \"sntp error\")\n    socket.sntp()\nend)\n"
            },
            {
                "name": "socket.ntptm",
                "snippet": "socket.ntptm()",
                "description": "socket.ntptm() - 网络对时后的时间戳(ms级别)\n返回值：\ntable 包含时间信息的数据\n例子：\n-- 本API于 2023.11.15 新增\n-- 注意, 本函数在执行socket.sntp()且获取到NTP时间后才有效\n-- 而且是2次sntp之后才是比较准确的值\n-- 网络波动越小, 该时间戳越稳定\nlocal tm = socket.ntptm()\n\n-- 对应的table包含多个数据, 均为整数值\n\n-- 标准数据\n-- tsec 当前秒数,从1900.1.1 0:0:0 开始算, UTC时间\n-- tms  当前毫秒数\n-- vaild 是否有效, true 或者 nil\n\n-- 调试数据, 调试用,一般用户不用管\n-- ndelay 网络延时平均值,单位毫秒\n-- ssec 系统启动时刻与1900.1.1 0:0:0的秒数偏移量\n-- sms 系统启动时刻与1900.1.1 0:0:0的毫秒偏移量\n-- lsec 本地秒数计数器,基于mcu.tick64()\n-- lms 本地毫秒数计数器,基于mcu.tick64()\n\nlog.info(\"tm数据\", json.encode(tm))\nlog.info(\"时间戳\", string.format(\"%u.%03d\", tm.tsec, tm.tms))\n"
            },
            {
                "name": "socket.sntp_port",
                "snippet": "socket.sntp_port(${1:port})",
                "description": "socket.sntp_port(port) - 设置SNTP服务器的端口号\n传入值：\nint port 端口号, 默认123\n返回值：\nint 返回当前的端口号\n例子：\n-- 本函数于2024.5.17新增\n-- 大部分情况下不需要设置NTP服务器的端口号,默认123即可\n"
            },
            {
                "name": "socket.localIP",
                "snippet": "socket.localIP(${1:adapter})",
                "description": "socket.localIP(adapter) - 获取本地ip\n传入值：\nint 适配器序号， 只能是socket.ETH0（外置以太网），socket.LWIP_ETH（内置以太网），socket.LWIP_STA（内置WIFI的STA），socket.LWIP_AP（内置WIFI的AP），socket.LWIP_GP（内置蜂窝网络的GPRS），socket.USB（外置USB网卡），如果不填，优先选择soc平台自带能上外网的适配器，若仍然没有，选择最后一个注册的适配器\n返回值：\nstring 通常是内网ip, 也可能是外网ip, 取决于运营商的分配\nstring 网络掩码\nstring 网关IP\n例子：\nsys.taskInit(function()\n    while 1 do\n        sys.wait(3000)\n        log.info(\"socket\", \"ip\", socket.localIP())\n        -- 输出示例\n        -- 62.39.244.10    255.255.255.255    0.0.0.0\n    end\nend)\n"
            },
            {
                "name": "socket.create",
                "snippet": "socket.create(${1:adapter},${2:cb})",
                "description": "socket.create(adapter, cb) - 在某个适配的网卡上申请一个socket_ctrl\n传入值：\nint 适配器序号， 只能是socket.ETH0（外置以太网），socket.LWIP_ETH（内置以太网），socket.LWIP_STA（内置WIFI的STA），socket.LWIP_AP（内置WIFI的AP），socket.LWIP_GP（内置蜂窝网络的GPRS），socket.USB（外置USB网卡），如果不填，优先选择soc平台自带能上外网的适配器，若仍然没有，选择最后一个注册的适配器\nstring or function string为消息通知的taskName，function则为回调函数，如果固件没有内置sys_wait，则必须是function\n"
            },
            {
                "name": "socket.debug",
                "snippet": "socket.debug(${1:ctrl},${2:onoff})",
                "description": "socket.debug(ctrl, onoff) - 配置是否打开debug信息\n传入值：\nuser_data socket.create得到的ctrl\nboolean true 打开debug开关\n返回值：\nnil 无返回值\n例子：\n-- 打开调试信息,默认是关闭状态\nsocket.debug(ctrl, true)\n"
            },
            {
                "name": "socket.config",
                "snippet": "socket.config(${1:ctrl},${2:local_port},${3:is_udp},${4:is_tls},${5:keep_idle},${6:keep_interval},${7:keep_cnt},${8:server_cert},${9:client_cert},${10:client_key},${11:client_password})",
                "description": "socket.config(ctrl, local_port, is_udp, is_tls, keep_idle, keep_interval, keep_cnt, server_cert, client_cert, client_key, client_password) - 配置network一些信息，\n传入值：\nuser_data socket.create得到的ctrl\nint 本地端口号，小端格式，如果不写，则自动分配一个，如果用户填了端口号则需要小于60000, 默认不写\nboolean 是否是UDP，默认false\nboolean 是否是加密传输，默认false\nint tcp keep live模式下的idle时间（秒），如果留空则表示不启用，如果是不支持标准posix接口的网卡（比如W5500），则为心跳间隔\nint tcp keep live模式下的探测间隔时间（秒）\nint tcp keep live模式下的探测次数\nstring TCP模式下的服务器ca证书数据，UDP模式下的PSK，不需要加密传输写nil，后续参数也全部nil\nstring TCP模式下的客户端ca证书数据，UDP模式下的PSK-ID，TCP模式下如果不需要验证客户端证书时，忽略，一般不需要验证客户端证书\nstring TCP模式下的客户端私钥加密数据\nstring TCP模式下的客户端私钥口令数据\n返回值：\nboolean 成功返回true，失败返回false\n例子：\n--最普通的TCP传输\nsocket.config(ctrl)\n--最普通的加密TCP传输，证书都不用验证的那种\nsocket.config(ctrl, nil, nil ,true)\n"
            },
            {
                "name": "socket.linkup",
                "snippet": "socket.linkup(${1:ctrl})",
                "description": "socket.linkup(ctrl) - 等待网卡linkup\n传入值：\nuser_data socket.create得到的ctrl\n返回值：\nboolean true没有异常发生，false失败了，如果false则不需要看下一个返回值了\nboolean true已经linkup，false没有linkup，之后需要接收socket.LINK消息\n例子：\n-- 判断一下是否已经联网\nlocal succ, result = socket.linkup(ctrl)\n"
            },
            {
                "name": "socket.connect",
                "snippet": "socket.connect(${1:ctrl},${2:ip},${3:remote_port},${4:need_ipv6_dns})",
                "description": "socket.connect(ctrl, ip, remote_port, need_ipv6_dns) - 作为客户端连接服务器\n传入值：\nuser_data socket.create得到的ctrl\nstring or int ip或者域名，如果是IPV4，可以是大端格式的int值\nint 服务器端口号，小端格式\nboolean 域名解析是否要IPV6，true要，false不要，默认false不要，只有支持IPV6的协议栈才有效果\n返回值：\nboolean true没有异常发生，false失败了，如果false则不需要看下一个返回值了，如果有异常，后续要close\nboolean true已经connect，false没有connect，之后需要接收socket.ON_LINE消息\n例子：\n\nlocal succ, result = socket.connect(ctrl, \"netlab.luatos.com\", 40123)\n\n--[[\n常见的连接失败的code值, 会在日志中显示\n-1 底层内存不足\n-3 超时\n-8 端口已经被占用\n-11 链接未建立\n-13 模块主动断开连接\n-14 服务器主动断开连接\n]]\n"
            },
            {
                "name": "socket.discon",
                "snippet": "socket.discon(${1:ctrl})",
                "description": "socket.discon(ctrl) - 作为客户端断开连接\n传入值：\nuser_data socket.create得到的ctrl\n返回值：\nboolean true没有异常发生，false失败了，如果false则不需要看下一个返回值了\nboolean true已经断开，false没有断开，之后需要接收socket.CLOSED消息\n例子：\nlocal succ, result = socket.discon(ctrl)\n"
            },
            {
                "name": "socket.close",
                "snippet": "socket.close(${1:ctrl})",
                "description": "socket.close(ctrl) - 强制关闭socket\n传入值：\nuser_data socket.create得到的ctrl\n返回值：\nnil 无返回值\n"
            },
            {
                "name": "socket.tx",
                "snippet": "socket.tx(${1:ctrl},${2:data},${3:ip},${4:port},${5:flag})",
                "description": "socket.tx(ctrl, data, ip, port, flag) - 发送数据给对端，UDP单次发送不要超过1460字节，否则很容易失败\n传入值：\nuser_data socket.create得到的ctrl\nstring or user_data zbuff  要发送的数据\nstring or int 对端IP，如果是TCP应用则忽略，如果是UDP，如果留空则用connect时候的参数，如果是IPV4，可以是大端格式的int值\nint 对端端口号，小端格式，如果是TCP应用则忽略，如果是UDP，如果留空则用connect时候的参数\nint 发送参数，目前预留，不起作用\n返回值：\nboolean true没有异常发生，false失败了，如果false则不需要看下一个返回值了，如果false，后续要close\nboolean true缓冲区满了，false没有满，如果true，则需要等待一段时间或者等到socket.TX_OK消息后再尝试发送，同时忽略下一个返回值\nboolean true已经收到应答，false没有收到应答，之后需要接收socket.TX_OK消息， 也可以忽略继续发送，直到full==true\n例子：\n\nlocal succ, full, result = socket.tx(ctrl, \"123456\", \"xxx.xxx.xxx.xxx\", xxxx)\n"
            },
            {
                "name": "socket.rx",
                "snippet": "socket.rx(${1:ctrl},${2:buff},${3:flag},${4:limit})",
                "description": "socket.rx(ctrl, buff, flag, limit) - 接收对端发出的数据，注意数据已经缓存在底层，使用本函数只是提取出来，UDP模式下一次只会取出一个数据包\n传入值：\nuser_data socket.create得到的ctrl\nuser_data zbuff 存放接收的数据，如果缓冲区不够大会自动扩容\nint 接收参数，目前预留，不起作用\nint 接收数据长度限制，如果指定了，则只取前N个字节. 2024.1.5 新增\n返回值：\nboolean true没有异常发生，false失败了，如果false则不需要看下一个返回值了，如果false，后续要close\nint 本次接收到数据长度\nstring 对端IP，只有UDP模式下才有意义，TCP模式返回nil，注意返回的格式，如果是IPV4，1byte 0x00 + 4byte地址 如果是IPV6，1byte 0x01 + 16byte地址\nint 对端port，只有UDP模式下才有意义，TCP模式返回0\n例子：\n-- 从socket中读取数据, ctrl是socket.create返回的, 请查阅demo/socket\nlocal buff = zbuff.create(2048)\nlocal succ, data_len, remote_ip, remote_port = socket.rx(ctrl, buff)\n\n-- 限制读取长度, 2024.1.5 新增\n-- 注意\n-- 如果是UDP数据, 如果limit小于UDP数据包长度, 只会取前limit个字节, 剩余数据会丢弃\n-- 如果是TCP数据, 如果有剩余数据, 不会丢弃, 可继续读取.\n-- 有新的数据到来才会有新的EVENT数据, 未读取完成的数据不会触发新EVENT事件\nlocal succ, data_len, remote_ip, remote_port = socket.rx(ctrl, buff, 1500)\n\n-- 读取缓冲区大小, 2024.1.5 新增, 注意,老版本固件不传buff参数会报错的\n-- 对于TCP数据, 这里返回的是待读取的数据的总长度\n-- 对于UDP数据, 这里返回的是单个UDP数据包的长度\nlocal succ, data_len = socket.rx(ctrl)\nif succ then\n    log.info(\"待收取数据长度\", data_len)\nend\n"
            },
            {
                "name": "socket.read",
                "snippet": "socket.read(${1:netc},${2:len})",
                "description": "socket.read(netc, len) - 读取数据(非zbuff版本)\n传入值：\nuserdata socket.create得到的ctrl\nint 限制读取数据长度,可选,不传就是读出全部\n返回值：\nboolean 读取成功与否\nstring 读取的数据,仅当读取成功时有效\nstring 对方IP地址,仅当读取成功且UDP通信时有效\nint 对方端口,仅当读取成功且UDP通信时有效\n例子：\n-- 本函数于2024.4.8添加, 用于简易读取不大的数据\n-- 请优先使用socket.rx函数, 本函数主要用于固件不含zbuff库时的变通调用\nlocal ok, data = socket.read(netc, 1500)\nif ok and #data > 0 then\n    log.info(\"读取到的数据\", data)\nend\n"
            },
            {
                "name": "socket.wait",
                "snippet": "socket.wait(${1:ctrl})",
                "description": "socket.wait(ctrl) - 等待新的socket消息，在连接成功和发送数据成功后，使用一次将network状态转换到接收新数据\n传入值：\nuser_data socket.create得到的ctrl\n返回值：\nboolean true没有异常发生，false失败了，如果false则不需要看下一个返回值了，如果false，后续要close\nboolean true有新的数据需要接收，false没有数据，之后需要接收socket.EVENT消息\n例子：\nlocal succ, result = socket.wait(ctrl)\n"
            },
            {
                "name": "socket.listen",
                "snippet": "socket.listen(${1:ctrl})",
                "description": "socket.listen(ctrl) - 作为服务端开始监听\n传入值：\nuser_data socket.create得到的ctrl\n返回值：\nboolean true没有异常发生，false失败了，如果false则不需要看下一个返回值了，如果false，后续要close\nboolean true已经connect，false没有connect，之后需要接收socket.ON_LINE消息\n例子：\nlocal succ, result = socket.listen(ctrl)\n"
            },
            {
                "name": "socket.accept",
                "snippet": "socket.accept(${1:ctrl})",
                "description": "socket.accept(ctrl) - 作为服务端接收到一个新的客户端，注意，如果是类似W5500的硬件协议栈不支持1对多，则不需要第二个参数\n传入值：\nuser_data socket.create得到的ctrl，这里是服务器端\nstring or function or nil string为消息通知的taskName，function则为回调函数，和socket.create参数一致\n返回值：\nboolean true没有异常发生，false失败了，如果false则不需要看下一个返回值了，如果false，后续要close\nuser_data or nil 如果支持1对多，则会返回新的ctrl，自动create，如果不支持则返回nil\n例子：\nlocal succ, new_netc = socket.listen(ctrl, cb)\n"
            },
            {
                "name": "socket.state",
                "snippet": "socket.state(${1:ctrl})",
                "description": "socket.state(ctrl) - 获取socket当前状态\n传入值：\nuser_data socket.create得到的ctrl\n返回值：\nint or nil,输入参数正确的情况下，返回状态的数值，否则返回nil\nstring or nil,输入参数正确的情况下，返回状态的中文描述，否则返回nil\n例子：\nlocal state, str = socket.state(ctrl)\nlog.info(\"state\", state, str)\nstate    0    \"硬件离线\",\n        1    \"离线\",\n        2    \"等待DNS\",\n        3    \"正在连接\",\n        4    \"正在TLS握手\",\n        5    \"在线\",\n        6    \"在监听\",\n        7    \"正在离线\",\n        8    \"未知\"\n"
            },
            {
                "name": "socket.release",
                "snippet": "socket.release(${1:ctrl})",
                "description": "socket.release(ctrl) - 主动释放掉network_ctrl\n传入值：\nuser_data socket.create得到的ctrl\n例子：\n-- 释放后就不能再使用了\nsocket.release(ctrl)\n"
            },
            {
                "name": "socket.setDNS",
                "snippet": "socket.setDNS(${1:adapter_index},${2:dns_index},${3:ip})",
                "description": "socket.setDNS(adapter_index, dns_index, ip) - 设置DNS服务器\n传入值：\nint 适配器序号， 只能是socket.ETH0，socket.STA，socket.AP，如果不填，会选择最后一个注册的适配器\nint dns服务器序号，从1开始\nstring or int dns，如果是IPV4，可以是大端格式的int值\n返回值：\nboolean 成功返回true，失败返回false\n例子：\n-- 设置默认网络适配器的DNS配置\nsocket.setDNS(nil, 1, \"114.114.114.114\")\n-- 设置制定网络适配器的DNS配置\nsocket.setDNS(socket.ETH0, 1, \"114.114.114.114\")\n"
            },
            {
                "name": "socket.sslLog",
                "snippet": "socket.sslLog(${1:log_level})",
                "description": "socket.sslLog(log_level) - 设置SSL的log登记\n传入值：\nint mbedtls log等级\n返回值：\nnil 无返回值\n例子：\n--[[\nSSL/TLS log级别说明\n0不打印\n1只打印错误和警\n2大部分info\n3及3以上详细的debug\n\n过多的信息可能会造成内存碎片化\n]]\n-- 打印大部分info日志\nsocket.sslLog(2)\n"
            },
            {
                "name": "socket.adapter",
                "snippet": "socket.adapter(${1:index})",
                "description": "socket.adapter(index) - 查看网卡适配器的联网状态\n传入值：\nint 需要查看的适配器序号，可以留空会查看全部网卡，直到遇到IP READY的，如果指定网卡，只能是socket.ETH0（外置以太网），socket.LWIP_ETH（内置以太网），socket.LWIP_STA（内置WIFI的STA），socket.LWIP_AP（内置WIFI的AP），socket.LWIP_GP（内置蜂窝网络的GPRS），socket.USB（外置USB网卡）\n返回值：\nboolean 被查看的适配器是否IP READY,true表示已经准备好可以联网了,false暂时不可以联网\nint 最后一个被查看的适配器序号\n例子：\n-- 查看全部网卡，直到找到一个是IP READY的\nlocal isReady,index = socket.adapter() --如果isReady为true,则index为IP READY的网卡适配器序号\n--查看外置以太网（比如W5500）是否IP READY\nlocal isReady,default = socket.adapter(socket.ETH0)\n"
            },
            {
                "name": "socket.remoteIP",
                "snippet": "socket.remoteIP(${1:ctrl})",
                "description": "socket.remoteIP(ctrl) - 获取对端ip\n传入值：\nuser_data socket.create得到的ctrl\n返回值：\nstring IP1，如果为nil，则表示没有获取到IP地址\nstring IP2，如果为nil，则表示没有IP2\nstring IP3，如果为nil，则表示没有IP3\nstring IP4，如果为nil，则表示没有IP4\n例子：\n-- 注意: ，必须在接收到socket.ON_LINE消息之后才可能获取到，最多返回4个IP。\n-- socket.connect里如果remote_port设置成0，则当DNS完成时就返回socket.ON_LINE消息\nlocal ip1,ip2,ip3,ip4 = socket.remoteIP(ctrl)\n"
            },
            {
                "name": "softkb.init",
                "snippet": "softkb.init(${1:port},${2:key_in},${3:key_out})",
                "description": "softkb.init(port, key_in, key_out) - 初始化软件键盘矩阵\n传入值：\nint 预留, 当前填0\ntable 矩阵输入按键表\ntable 矩阵输出按键表\n例子：\n    key_in = {pin.PD10,pin.PE00,pin.PE01,pin.PE02}\n    key_out = {pin.PD12,pin.PD13,pin.PD14,pin.PD15}\n    softkb.init(0,key_in,key_out)\n\nsys.subscribe(\"SOFT_KB_INC\", function(port, data, state)\n    -- port 当前固定为0, 可以无视\n    -- data, 需要配合init的map进行解析\n    -- state, 1 为按下, 0 为 释放\n    -- TODO 详细介绍\nend)\n"
            },
            {
                "name": "softkb.deinit",
                "snippet": "softkb.deinit(${1:port})",
                "description": "softkb.deinit(port) - 删除软件键盘矩阵\n传入值：\nint 预留, 当前填0\n例子：\n    softkb.deinit(0)\n"
            },
            {
                "name": "spi.setup",
                "snippet": "spi.setup(${1:id},${2:cs},${3:CPHA},${4:CPOL},${5:dataw},${6:bandrate},${7:bitdict},${8:ms},${9:mode})",
                "description": "spi.setup(id, cs, CPHA, CPOL, dataw, bandrate, bitdict, ms, mode) - 设置并启用SPI\n传入值：\nint SPI号,例如0\nint CS 片选脚,在w600不可用请填nil\nint CPHA 默认0,可选0/1\nint CPOL 默认0,可选0/1\nint 数据宽度,默认8bit\nint 波特率,默认2M=2000000\nint 大小端, 默认spi.MSB, 可选spi.LSB\nint 主从设置, 默认主1, 可选从机0. 通常只支持主机模式\nint 工作模式, 全双工1, 半双工0, 默认全双工\n返回值：\nint 成功返回0,否则返回其他值\n例子：\n-- 初始化spi\nspi.setup(0,20,0,0,8,2000000,spi.MSB,1,1)\n"
            },
            {
                "name": "spi.createSoft",
                "snippet": "spi.createSoft(${1:cs},${2:mosi},${3:miso},${4:clk},${5:CPHA},${6:CPOL},${7:dataw},${8:bitdict},${9:ms},${10:mode})",
                "description": "spi.createSoft(cs, mosi, miso, clk, CPHA, CPOL, dataw, bitdict, ms, mode) - 设置并启用软件SPI\n传入值：\nint cs引脚编号，传入nil意为Lua控制cs脚\nint mosi引脚编号\nint miso引脚编号\nint clk引脚编号\nint 默认0，可选0/1\nint 默认0，可选0/1\nint 数据宽度，默认8bit\nint 大小端，默认spi.MSB, 可选spi.LSB\nint 主从设置，默认主1, 可选从机0. 通常只支持主机模式\nint 工作模式，全双工1，半双工0，默认半双工\n返回值：\n软件SPI对象 可当作SPI的id使用\n例子：\n-- 初始化软件spi\nlocal softSpiDevice = spi.createSoft(0, 1, 2, 3, 0, 0, 8, spi.MSB, 1, 1)\nlocal result = spi.send(softSpiDevice, string.char(0x9f))\n"
            },
            {
                "name": "spi.close",
                "snippet": "spi.close(${1:id})",
                "description": "spi.close(id) - 关闭指定的SPI\n传入值：\nint SPI号,例如0\n返回值：\nint 成功返回0,否则返回其他值\n例子：\n-- 初始化spi\nspi.close(0)\n"
            },
            {
                "name": "spi.transfer",
                "snippet": "spi.transfer(${1:id},${2:send_data},${3:send_len},${4:recv_len})",
                "description": "spi.transfer(id, send_data, send_len, recv_len) - 传输SPI数据\n传入值：\nint SPI号(例如0)或软件SPI对象\nstring/zbuff 待发送的数据，如果为zbuff数据，则会从对象所处的指针处开始读\nint 可选。待发送数据的长度，默认为data长度\nint 可选。读取数据的长度，默认为1\n返回值：\nstring 读取成功返回字符串,否则返回nil\n例子：\n-- 初始化spi\nspi.setup(0,nil,0,0,8,2000000,spi.MSB,1,1)\nlocal recv = spi.transfer(0, \"123\")--发送123,并读取数据\n\nlocal buff = zbuff.create(1024, 0x33) --创建一个初值全为0x33的内存区域\nlocal recv = spi.transfer(0, buff)--把zbuff数据从指针开始，全发出去,并读取数据\n"
            },
            {
                "name": "spi.recv",
                "snippet": "spi.recv(${1:id},${2:size},${3:buff})",
                "description": "spi.recv(id, size, buff) - 接收指定长度的SPI数据\n传入值：\nint SPI号,例如0\nint 数据长度\nuserdata zbuff对象,可选,2024.3.29新增\n返回值：\nstring/int 读取成功返回字符串,若传入的是zbuff就返回读取大小,出错返回nil\n例子：\n-- 初始化spi\nspi.setup(0,nil,0,0,8,2000000,spi.MSB,1,1)\n-- 接收数据\nlocal recv = spi.recv(0, 4)--接收4字节数据\n\n-- 当传入zbuff参数时,返回值有所不同. 2024.3.29新增\n-- 读取成功后, 指针会往后移动len个字节\n-- 写入位置以当前used()位置开始, 请务必确保有足够空间写入len长度的数据\nlocal len = spi.recv(0, 4, buff)\n"
            },
            {
                "name": "spi.send",
                "snippet": "spi.send(${1:id},${2:data[},${3:len]})",
                "description": "spi.send(id, data[, len]) - 发送SPI数据\n传入值：\nint SPI号,例如0\nstring/zbuff 待发送的数据，如果为zbuff数据，则会从对象所处的指针处开始读\nint 可选。待发送数据的长度，默认为data长度\n返回值：\nint 发送结果\n例子：\n-- 初始化spi\nspi.setup(0,nil,0,0,8,2000000,spi.MSB,1,1)\nlocal result = spi.send(0, \"123\")--发送123\n\nlocal buff = zbuff.create(1024, 0x33) --创建一个初值全为0x33的内存区域\nlocal result = spi.send(0, buff)--把zbuff数据从指针开始，全发出去\n"
            },
            {
                "name": "spi.deviceSetup",
                "snippet": "spi.deviceSetup(${1:id},${2:cs},${3:CPHA},${4:CPOL},${5:dataw},${6:bandrate},${7:bitdict},${8:ms},${9:mode})",
                "description": "spi.deviceSetup(id, cs, CPHA, CPOL, dataw, bandrate, bitdict, ms, mode) - 设置并启用SPI(对象方式)\n传入值：\nint SPI号,例如0\nint CS 片选脚,在w600不可用请填nil\nint CPHA 默认0,可选0/1\nint CPOL 默认0,可选0/1\nint 数据宽度,默认8bit\nint 波特率,默认20M=20000000\nint 大小端, 默认spi.MSB, 可选spi.LSB\nint 主从设置, 默认主1, 可选从机0. 通常只支持主机模式\nint 工作模式, 全双工1, 半双工0, 默认全双工\n返回值：\nuserdata spi_device\n例子：\n-- 初始化spi\nlocal spi_device = spi.deviceSetup(0,17,0,0,8,2000000,spi.MSB,1,1)\n"
            },
            {
                "name": "spi_device:close",
                "snippet": "spi_device:close()",
                "description": "spi_device:close() - 关闭指定的SPI(对象方式)\n传入值：\nuserdata spi_device\n返回值：\nint 成功返回0,否则返回其他值\n例子：\n-- 初始化spi\nspi_device.close()\n"
            },
            {
                "name": "spi_device:transfer",
                "snippet": "spi_device:transfer(${1:send_data[},${2:len]})",
                "description": "spi_device:transfer(send_data[, len]) - 传输SPI数据(对象方式)\n传入值：\nuserdata spi_device\nstring/zbuff 待发送的数据，如果为zbuff数据，则会从对象所处的指针处开始读\nint 可选。待发送数据的长度，默认为data长度\nint 可选。读取数据的长度，默认为1\n返回值：\nstring 读取成功返回字符串,否则返回nil\n例子：\n-- 初始化spi\nlocal spi_device = spi.device_setup(0,17,0,0,8,2000000,spi.MSB,1,1)\nlocal recv = spi_device:transfer(\"123\")--发送123,并读取数据\nlocal result = spi_device:transfer({0x00,0x01})--发送0x00,0x01,并读取数据\n\nlocal buff = zbuff.create(1024, 0x33) --创建一个初值全为0x33的内存区域\nlocal recv = spi_device:transfer(buff)--把zbuff数据从指针开始，全发出去,并读取数据\n"
            },
            {
                "name": "spi_device:send",
                "snippet": "spi_device:send(${1:data[},${2:len]})",
                "description": "spi_device:send(data[, len]) - 发送SPI数据(对象方式)\n传入值：\nuserdata spi_device\nstring/zbuff 待发送的数据，如果为zbuff数据，则会从对象所处的指针处开始读\n返回值：\nint 发送结果\n例子：\n-- 初始化spi\nlocal spi_device = spi.device_setup(0,17,0,0,8,2000000,spi.MSB,1,1)\nlocal result = spi_device:send(\"123\")--发送123\nlocal result = spi_device:send({0x00,0x01})--发送0x00,0x01\n\nlocal buff = zbuff.create(1024, 0x33) --创建一个初值全为0x33的内存区域\nlocal result = spi_device:send(buff)--把zbuff数据从指针开始，全发出去\n"
            },
            {
                "name": "spi_device:recv",
                "snippet": "spi_device:recv(${1:size})",
                "description": "spi_device:recv(size) - 接收指定长度的SPI数据(对象方式)\n传入值：\nuserdata spi_device\nint 数据长度\n返回值：\nstring 读取成功返回字符串,否则返回nil\n例子：\n-- 初始化spi\nlocal spi_device = spi.device_setup(0,17,0,0,8,2000000,spi.MSB,1,1)\nlocal recv = spi_device:recv(4)--接收4字节数据\n"
            },
            {
                "name": "spi.xfer",
                "snippet": "spi.xfer(${1:id},${2:txbuff},${3:rxbuff},${4:rx_len},${5:transfer_done_topic})",
                "description": "spi.xfer(id, txbuff, rxbuff, rx_len, transfer_done_topic) - 非阻塞方式硬件SPI传输SPI数据，目的为了提高核心利用率。API直接返回是否启动传输，传输完成后通过topic回调，本API适合硬件SPI传输大量数据传输，外设功能（LCD SPI，W5500 SPI之类的）占据的SPI和软件SPI不能用，少量数据传输建议使用传统阻塞型API\n传入值：\nuserdata or int spi_device或者spi_id，注意，如果是spi_device，需要手动在传输完成后拉高cs!!!!!!\nzbuff 待发送的数据，如果为nil，则只接收数据，由于用的非阻塞模型，为保证动态数据的有效性，只能使用zbuff，发送的数据从zbuff.addr\nzbuff 接收数据，如果为nil，则只发送数据，由于用的非阻塞模型，为保证动态数据的有效性，只能使用zbuff，接收的数据从zbuff.addr开始存储\nint 传输数据长度，特别说明 如果为半双工，先发后收，比如spi flash操作这种，则长度=发送字节+接收字节，注意上面发送和接收buff都要留足够的数据，后续接收数据处理需要跳过发送数据长度字节\nstring 传输完成后回调的topic\n返回值：\nboolean true/false 本次传输是否正确启动，true，启动，false，有错误无法启动。传输完成会发布消息transfer_done_topic和boolean型结果\n例子：\nlocal result = spi.xfer(spi.SPI_0, txbuff, rxbuff, 1024, \"SPIDONE\") if result then result, spi_id, succ, error_code = sys.waitUntil(\"SPIDONE\") end if not result or not succ then log.info(\"spi fail, error code\", error_code) else log.info(\"spi ok\") end\n\n"
            },
            {
                "name": "spislave.setup",
                "snippet": "spislave.setup(${1:id},${2:opts})",
                "description": "spislave.setup(id, opts) - 初始化SPI从机\n传入值：\nint 从机SPI的编号,注意与SPI主机的编号的差异,这个与具体设备相关\ntable opts 扩展配置参数,当前无参数\n返回值：\nboolean true表示成功,其他失败\n例子：\n-- 当前仅XT804系列支持, 例如 Air101/Air103/Air601/Air690\n-- Air101为例, 初始化SPI从机, 编号为2, SPI模式\nspislave.setup(2)\n-- Air101为例, 初始化SPI从机, 编号为3, SDIO模式\nspislavve.setup(3)\n"
            },
            {
                "name": "spislave.ready",
                "snippet": "spislave.ready(${1:id})",
                "description": "spislave.ready(id) - 是否可写\n传入值：\nint 从机SPI的编号\n返回值：\nboolean true表示可写,其他不可写\n"
            },
            {
                "name": "spislave.on",
                "snippet": "spislave.on(${1:id},${2:cb})",
                "description": "spislave.on(id, cb) - 注册事件回调函数\n传入值：\nint 从机SPI的编号\nfunction 回调函数\n"
            },
            {
                "name": "spislave.read",
                "snippet": "spislave.read(${1:id},${2:ptr},${3:buff},${4:len})",
                "description": "spislave.read(id, ptr, buff, len) - 读取数据\n传入值：\nint 从机SPI的编号\nuserdata 用户数据指针, 从回调函数得到\nint zbuff缓冲对象\nint 读取长度,从回调函数得到\n返回值：\nint 读取到字节数,通常与期望读取的长度相同\nint 错误码, 仅当出错时返回\n"
            },
            {
                "name": "spislave.write",
                "snippet": "spislave.write(${1:id},${2:ptr},${3:buff},${4:len})",
                "description": "spislave.write(id, ptr, buff, len) - 写入数据\n传入值：\nint 从机SPI的编号\nuserdata 用户数据指针, 当前传nil\nint zbuff缓冲对象\nint 写入长度,注意不能超过硬件限制,通常是1500字节\n返回值：\nboolean true表示成功,其他失败\nint 错误码, 仅当出错时返回\n"
            },
            {
                "name": "sqlite3.open",
                "snippet": "sqlite3.open(${1:path})",
                "description": "sqlite3.open(path) - 打开数据库\n传入值：\nstring 数据库文件路径,必须填写,不存在就会自动新建\n返回值：\nuserdata 数据库指针,是否就返回nil\n例子：\nlocal db = sqlite3.open(\"/test.db\")\nif db then\n   -- 数据库操作xxxx\n\n    -- 用完必须关掉\n    sqlite3.close(db)\nend\n"
            },
            {
                "name": "sqlite3.exec",
                "snippet": "sqlite3.exec(${1:db},${2:sql})",
                "description": "sqlite3.exec(db, sql) - 执行SQL语句\n传入值：\nuserdata 通过sqlite3.open获取到的数据库指针\nstring SQL字符串,必须填写\n返回值：\nboolean 成功返回true,否则返回nil\ntable 成功返回查询结果(若有),否则返回报错的字符串\n"
            },
            {
                "name": "sqlite3.close",
                "snippet": "sqlite3.close(${1:db})",
                "description": "sqlite3.close(db) - 关闭数据库\n传入值：\nuserdata 通过sqlite3.open获取到的数据库指针\n返回值：\nboolean 成功返回true,否则返回nil\n"
            },
            {
                "name": "statem.create",
                "snippet": "statem.create(${1:count},${2:repeat})",
                "description": "statem.create(count, repeat) - 创建一个新的状态机.\n传入值：\nint 指令条数,默认32条\nint 重复执行的次数, 0 代表不重复, 正整数代表具体重复执行的次数. 暂不支持永续执行\n返回值：\nsome 若成功,返回状态机指针,否则返回nil\n例子：\ngpio.setup(7, 0, gpio.PULLUP)\ngpio.setup(12, 0, gpio.PULLUP)\ngpio.setup(13, 0, gpio.PULLUP)\ngpio.setup(14, 0, gpio.PULLUP)\nlocal sm =  statem.create()\n            :gpio_set(7, 0) -- gpio设置为低电平\n            :usleep(10)     -- 休眠10us\n            :gpio_set(7, 1) -- gpio设置为高电平\n            :usleep(40)     -- 休眠40us\n            :gpio_set(12, 1) -- gpio设置为高电平\n            :gpio_set(13, 1) -- gpio设置为高电平\n            :gpio_set(14, 1) -- gpio设置为高电平\n            :usleep(40)      -- 休眠40us\n            :gpio_set(7, 0) -- gpio设置为低电平\n            :finish()\n\n-- 执行之,后续会支持后台执行\nsm:exec()\n"
            },
            {
                "name": "string.toHex",
                "snippet": "string.toHex(${1:str},${2:separator})",
                "description": "string.toHex(str, separator) - 将字符串转成HEX\n传入值：\nstring 需要转换的字符串\nstring 分隔符, 默认为\"\"\n返回值：\nstring HEX字符串\nnumber HEX字符串的长度\n例子：\nstring.toHex(\"\\1\\2\\3\") --> \"010203\" 6\nstring.toHex(\"123abc\") --> \"313233616263\" 12\nstring.toHex(\"123abc\", \" \") --> \"31 32 33 61 62 63 \" 12\n"
            },
            {
                "name": "string.fromHex",
                "snippet": "string.fromHex(${1:hex})",
                "description": "string.fromHex(hex) - 将HEX转成字符串\n传入值：\nstring hex,16进制组成的串\n返回值：\nstring 字符串\n例子：\nstring.fromHex(\"010203\")       -->  \"\\1\\2\\3\"\nstring.fromHex(\"313233616263\") -->  \"123abc\"\n"
            },
            {
                "name": "string.split",
                "snippet": "string.split(${1:str},${2:delimiter},${3:keepEmtry})",
                "description": "string.split(str, delimiter, keepEmtry) - 按照指定分隔符分割字符串\n传入值：\nstring 输入字符串\nstring 分隔符,可选,默认 \",\"\nbool 是否保留空白片段,默认为false,不保留. 2023.4.11之后的固件可用\n返回值：\ntable 分割后的字符串表\n例子：\nlocal tmp = string.split(\"123,233333,122\")\nlog.info(\"tmp\", json.encode(tmp))\nlocal tmp = (\"123,456,789\"):split(',') --> {'123','456','789'}\nlog.info(\"tmp\", json.encode(tmp))\n\n-- 保留空片段, 2023.4.11之后的固件可用\nlocal str = \"/tmp//def/1234/\"\nlocal tmp = str:split(\"/\", true) \nlog.info(\"str.split\", #tmp, json.encode(tmp))\n"
            },
            {
                "name": "string.toValue",
                "snippet": "string.toValue(${1:str})",
                "description": "string.toValue(str) - 返回字符串tonumber的转义字符串(用来支持超过31位整数的转换)\n传入值：\nstring 输入字符串\n返回值：\nstring 转换后的二进制字符串\nnumber 转换了多少个字符\n例子：\nstring.toValue(\"123456\") --> \"\\1\\2\\3\\4\\5\\6\"  6\nstring.toValue(\"123abc\") --> \"\\1\\2\\3\\a\\b\\c\"  6\n"
            },
            {
                "name": "string.urlEncode",
                "snippet": "string.urlEncode(${1:\"123abc\"})",
                "description": "string.urlEncode(\"123 abc\") - 将字符串进行url编码转换\n传入值：\nstring 需要转换的字符串\nint mode:url编码的转换标准,\n"
            },
            {
                "name": "string.toBase64",
                "snippet": "string.toBase64(${1:str})",
                "description": "string.toBase64(str) - 将字符串进行base64编码\n传入值：\nstring 需要转换的字符串\n返回值：\nstring 解码后的字符串,如果解码失败会返回空字符串\n"
            },
            {
                "name": "string.fromBase64",
                "snippet": "string.fromBase64(${1:str})",
                "description": "string.fromBase64(str) - 将字符串进行base64解码\n传入值：\nstring 需要转换的字符串\n返回值：\nstring 解码后的字符串,如果解码失败会返回空字符串\n"
            },
            {
                "name": "string.toBase32",
                "snippet": "string.toBase32(${1:str})",
                "description": "string.toBase32(str) - 将字符串进行base32编码\n传入值：\nstring 需要转换的字符串\n返回值：\nstring 解码后的字符串,如果解码失败会返回0长度字符串\n"
            },
            {
                "name": "string.fromBase32",
                "snippet": "string.fromBase32(${1:str})",
                "description": "string.fromBase32(str) - 将字符串进行base32解码\n传入值：\nstring 需要转换的字符串\n返回值：\nstring 解码后的字符串,如果解码失败会返回0长度字符串\n"
            },
            {
                "name": "string.startsWith",
                "snippet": "string.startsWith(${1:str},${2:prefix})",
                "description": "string.startsWith(str, prefix) - 判断字符串前缀\n传入值：\nstring 需要检查的字符串\nstring 前缀字符串\n返回值：\nbool 真为true, 假为false\n例子：\nlocal str = \"abc\"\nlog.info(\"str\", str:startsWith(\"a\"))\nlog.info(\"str\", str:startsWith(\"b\"))\n"
            },
            {
                "name": "string.endsWith",
                "snippet": "string.endsWith(${1:str},${2:suffix})",
                "description": "string.endsWith(str, suffix) - 判断字符串后缀\n传入值：\nstring 需要检查的字符串\nstring 后缀字符串\n返回值：\nbool 真为true, 假为false\n例子：\nlocal str = \"abc\"\nlog.info(\"str\", str:endsWith(\"c\"))\nlog.info(\"str\", str:endsWith(\"b\"))\n"
            },
            {
                "name": "string.trim",
                "snippet": "string.trim(${1:str},${2:ltrim},${3:rtrim})",
                "description": "string.trim(str, ltrim, rtrim) - 裁剪字符串,去除头尾的空格\n传入值：\nstring 需要处理的字符串\nbool 清理前缀,默认为true\nbool 清理后缀,默认为true\n返回值：\nstring 清理后的字符串\n例子：\nlocal str = \"\\r\\nabc\\r\\n\"\nlog.info(\"str\", string.trim(str)) -- 打印 \"abc\"\nlog.info(\"str\", str:trim())       -- 打印 \"abc\"\nlog.info(\"str\", #string.trim(str, false, true)) -- 仅裁剪后缀,所以长度是5\n"
            },
            {
                "name": "sys.wait",
                "snippet": "sys.wait(${1:timeout})",
                "description": "sys.wait(timeout) - Task协程等待指定时长\n传入值：\nint 等待时长,单位毫秒,必须大于0,否则无效\n返回值：\nany 通常为nil,除非主动被唤醒(通常不会)\n例子：\nsys.taskInit(function()\n    while 1 do\n        sys.wait(500)\n    end\nend)\n"
            },
            {
                "name": "sys.waitUntil",
                "snippet": "sys.waitUntil(${1:topic},${2:timeout})",
                "description": "sys.waitUntil(topic, timeout) - Task协程等待指定时长或者特定的topic\n传入值：\nstring 事件topic\nint 等待时长,单位毫秒,必须大于0,否则无效\n返回值：\nboolean 如果是超时,返回false,否则返回true\nany 对应topic的内容\n例子：\nsys.taskInit(function()\n    // do something\n    local result, data = sys.waitUntil(\"NET_READY\", 30000)\n    // do something else\nend)\n"
            },
            {
                "name": "sys.taskInit",
                "snippet": "sys.taskInit(${1:func},${2:arg1},${3:arg2},${4:argN})",
                "description": "sys.taskInit(func, arg1, arg2, argN) - 创建一个Task协程\n传入值：\nfunction 待执行的函数,可以是匿名函数, 也可以是local或全局函数\nany 需要传递的参数1,可选 \nany 需要传递的参数2,可选 \nany 需要传递的参数N,可选 \n返回值：\ntask 协程对象\n例子：\nsys.taskInit(function(a, b, c)\n    log.info(\"task\", a, b, c) -- 打印 task A B C\nend, \"A\", \"B\", \"N\")\n"
            },
            {
                "name": "sys.timerStart",
                "snippet": "sys.timerStart(${1:func},${2:timeout},${3:arg1},${4:arg2},${5:argN})",
                "description": "sys.timerStart(func, timeout, arg1, arg2, argN) - 创建一个定时器.非Task,函数里不能直接sys.waitXXX\n传入值：\nfunction 待执行的函数,可以是匿名函数, 也可以是local或全局函数\nint 延时时长,单位毫秒\nany 需要传递的参数1,可选 \nany 需要传递的参数2,可选 \nany 需要传递的参数N,可选 \n返回值：\nint 定时器id\n例子：\nsys.timerStart(function(a, b, c)\n    log.info(\"task\", a, b, c) -- 1000毫秒后才会执行, 打印 task A B C\nend, 1000, \"A\", \"B\", \"N\")\n"
            },
            {
                "name": "sys.timerLoopStart",
                "snippet": "sys.timerLoopStart(${1:func},${2:timeout},${3:arg1},${4:arg2},${5:argN})",
                "description": "sys.timerLoopStart(func, timeout, arg1, arg2, argN) - 创建一个循环定时器.非Task,函数里不能直接sys.waitXXX\n传入值：\nfunction 待执行的函数,可以是匿名函数, 也可以是local或全局函数\nint 延时时长,单位毫秒\nany 需要传递的参数1,可选 \nany 需要传递的参数2,可选 \nany 需要传递的参数N,可选 \n返回值：\nint 定时器id\n例子：\nsys.timerLoopStart(function(a, b, c)\n    log.info(\"task\", a, b, c) -- 1000毫秒后才会执行, 打印 task A B C\nend, 1000, \"A\", \"B\", \"N\")\n"
            },
            {
                "name": "sys.timerStop",
                "snippet": "sys.timerStop(${1:id})",
                "description": "sys.timerStop(id) - 关闭一个定时器.\n传入值：\nint 定时器id\n返回值：\nnil 无返回值\n例子：\nlocal tcount = 0\nlocal tid \ntid = sys.timerLoopStart(function(a, b, c)\n    log.info(\"task\", a, b, c) -- 1000毫秒后才会执行, 打印 task A B C\n    if tcount > 10 then\n        sys.timerStop(tid)\n    end\n    tcount = tcount + 1\nend, 1000, \"A\", \"B\", \"N\")\n"
            },
            {
                "name": "sys.timerStopAll",
                "snippet": "sys.timerStopAll(${1:fnc})",
                "description": "sys.timerStopAll(fnc) - 关闭同一回调函数的所有定时器.\n传入值：\nfunction fnc回调的函数\n返回值：\nnil 无返回值\n例子：\n-- 关闭回调函数为publicTimerCbFnc的所有定时器\nlocal function publicTimerCbFnc(tag)\nlog.info(\"publicTimerCbFnc\",tag)\nend\nsys.timerStart(publicTimerCbFnc,8000,\"first\")\nsys.timerStart(publicTimerCbFnc,8000,\"second\")\nsys.timerStart(publicTimerCbFnc,8000,\"third\")\nsys.timerStopAll(publicTimerCbFnc)\n"
            },
            {
                "name": "sys.publish",
                "snippet": "sys.publish(${1:topic},${2:arg1},${3:agr2},${4:argN})",
                "description": "sys.publish(topic, arg1, agr2, argN) - 往特定topic通道发布一个消息\n传入值：\nstring topic的值\nany 附带的参数1\nany 附带的参数2\nany 附带的参数N\n返回值：\nnil 无返回值\n例子：\nsys.publish(\"BT_READY\", false)\n"
            },
            {
                "name": "sys.subscribe",
                "snippet": "sys.subscribe(${1:topic},${2:func})",
                "description": "sys.subscribe(topic, func) - 订阅一个topic通道\n传入值：\nstring topic的值\nfunction 回调函数, 注意, 不能直接使用sys.waitXXX\n返回值：\nnil 无返回值\n例子：\nlocal function bt_cb(state)\n    log.info(\"bt\", state)\nend\nsys.subscribe(\"BT_READY\", bt_cb)\nsys.subscribe(\"BT_READY\", function(state)\n    log.info(\"sys\", \"Got BT_READY\", state)\nend)\n"
            },
            {
                "name": "sys.unsubscribe",
                "snippet": "sys.unsubscribe(${1:topic},${2:func})",
                "description": "sys.unsubscribe(topic, func) - 取消订阅topic通道\n传入值：\nstring topic的值\nfunction 回调函数, 注意, 不能直接使用sys.waitXXX\n返回值：\nnil 无返回值\n例子：\nlocal function bt_cb(state)\n    log.info(\"bt\", state)\nend\nsys.unsubscribe(\"BT_READY\", bt_cb)\n"
            },
            {
                "name": "sys.run",
                "snippet": "sys.run()",
                "description": "sys.run() - sys库主循环方法,仅允许在main.lua的末尾调用\n返回值：\nnil 无返回值. 这个方法几乎不可能返回.\n例子：\n-- 总是main.lua的结尾一句,将来也许会简化掉\nsys.run()\n-- 之后的代码不会被执行\n"
            },
            {
                "name": "sysplus.waitMsg",
                "snippet": "sysplus.waitMsg(${1:taskName},${2:target},${3:timeout})",
                "description": "sysplus.waitMsg(taskName, target, timeout) - 等待接收一个目标消息\n传入值：\nstring 任务名称，用于唤醒任务的id\nstring 目标消息，如果为nil，则表示接收到任意消息都会退出\nint 超时时间，如果为nil，则表示无超时，永远等待\n返回值：\ntable 成功返回table型的msg，超时返回false\n例子：\n-- 等待任务\nsysplus.waitMsg('a', 'b', 1000)\n-- 注意, 本函数会自动注册成全局函数 sys_wait\n"
            },
            {
                "name": "sysplus.sendMsg",
                "snippet": "sysplus.sendMsg(${1:taskName},${2:target},${3:arg2},${4:arg3},${5:arg4})",
                "description": "sysplus.sendMsg(taskName, target, arg2, arg3, arg4) - 向目标任务发送一个消息\n传入值：\nstring 任务名称，用于唤醒任务的id\nany 消息中的参数1，同时也是waitMsg里的target\nany 消息中的参数2\nany 消息中的参数3\nany 消息中的参数4\n返回值：\nbool 成功返回true, 否则返回false\n例子：\n-- 向任务a,目标b发送消息\nsysplus.sendMsg('a', 'b')\n-- 注意, 本函数会自动注册成全局函数 sys_send\n"
            },
            {
                "name": "sysplus.taskInitEx",
                "snippet": "sysplus.taskInitEx(${1:fun},${2:taskName},${3:cbFun},${4:...})",
                "description": "sysplus.taskInitEx(fun, taskName, cbFun, ...) - 创建一个任务线程,在模块最末行调用该函数并注册模块中的任务函数,main.lua导入该模块即可\n传入值：\nfunction 任务函数名,用于resume唤醒时调用\nstring 任务名称,用于唤醒任务的id\nfunction 接收到非目标消息时的回调函数\nany ... 任务函数fun的可变参数\n返回值：\nnumber 返回该任务的线程号\n例子：\nsysplus.taskInitEx(task1,'a',callback)\n"
            },
            {
                "name": "sysplus.taskDel",
                "snippet": "sysplus.taskDel(${1:taskName})",
                "description": "sysplus.taskDel(taskName) - 删除由taskInitEx创建的任务线程\n传入值：\nstring 任务名称,用于唤醒任务的id\n例子：\nsysplus.taskDel('a')\n"
            },
            {
                "name": "sysplus.cleanMsg",
                "snippet": "sysplus.cleanMsg(${1:taskName})",
                "description": "sysplus.cleanMsg(taskName) - 清除指定task的消息队列\n传入值：\nstring 任务名称\n例子：\nsysplus.cleanMsg('a')\n"
            },
            {
                "name": "timer.mdelay",
                "snippet": "timer.mdelay(${1:timeout})",
                "description": "timer.mdelay(timeout) - 硬阻塞指定时长\n传入值：\nint 阻塞时长,单位ms, 最高1024ms, 实际使用强烈建议不要超过200ms\n返回值：\nnil 无返回值\n例子：\n-- 期间没有任何luat代码会执行,包括底层消息处理机制\n-- 本方法通常不会使用,除非你很清楚会发生什么\ntimer.mdelay(10)\n"
            },
            {
                "name": "timer.udelay",
                "snippet": "timer.udelay(${1:timeout})",
                "description": "timer.udelay(timeout) - 硬阻塞指定时长但us级别,不会很精准\n传入值：\nint 阻塞时长,单位us, 最大3000us\n返回值：\nnil 无返回值\n例子：\n-- 本方法通常不会使用,除非你很清楚会发生什么\n-- 本API在 2023.05.18 添加\ntimer.udelay(10)\n-- 实际阻塞时长是有波动的\n"
            },
            {
                "name": "touchkey.setup",
                "snippet": "touchkey.setup(${1:id},${2:scan_period},${3:window},${4:threshold})",
                "description": "touchkey.setup(id, scan_period, window, threshold) - 配置触摸按键\n传入值：\nint 传感器id,请查阅硬件文档, 例如air101/air103支持 1~15, 例如PA7对应touch id=1\nint 扫描间隔,范围1 ~ 0x3F, 单位16ms,可选\nint 扫描窗口,范围2-7, 可选\nint 阀值, 范围0-127, 可选\n返回值：\nbool 成功返回true, 失败返回false\n例子：\ntouchkey.setup(1)\nsys.subscribe(\"TOUCHKEY_INC\", function(id, count)\n    -- 传感器id\n    -- 计数器,触摸次数统计\n    log.info(\"touchkey\", id, count)\nend)\n"
            },
            {
                "name": "touchkey.close",
                "snippet": "touchkey.close(${1:id})",
                "description": "touchkey.close(id) - 关闭初始触摸按键\n传入值：\nint 传感器id,请查阅硬件文档\n返回值：\nnil 无返回值\n例子：\n-- 不太可能需要关掉的样子\ntouchkey.close(1)\n"
            },
            {
                "name": "u8g2.begin",
                "snippet": "u8g2.begin(${1:conf})",
                "description": "u8g2.begin(conf) - u8g2显示屏初始化\n传入值：\ntable conf 配置信息,详细配置看下面的例子\n返回值：\nint 正常初始化1,已经初始化过2,内存不够3,初始化失败返回4\n例子：\n-- conf配置项说明\n-- ic 字符串,主控芯片类型, 支持custom(自定义命令) ssd1306(默认) ssd1309 ssd1322 sh1106 sh1107 sh1108 st7567 uc1701 ssd1306_128x32\n-- direction 数值,方向,可选0 90 180 270 默认0\n-- mode 字符串,模式,可选i2c_sw:软件i2c i2c_hw:硬件i2c,spi_hw_4pin: 硬件spi\n-- i2c_id: 数值,硬件i2c时有效\n-- i2c_scl: 数值,软件i2c时时钟线的GPIO编号\n-- i2c_sda: 数值软件i2c时数据线的GPIO编号\n-- spi_id、spi_res、spi_dc、spi_cs: 数值,硬件spi的SPI编号,复位GPIO编号,DC线的GPIO编号, CS线的GPIO编号\n-- x_offset: 数值,X轴偏移量,默认按驱动走, 2023.11.10新增的配置项\n\n-- 初始化硬件i2c的ssd1306\nu8g2.begin({ic = \"ssd1306\",direction = 0,mode=\"i2c_hw\",i2c_id=0}) -- direction 可选0 90 180 270\n-- 初始化硬件spi的ssd1306\nu8g2.begin({ic = \"ssd1306\",direction = 0,mode=\"spi_hw_4pin\",spi_id=0,spi_res=pin.PB03,spi_dc=pin.PB01,spi_cs=pin.PB04}) -- direction 可选0 90 180 270\n-- 初始化软件i2c的ssd1306\nu8g2.begin({ic = \"ssd1306\",direction = 0,mode=\"i2c_sw\", i2c_scl=1, i2c_sda=4}) -- 通过PA1 SCL / PA4 SDA模拟\n"
            },
            {
                "name": "u8g2.close",
                "snippet": "u8g2.close()",
                "description": "u8g2.close() - 关闭显示屏\n例子：\n-- 关闭disp,再次使用disp相关API的话,需要重新初始化\nu8g2.close()\n"
            },
            {
                "name": "u8g2.ClearBuffer",
                "snippet": "u8g2.ClearBuffer()",
                "description": "u8g2.ClearBuffer() - 清屏，清除内存帧缓冲区中的所有像素\n例子：\n-- 清屏\nu8g2.ClearBuffer()\n"
            },
            {
                "name": "u8g2.SendBuffer",
                "snippet": "u8g2.SendBuffer()",
                "description": "u8g2.SendBuffer() - 将数据更新到屏幕，将存储器帧缓冲区的内容发送到显示器\n例子：\n-- 把显示数据更新到屏幕\nu8g2.SendBuffer()\n"
            },
            {
                "name": "u8g2.DrawUTF8",
                "snippet": "u8g2.DrawUTF8(${1:str},${2:x},${3:y})",
                "description": "u8g2.DrawUTF8(str, x, y) - 在显示屏上画一段文字，在显示屏上画一段文字,要调用u8g2.SendBuffer()才会更新到屏 注意:设置坐标为显示字符串左下角坐标\n传入值：\nstring 文件内容\nint 横坐标\nint 竖坐标\n例子：\nu8g2.DrawUTF8(\"wifi is ready\", 10, 20)\n"
            },
            {
                "name": "u8g2.DrawButtonUTF8",
                "snippet": "u8g2.DrawButtonUTF8(${1:str},${2:x},${3:y},${4:flags},${5:w},${6:h},${7:v},${8:str})",
                "description": "u8g2.DrawButtonUTF8(str, x, y, flags, w, h, v, str) - 在提供的文本周围画一个框。这与 DrawUTF8 类似，但为文本添加了一些装饰。要调用u8g2.SendBuffer()才会更新到屏幕 注意:设置坐标为显示字符串左下角坐标\n传入值：\nstring 文件内容\nint 横坐标\nint 竖坐标\nint 标志 多个标志可以与“或”运算符一起使用。\nint 文本的最小宽度。如果为0（或低于文本宽度），则文本宽度将用于框架。\nint 文本前后的额外空间。\nint 文本上下的额外空间。\n例子：\nu8g2.DrawButtonUTF8(\"str\", 10, 20,u8g2.BTN_BW2,0,2,2)\n"
            },
            {
                "name": "u8g2.SetFontMode",
                "snippet": "u8g2.SetFontMode(${1:mode})",
                "description": "u8g2.SetFontMode(mode) - 设置字体模式\n传入值：\nint mode字体模式，启用（1）或禁用（0）透明模式\n例子：\nu8g2.SetFontMode(1)\n"
            },
            {
                "name": "u8g2.SetFont",
                "snippet": "u8g2.SetFont(${1:font},${2:indentation})",
                "description": "u8g2.SetFont(font, indentation) - 设置字体\n传入值：\nuserdata font, u8g2.font_opposansm8 为纯英文8号字体,还有font_opposansm10 font_opposansm12 font_opposansm16 font_opposansm18 font_opposansm20 font_opposansm22 font_opposansm24 font_opposansm32 可选 u8g2.font_opposansm12_chinese 为12x12全中文,还有 font_opposansm16_chinese font_opposansm24_chinese font_opposansm32_chinese 可选, u8g2.font_unifont_t_symbols 为符号.\nint indentation, 等宽字体ascii右侧缩进0~127个pixel，等宽字体的ascii字符可能在右侧有大片空白，用户可以选择删除部分。留空或者超过127则直接删除右半边, 非等宽字体无效\n例子：\n-- 设置为中文字体,对之后的drawStr有效\nu8g2.SetFont(u8g2.font_opposansm12)\n"
            },
            {
                "name": "u8g2.GetDisplayHeight",
                "snippet": "u8g2.GetDisplayHeight()",
                "description": "u8g2.GetDisplayHeight() - 获取显示屏高度\n返回值：\nint 显示屏高度\n例子：\nu8g2.GetDisplayHeight()\n"
            },
            {
                "name": "u8g2.GetDisplayWidth",
                "snippet": "u8g2.GetDisplayWidth()",
                "description": "u8g2.GetDisplayWidth() - 获取显示屏宽度\n返回值：\nint 显示屏宽度\n例子：\nu8g2.GetDisplayWidth()\n"
            },
            {
                "name": "u8g2.SetDrawColor",
                "snippet": "u8g2.SetDrawColor(${1:c})",
                "description": "u8g2.SetDrawColor(c) - 为所有绘图功能分配绘图颜色。\n传入值：\nint c为颜色值 0没有色 1有色 2与底色xor\n例子：\nu8g2.SetDrawColor(0)\n"
            },
            {
                "name": "u8g2.DrawPixel",
                "snippet": "u8g2.DrawPixel(${1:x},${2:y})",
                "description": "u8g2.DrawPixel(x,y) - 画一个点.\n传入值：\nint X位置.\nint Y位置.\n例子：\nu8g2.DrawPixel(20, 5)\n"
            },
            {
                "name": "u8g2.DrawLine",
                "snippet": "u8g2.DrawLine(${1:x0},${2:y0},${3:x1},${4:y1})",
                "description": "u8g2.DrawLine(x0,y0,x1,y1) - 在两点之间画一条线.\n传入值：\nint 第一个点的X位置.\nint 第一个点的Y位置.\nint 第二个点的X位置.\nint 第二个点的Y位置.\n例子：\nu8g2.DrawLine(20, 5, 5, 32)\n"
            },
            {
                "name": "u8g2.DrawCircle",
                "snippet": "u8g2.DrawCircle(${1:x0},${2:y0},${3:rad},${4:opt})",
                "description": "u8g2.DrawCircle(x0,y0,rad,opt) - 在x,y位置画一个半径为rad的空心圆.\n传入值：\nint 圆心位置\nint 圆心位置\nint 圆半径.\nint 选择圆的部分或全部. 默认全画 可选 u8g2.DRAW_UPPER_RIGHT  u8g2.DRAW_UPPER_LEFT  u8g2.DRAW_LOWER_LEFT  u8g2.DRAW_LOWER_RIGHT  u8g2.DRAW_ALL\n例子：\nu8g2.DrawCircle(60,30,8,u8g2.DRAW_ALL)\n"
            },
            {
                "name": "u8g2.DrawDisc",
                "snippet": "u8g2.DrawDisc(${1:x0},${2:y0},${3:rad},${4:opt})",
                "description": "u8g2.DrawDisc(x0,y0,rad,opt) - 在x,y位置画一个半径为rad的实心圆.\n传入值：\nint 圆心位置\nint 圆心位置\nint 圆半径.\nint 选择圆的部分或全部. 默认全画 可选 u8g2.DRAW_UPPER_RIGHT  u8g2.DRAW_UPPER_LEFT  u8g2.DRAW_LOWER_LEFT  u8g2.DRAW_LOWER_RIGHT  u8g2.DRAW_ALL\n例子：\nu8g2.DrawDisc(60,30,8,u8g2.DRAW_ALL)\n"
            },
            {
                "name": "u8g2.DrawEllipse",
                "snippet": "u8g2.DrawEllipse(${1:x0},${2:y0},${3:rx},${4:ry},${5:opt})",
                "description": "u8g2.DrawEllipse(x0,y0,rx,ry,opt) - 在x,y位置画一个半径为rad的空心椭圆.\n传入值：\nint 圆心位置\nint 圆心位置\nint 椭圆大小\nint 椭圆大小\nint 选择圆的部分或全部. 默认全画 可选 u8g2.DRAW_UPPER_RIGHT  u8g2.DRAW_UPPER_LEFT  u8g2.DRAW_LOWER_LEFT  u8g2.DRAW_LOWER_RIGHT  u8g2.DRAW_ALL\n例子：\nu8g2.DrawEllipse(60,30,8,u8g2.DRAW_ALL)\n"
            },
            {
                "name": "u8g2.DrawFilledEllipse",
                "snippet": "u8g2.DrawFilledEllipse(${1:x0},${2:y0},${3:rx},${4:ry},${5:opt})",
                "description": "u8g2.DrawFilledEllipse(x0,y0,rx,ry,opt) - 在x,y位置画一个半径为rad的实心椭圆.\n传入值：\nint 圆心位置\nint 圆心位置\nint 椭圆大小\nint 椭圆大小\nint 选择圆的部分或全部. 默认全画 可选 u8g2.DRAW_UPPER_RIGHT  u8g2.DRAW_UPPER_LEFT  u8g2.DRAW_LOWER_LEFT  u8g2.DRAW_LOWER_RIGHT  u8g2.DRAW_ALL\n例子：\nu8g2.DrawFilledEllipse(60,30,8,15)\n"
            },
            {
                "name": "u8g2.DrawBox",
                "snippet": "u8g2.DrawBox(${1:x},${2:y},${3:w},${4:h})",
                "description": "u8g2.DrawBox(x,y,w,h) - 从x / y位置（左上边缘）开始绘制一个框（填充的框）.\n传入值：\nint 左上边缘的X位置\nint 左上边缘的Y位置\nint 盒子的宽度\nint 盒子的高度\n例子：\nu8g2.DrawBox(3,7,25,15)\n"
            },
            {
                "name": "u8g2.DrawFrame",
                "snippet": "u8g2.DrawFrame(${1:x},${2:y},${3:w},${4:h})",
                "description": "u8g2.DrawFrame(x,y,w,h) - 从x / y位置（左上边缘）开始绘制一个框（空框）.\n传入值：\nint 左上边缘的X位置\nint 左上边缘的Y位置\nint 盒子的宽度\nint 盒子的高度\n例子：\nu8g2.DrawFrame(3,7,25,15)\n"
            },
            {
                "name": "u8g2.DrawRBox",
                "snippet": "u8g2.DrawRBox(${1:x},${2:y},${3:w},${4:h},${5:r})",
                "description": "u8g2.DrawRBox(x,y,w,h,r) - 绘制一个从x / y位置（左上边缘）开始具有圆形边缘的填充框/框架.\n传入值：\nint 左上边缘的X位置\nint 左上边缘的Y位置\nint 盒子的宽度\nint 盒子的高度\nint 四个边缘的半径\n例子：\nu8g2.DrawRBox(3,7,25,15)\n"
            },
            {
                "name": "u8g2.DrawRFrame",
                "snippet": "u8g2.DrawRFrame(${1:x},${2:y},${3:w},${4:h},${5:r})",
                "description": "u8g2.DrawRFrame(x,y,w,h,r) - 绘制一个从x / y位置（左上边缘）开始具有圆形边缘的空框/框架.\n传入值：\nint 左上边缘的X位置\nint 左上边缘的Y位置\nint 盒子的宽度\nint 盒子的高度\nint 四个边缘的半径\n例子：\nu8g2.DrawRFrame(3,7,25,15)\n"
            },
            {
                "name": "u8g2.DrawGlyph",
                "snippet": "u8g2.DrawGlyph(${1:x},${2:y},${3:encoding})",
                "description": "u8g2.DrawGlyph(x,y,encoding) - 绘制一个图形字符。字符放置在指定的像素位置x和y.\n传入值：\nint 字符在显示屏上的位置\nint 字符在显示屏上的位置\nint 字符的Unicode值\n例子：\nu8g2.SetFont(u8g2_font_unifont_t_symbols)\nu8g2.DrawGlyph(5, 20, 0x2603)    -- dec 9731/hex 2603 Snowman\n"
            },
            {
                "name": "u8g2.DrawTriangle",
                "snippet": "u8g2.DrawTriangle(${1:x0},${2:y0},${3:x1},${4:y1},${5:x2},${6:y2})",
                "description": "u8g2.DrawTriangle(x0,y0,x1,y1,x2,y2) - 绘制一个三角形（实心多边形）.\n传入值：\nint 点0X位置\nint 点0Y位置\nint 点1X位置\nint 点1Y位置\nint 点2X位置\nint 点2Y位置\n例子：\nu8g2.DrawTriangle(20,5, 27,50, 5,32)\n"
            },
            {
                "name": "u8g2.SetBitmapMode",
                "snippet": "u8g2.SetBitmapMode(${1:mode})",
                "description": "u8g2.SetBitmapMode(mode) - 定义位图函数是否将写入背景色\n传入值：\nint mode字体模式，启用（1）或禁用（0）透明模式\n例子：\nu8g2.SetBitmapMode(1)\n"
            },
            {
                "name": "u8g2.DrawXBM",
                "snippet": "u8g2.DrawXBM(${1:x},${2:y},${3:w},${4:h},${5:data})",
                "description": "u8g2.DrawXBM(x, y, w, h, data) - 绘制位图\n传入值：\nint X坐标\nint y坐标\nint 位图宽\nint 位图高\nint 位图数据,每一位代表一个像素\n例子：\n-- 取模使用PCtoLCD2002软件即可\n-- 在(0,0)为左上角,绘制 16x16 \"今\" 的位图\nu8g2.DrawXBM(0, 0, 16,16, string.char(\n    0x80,0x00,0x80,0x00,0x40,0x01,0x20,0x02,0x10,0x04,0x48,0x08,0x84,0x10,0x83,0x60,\n    0x00,0x00,0xF8,0x0F,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0x02,0x00,0x01,0x80,0x00\n))\n"
            },
            {
                "name": "u8g2.DrawDrcode",
                "snippet": "u8g2.DrawDrcode(${1:x},${2:y},${3:str},${4:size})",
                "description": "u8g2.DrawDrcode(x, y, str, size) - 缓冲区绘制QRCode\n传入值：\nint x坐标\nint y坐标\nstring 二维码的内容\nint 显示大小 (注意:二维码生成大小与要显示内容和纠错等级有关,生成版本为1-40(对应 21x21 - 177x177)的不定大小,如果和设置大小不同会自动在指定的区域中间显示二维码,如二维码未显示请查看日志提示)\n返回值：\nnil 无返回值\n"
            },
            {
                "name": "u8g2.SetContrast",
                "snippet": "u8g2.SetContrast(${1:contrast})",
                "description": "u8g2.SetContrast(contrast) - 调整屏幕对比度\n传入值：\nint 对比度（取值范围与IC有关，如st7567为0-63）\n返回值：\nnil 无返回值\n"
            },
            {
                "name": "u8g2.drawGtfontGb2312",
                "snippet": "u8g2.drawGtfontGb2312(${1:str},${2:size},${3:x},${4:y})",
                "description": "u8g2.drawGtfontGb2312(str,size,x,y) - 使用gtfont显示gb2312字符串\n传入值：\nstring str 显示字符串\nint size 字体大小 (支持16-192号大小字体)\nint x 横坐标\nint y 竖坐标\n例子：\nu8g2.drawGtfontGb2312(\"啊啊啊\",32,0,0)\n"
            },
            {
                "name": "u8g2.drawGtfontUtf8",
                "snippet": "u8g2.drawGtfontUtf8(${1:str},${2:size},${3:x},${4:y})",
                "description": "u8g2.drawGtfontUtf8(str,size,x,y) - 使用gtfont显示UTF8字符串\n传入值：\nstring str 显示字符串\nint size 字体大小 (支持16-192号大小字体)\nint x 横坐标\nint y 竖坐标\n例子：\nu8g2.drawGtfontUtf8(\"啊啊啊\",32,0,0)\n"
            },
            {
                "name": "u8g2.CopyBuffer",
                "snippet": "u8g2.CopyBuffer(${1:buff})",
                "description": "u8g2.CopyBuffer(buff) - 获取底层图像缓冲区\n传入值：\nuserdata zbuff实例,空间要大于等于底层buff的大小\n返回值：\nint 成功返回buff大小,否则返回nil\n例子：\n-- 本函数在u8g2初始化之后才能调用\n\n-- 获取大小\nlocal sz = u8g2.CopyBuffer()\n\n-- 拷贝底层buff\nlocal buff = zbuff.create(sz)\nu8g2.CopyBuffer(buff)\n\n"
            },
            {
                "name": "u8g2.SetPowerSave",
                "snippet": "u8g2.SetPowerSave(${1:is_enable})",
                "description": "u8g2.SetPowerSave(is_enable) - 设置省电模式\n传入值：\nboolean 启用与否. true 启用, false禁用\n返回值：\nnil 无返回值\n例子：\n-- 本API于2023.11.02新增\n-- 开启省电\nu8g2.SetPowerSave(true)\n-- 关闭省电\nu8g2.SetPowerSave(false)\n"
            },
            {
                "name": "uart.setup",
                "snippet": "uart.setup(${1:id},${2:baud_rate},${3:data_bits},${4:stop_bits},${5:partiy},${6:bit_order},${7:buff_size},${8:rs485_gpio},${9:rs485_level},${10:rs485_delay},${11:debug_enable},${12:error_drop})",
                "description": "uart.setup(id, baud_rate, data_bits, stop_bits, partiy, bit_order, buff_size, rs485_gpio, rs485_level, rs485_delay, debug_enable, error_drop) - 配置串口参数\n传入值：\nint 串口id, uart0写0, uart1写1, 如此类推, 最大值取决于设备\nint 波特率, 默认115200，可选择波特率表:{2000000,921600,460800,230400,115200,57600,38400,19200,9600,4800,2400}\nint 数据位，默认为8, 可选 7/8\nint 停止位，默认为1, 根据实际情况，可以有0.5/1/1.5/2等\nint 校验位，可选 uart.None/uart.Even/uart.Odd\nint 大小端，默认小端 uart.LSB, 可选 uart.MSB\nint 缓冲区大小，默认值1024\nint 485模式下的转换GPIO, 默认值0xffffffff\nint 485模式下的rx方向GPIO的电平, 默认值0\nint 485模式下tx向rx转换的延迟时间，默认值12bit的时间，单位us, 9600波特率填20000\nint 开启调试功能，默认使能，填写uart.DEBUG或者非数字使能，其他值都是关闭，目前只有移芯平台支持\nint 遇到接收错误是否放弃缓存数据，默认使能，填写uart.ERROR_DROP或者非数字使能，其他值都是关闭，目前只有移芯平台支持\n返回值：\nint 成功返回0,失败返回其他值\n例子：\n-- 最常用115200 8N1\nuart.setup(1, 115200, 8, 1, uart.NONE)\n-- 可以简写为 uart.setup(1)\n\n-- 485自动切换, 选取GPIO10作为收发转换脚\nuart.setup(1, 115200, 8, 1, uart.NONE, uart.LSB, 1024, 10, 0, 2000)\n-- 遇到接收错误不抛弃缓存数据\nuart.setup(1, 115200, 8, 1, uart.NONE, nil, 1024, nil, nil, nil, nil, 0)\n"
            },
            {
                "name": "uart.write",
                "snippet": "uart.write(${1:id},${2:data})",
                "description": "uart.write(id, data) - 写串口\n传入值：\nint 串口id, uart0写0, uart1写1\nstring/zbuff 待写入的数据，如果是zbuff会从指针起始位置开始读\nint 可选，要发送的数据长度，默认全发\n返回值：\nint 成功的数据长度\n例子：\n-- 写入可见字符串\nuart.write(1, \"rdy\\r\\n\")\n-- 写入十六进制的数据串\nuart.write(1, string.char(0x55,0xAA,0x4B,0x03,0x86))\n"
            },
            {
                "name": "uart.read",
                "snippet": "uart.read(${1:id},${2:len})",
                "description": "uart.read(id, len) - 读串口\n传入值：\nint 串口id, uart0写0, uart1写1\nint 读取长度\nfile/zbuff 可选：文件句柄或zbuff对象\n返回值：\nstring 读取到的数据 / 传入zbuff时，返回读到的长度，并把zbuff指针后移\n例子：\nuart.read(1, 16)\n"
            },
            {
                "name": "uart.close",
                "snippet": "uart.close(${1:id})",
                "description": "uart.close(id) - 关闭串口\n传入值：\nint 串口id, uart0写0, uart1写1\n返回值：\nnil 无返回值\n例子：\nuart.close(1)\n"
            },
            {
                "name": "uart.on",
                "snippet": "uart.on(${1:id},${2:event},${3:func})",
                "description": "uart.on(id, event, func) - 注册串口事件回调\n传入值：\nint 串口id, uart0写0, uart1写1\nstring 事件名称\nfunction 回调方法\n返回值：\nnil 无返回值\n例子：\nuart.on(1, \"receive\", function(id, len)\n    local data = uart.read(id, len)\n    log.info(\"uart\", id, len, data)\nend)\n"
            },
            {
                "name": "uart.wait485",
                "snippet": "uart.wait485(${1:id})",
                "description": "uart.wait485(id) - 等待485模式下TX完成，mcu不支持串口发送移位寄存器空或者类似中断时才需要，在sent事件回调后使用\n传入值：\nint 串口id, uart0写0, uart1写1\n返回值：\nint 等待了多少次循环才等到tx完成，用于粗劣的观察delay时间是否足够，返回不为0说明还需要放大delay\n"
            },
            {
                "name": "uart.exist",
                "snippet": "uart.exist(${1:id})",
                "description": "uart.exist(id) - 检查串口号是否存在\n传入值：\nint 串口id, uart0写0, uart1写1, 如此类推\n返回值：\nbool 存在返回true\n"
            },
            {
                "name": "uart.rx",
                "snippet": "uart.rx(${1:id},${2:buff})",
                "description": "uart.rx(id, buff) - buff形式读串口，一次读出全部数据存入buff中，如果buff空间不够会自动扩展，目前air105,air780e支持这个操作\n传入值：\nint 串口id, uart0写0, uart1写1\nzbuff zbuff对象\n返回值：\nint 返回读到的长度，并把zbuff指针后移\n例子：\nuart.rx(1, buff)\n"
            },
            {
                "name": "uart.rxSize",
                "snippet": "uart.rxSize(${1:id})",
                "description": "uart.rxSize(id) - 读串口Rx缓存中剩余数据量，目前air105,air780e支持这个操作\n传入值：\nint 串口id, uart0写0, uart1写1\n返回值：\nint 返回读到的长度\n例子：\nlocal size = uart.rxSize(1)\n"
            },
            {
                "name": "uart.rxClear",
                "snippet": "uart.rxClear(${1:id})",
                "description": "uart.rxClear(id) - 清除串口Rx缓存中剩余数据量，目前air105,air780e支持这个操作\n传入值：\nint 串口id, uart0写0, uart1写1\n例子：\nuart.rxClear(1)\n"
            },
            {
                "name": "uart.tx",
                "snippet": "uart.tx(${1:id},${2:buff},${3:start},${4:len})",
                "description": "uart.tx(id, buff, start, len) - buff形式写串口,等同于c语言uart_tx(uart_id, &buff[start], len);\n传入值：\nint 串口id, uart0写0, uart1写1\nzbuff 待写入的数据，如果是zbuff会从指针起始位置开始读\nint 可选，要发送的数据起始位置，默认为0\nint 可选，要发送的数据长度，默认为zbuff内有效数据，最大值不超过zbuff的最大空间\n返回值：\nint 成功的数据长度\n例子：\nuart.tx(1, buf)\n"
            },
            {
                "name": "uart.createSoft",
                "snippet": "uart.createSoft(${1:tx_pin},${2:tx_hwtimer_id},${3:rx_pin},${4:rx_hwtimer_id},${5:adjust_period})",
                "description": "uart.createSoft(tx_pin, tx_hwtimer_id, rx_pin, rx_hwtimer_id, adjust_period) - 设置软件uart的硬件配置，只有支持硬件定时器的SOC才能使用，目前只能设置一个，波特率根据平台的软硬件配置有不同的极限，建议9600，接收缓存不超过65535，不支持MSB，支持485自动控制。后续仍要setup操作\n传入值：\nint 发送引脚编号\nint 发送用的硬件定时器ID\nint 接收引脚编号\nint 接收用的硬件定时器ID\nint 发送时序调整，单位是定时器时钟周期，默认是0，需要根据示波器或者逻辑分析仪进行微调\nint 接收时序调整，单位是定时器时钟周期，默认是0，需要根据示波器或者逻辑分析仪进行微调\n返回值：\nint 软件uart的id，如果失败则返回nil\n例子：\n-- 初始化软件uart\nlocal uart_id = uart.createSoft(21, 0, 1, 2) --air780e建议用定时器0和2，tx_pin最好用AGPIO，防止休眠时误触发对端RX\n"
            },
            {
                "name": "uart.list",
                "snippet": "uart.list(${1:max})",
                "description": "uart.list(max) - 获取可用串口号列表，当前仅限win32\n传入值：\nint 可选，默认256，最多获取多少个串口\n返回值：\ntable 获取到的可用串口号列表\n"
            },
            {
                "name": "ulwip.setup",
                "snippet": "ulwip.setup(${1:adapter_index},${2:mac},${3:output_lua_ref},${4:opts})",
                "description": "ulwip.setup(adapter_index, mac, output_lua_ref, opts) - 初始化lwip netif\n传入值：\nint adapter_index 适配器编号\nstring mac 网卡mac地址\nfunction output_lua_ref 回调函数, 参数为(adapter_index, data)\ntable 额外参数, 例如 {mtu=1500, flags=(ulwip.FLAG_BROADCAST | ulwip.FLAG_ETHARP)}\n返回值：\nboolean 成功与否\n例子：\n-- 初始化一个适配器, 并设置回调函数\nulwip.setup(socket.LWIP_STA, string.fromHex(\"18fe34a27b69\"), function(adapter_index, data)\n    log.info(\"ulwip\", \"output_lua_ref\", adapter_index, data:toHex())\nend)\n-- 注意, setup之后, netif的状态是down, 调用ulwip.updown(adapter_index, true)后, 才能正常收发数据\n\n-- 额外参数配置table可选值\n-- mtu, 默认1460\n-- flags, 默认 ulwip.FLAG_BROADCAST | ulwip.FLAG_ETHARP | ulwip.FLAG_ETHERNET | ulwip.FLAG_IGMP | ulwip.FLAG_MLD6\n-- zbuff_out 回调函数接受zbuff作为参数, 默认false\n-- reverse 本地lwip设备,翻转调用逻辑, 默认false, 这个参数是为了拦截当前设备的硬件联网数据所设计的\n"
            },
            {
                "name": "ulwip.updown",
                "snippet": "ulwip.updown(${1:adapter_index},${2:up})",
                "description": "ulwip.updown(adapter_index, up) - 设置netif的状态\n传入值：\nint adapter_index 适配器编号\nboolean up true为up, false为down\n返回值：\nboolean 成功与否\n例子：\n-- 参考ulwip.setup\n"
            },
            {
                "name": "ulwip.link",
                "snippet": "ulwip.link(${1:adapter_index},${2:up})",
                "description": "ulwip.link(adapter_index, up) - 设置netif的物理链路状态\n传入值：\nint adapter_index 适配器编号\nboolean up true为up, false为down\n返回值：\nboolean 当前状态\n例子：\n-- 参考ulwip.setup\n"
            },
            {
                "name": "ulwip.input",
                "snippet": "ulwip.input(${1:adapter_index},${2:data},${3:len},${4:offset})",
                "description": "ulwip.input(adapter_index, data, len, offset) - 往netif输入数据\n传入值：\nint adapter_index 适配器编号\nstring/userdata data 输入的数据\nint 如果data是zbuff, len默认是zbuff的used, 对string无效\nint 如果data是zbuff, offset为数据起始位置, 默认是0, 对string无效\n返回值：\nboolean 成功与否\n例子：\n-- 参考ulwip.setup\n"
            },
            {
                "name": "ulwip.dhcp",
                "snippet": "ulwip.dhcp(${1:adapter_index},${2:up})",
                "description": "ulwip.dhcp(adapter_index, up) - 启动或关闭dhcp\n传入值：\nint adapter_index 适配器编号\nboolean up true为启动, false为关闭\n返回值：\nboolean 当前状态\n例子：\n-- 参考ulwip.setup\n"
            },
            {
                "name": "ulwip.ip",
                "snippet": "ulwip.ip(${1:adapter_index},${2:ip},${3:netmask},${4:gw})",
                "description": "ulwip.ip(adapter_index, ip, netmask, gw) - 设置或获取ip信息\n传入值：\nint adapter_index 适配器编号\nstring ip IP地址, 仅获取时可以不填\nstring netmask 子网掩码, 仅获取时可以不填\nstring gw 网关地址, 仅获取时可以不填\n返回值：\nstring ip地址, 子网掩码, 网关地址\n例子：\n-- 获取现有值\nlocal ip, netmask, gw = ulwip.ip(socket.LWIP_STA)\n-- 设置新值\nulwip.ip(socket.LWIP_STA, \"192.168.0.1\", \"255.255.255.0\", \"192.168.0.1\")\n"
            },
            {
                "name": "ulwip.reg",
                "snippet": "ulwip.reg(${1:adapter_index})",
                "description": "ulwip.reg(adapter_index) - 将netif注册到luatos socket中\n传入值：\nint adapter_index 适配器编号\n返回值：\nboolean 成功与否\n例子：\n-- 参考ulwip.setup\n"
            },
            {
                "name": "ulwip.xt804_xfer",
                "snippet": "ulwip.xt804_xfer(${1:spi_id},${2:cs_pin},${3:addr},${4:zbuff},${5:len},${6:offset},${7:auto_seek},${8:auto_len})",
                "description": "ulwip.xt804_xfer(spi_id, cs_pin, addr, zbuff, len, offset, auto_seek, auto_len) - 操作XT804进行SPI快速收发\n传入值：\nint spi_id SPI的ID号\nint cs_pin CS脚的GPIO号\nint addr 寄存器地址\nzbuff zbuff对象\nint len 长度\nint offset 偏移量, 默认buff:used()\nboolean auto_seek 是否自动移动偏移量, 默认false\nint auto_len 自动分片长度, 默认按寄存器自动选择\n返回值：\nnil 无返回值\n例子：\n-- 本函数属于辅助函数\n"
            },
            {
                "name": "usbapp.set_id",
                "snippet": "usbapp.set_id(${1:id},${2:vid},${3:pid})",
                "description": "usbapp.set_id(id, vid, pid) - USB 设置VID和PID\n传入值：\nint 设备id,默认为0\nint vid 小端格式\nint pid 小端格式\n例子：\nusbapp.set_id(0, 0x1234, 0x5678)\n"
            },
            {
                "name": "usbapp.hid_mode",
                "snippet": "usbapp.hid_mode(${1:id},${2:mode},${3:buff_size})",
                "description": "usbapp.hid_mode(id, mode, buff_size) - USB HID设备模式\n传入值：\nint 设备id,默认为0\nint mode，目前0是键盘，1是自定义\nint buff_size，只能是8,16,32,64，如果是键盘模式或者填了其他值，自动为8\n例子：\nusbapp.hid_mode(0, 0) -- usb hid键盘模式\nusbapp.hid_mode(0, 1) -- usb hid自定义模式，用于免驱USB交互\n"
            },
            {
                "name": "usbapp.start",
                "snippet": "usbapp.start(${1:id})",
                "description": "usbapp.start(id) - 启动USB设备\n传入值：\nint 设备id,默认为0\n返回值：\nbool 成功返回true,否则返回false\n例子：\n-- 启动USB\nusbapp.start(0)\n"
            },
            {
                "name": "usbapp.stop",
                "snippet": "usbapp.stop(${1:id})",
                "description": "usbapp.stop(id) - 关闭USB设备\n传入值：\nint 设备id,默认为0\n返回值：\nbool 成功返回true,否则返回false\n例子：\n-- 关闭USB\nusbapp.stop(0)\n"
            },
            {
                "name": "usbapp.vhid_upload",
                "snippet": "usbapp.vhid_upload(${1:id},${2:data})",
                "description": "usbapp.vhid_upload(id, data) - USB HID设备上传数据\n传入值：\nint 设备id,默认为0\nstring 数据. 注意, HID的可用字符是有限制的, 基本上只有可见字符是支持的, 不支持的字符会替换为空格.\n返回值：\nbool 成功返回true,否则返回false\n例子：\n-- HID上传数据\nusbapp.vhid_upload(0, \"1234\") -- usb hid会模拟敲出1234\n"
            },
            {
                "name": "usbapp.hid_tx",
                "snippet": "usbapp.hid_tx(${1:id},${2:data},${3:start},${4:len})",
                "description": "usbapp.hid_tx(id, data, start, len) - USB HID设备上传用户自定义数据\n传入值：\nint 设备id,默认为0\nstring or zbuff 注意数据量不足时会自动填充0\nint 可选，data为zbuff才有效，要发送的数据起始位置，默认为0\nint 可选，data为zbuff才有效，要发送的数据长度，默认为zbuff内有效数据，最大值不超过zbuff的最大空间\n返回值：\nbool 成功返回true,否则返回false\n例子：\n-- HID上传数据\nusbapp.hid_tx(0, \"1234\") -- usb hid上传0x31 0x32 0x33 0x34  + N个0\n"
            },
            {
                "name": "usbapp.hid_rx",
                "snippet": "usbapp.hid_rx(${1:id},${2:buff})",
                "description": "usbapp.hid_rx(id, buff) - buff形式读接收到的数据，一次读出全部数据存入buff中，如果buff空间不够会自动扩展，目前只有air105支持这个操作\n传入值：\nint 设备id,默认为0\nzbuff zbuff对象\n返回值：\nint 返回读到的长度，并把zbuff指针后移\n例子：\nusbapp.hid_rx(0, buff)\n"
            },
            {
                "name": "usbapp.vhid_cancel_upload",
                "snippet": "usbapp.vhid_cancel_upload(${1:id})",
                "description": "usbapp.vhid_cancel_upload(id) - USB HID设备取消上传数据\n传入值：\nint 设备id,默认为0\n返回值：\nnil 无返回值\n例子：\n-- 取消上传数据,通常不需要\nusbapp.vhid_cancel_upload(0)\n"
            },
            {
                "name": "usbapp.udisk_attach_sdhc",
                "snippet": "usbapp.udisk_attach_sdhc(${1:id})",
                "description": "usbapp.udisk_attach_sdhc(id) - USB U盘设备挂载SDHC，TF卡\n传入值：\nint 设备id,默认为0\n返回值：\nnil 无返回值\n例子：\nusbapp.udisk_attach_sdhc(0)\n"
            },
            {
                "name": "usbapp.udisk_detach_sdhc",
                "snippet": "usbapp.udisk_detach_sdhc(${1:id})",
                "description": "usbapp.udisk_detach_sdhc(id) - USB U盘设备去除挂载SDHC，TF卡\n传入值：\nint 设备id,默认为0\n返回值：\nnil 无返回值\n例子：\nusbapp.udisk_detach_sdhc(0)\n"
            },
            {
                "name": "w5500.init",
                "snippet": "w5500.init(${1:spiid},${2:speed},${3:cs_pin},${4:irq_pin},${5:rst_pin},${6:link_pin})",
                "description": "w5500.init(spiid, speed, cs_pin, irq_pin, rst_pin, link_pin) - 初始化w5500\n传入值：\nint spi通道号, 例如 0, 1, 5, 按设备实际情况选\nint spi速度, 可以设置到对应SPI的最高速度\nint cs pin, 片选脚, 对应W5500的SCS\nint irq pin, 中断脚, 对应W5500的INT\nint reset pin, 复位脚, 对应W5500的RST\nint link 状态 pin，可以留空不使用，默认不使用\n例子：\nw5500.init(spi.SPI_0, 24000000, pin.PB13, pin.PC08, pin.PC09)\n"
            },
            {
                "name": "w5500.config",
                "snippet": "w5500.config(${1:ip},${2:submask},${3:gateway},${4:mac},${5:RTR},${6:RCR},${7:speed})",
                "description": "w5500.config(ip, submask, gateway, mac, RTR, RCR, speed) - w5500配置网络信息\n传入值：\nstring 静态ip地址，如果需要用DHCP获取，请写nil\nstring 子网掩码，如果使用动态ip，则忽略\nstring 网关，如果使用动态ip，则忽略\nstring MAC，写nil则通过MCU唯一码自动生成，如果要写，长度必须是6byte\nint 重试间隔时间，默认2000，单位100us，不懂的不要改\nint 最大重试次数，默认8，不懂的不要改\nint 速度类型，目前只有0硬件配置，1自适应，默认为0\n例子：\nw5500.config(\"192.168.1.2\", \"255.255.255.0\", \"192.168.1.1\", string.fromHex(\"102a3b4c5d6e\"))\n"
            },
            {
                "name": "w5500.bind",
                "snippet": "w5500.bind(${1:id})",
                "description": "w5500.bind(id) - 将w5500注册进通用网络接口\n传入值：\nint 通用网络通道号\n例子：\n-- 若使用的版本不带socket库, 改成 network.ETH0\nw5500.bind(socket.ETH0)\n"
            },
            {
                "name": "w5500.getMac",
                "snippet": "w5500.getMac()",
                "description": "w5500.getMac() - 获取w5500当前的MAC，必须在init之后用，如果config中设置了自己的MAC，需要延迟一点时间再读\n返回值：\nstring 当前的MAC\n例子：\nlocal mac = w5500.getMac()\nlog.info(\"w5500 mac\", mac:toHex())\n"
            },
            {
                "name": "wdt.init",
                "snippet": "wdt.init(${1:timeout})",
                "description": "wdt.init(timeout) - 初始化watchdog并马上启用.大部分设备的watchdog一旦启用就无法关闭.\n传入值：\nint 超时时长,单位为毫秒\n返回值：\nbool 成功返回true,否则返回false(例如底层不支持)\n例子：\nwdt.init(9000)\nsys.timerLoopStart(wdt.feed, 3000)\n"
            },
            {
                "name": "wdt.setTimeout",
                "snippet": "wdt.setTimeout(${1:timeout})",
                "description": "wdt.setTimeout(timeout) - 部分设备支持重新设置watchdog超时时长\n传入值：\nint 超时时长,单位为毫秒\n返回值：\nbool 成功返回true,否则返回false(例如底层不支持)\n例子：\nwdt.init(10000)\nsys.timerLoopStart(wdt.feed, 3000)\nsys.wait(5000)\nsys.setTimeout(5000)\n"
            },
            {
                "name": "wdt.feed",
                "snippet": "wdt.feed()",
                "description": "wdt.feed() - 喂狗,使得超时计时复位,重新计时\n返回值：\nbool 成功返回true,否则返回false(例如底层不支持)\n例子：\nwdt.init(10000)\n-- 定时喂狗,或者根据业务按需喂狗\nsys.timerLoopStart(wdt.feed, 3000)\n"
            },
            {
                "name": "wdt.close",
                "snippet": "wdt.close()",
                "description": "wdt.close() - 关闭watchdog,通常不被支持\n返回值：\nbool 成功返回true,否则返回false(例如底层不支持)\n例子：\nwdt.init(10000)\nsys.wait(9000)\nwdt.close()\n"
            },
            {
                "name": "wsc:debug",
                "snippet": "wsc:debug(${1:onoff})",
                "description": "wsc:debug(onoff) - 配置是否打开debug信息\n传入值：\nboolean 是否打开debug开关\n返回值：\nnil 无返回值\n"
            },
            {
                "name": "websocket.create",
                "snippet": "websocket.create(${1:adapter},${2:url},${3:keepalive},${4:use_ipv6})",
                "description": "websocket.create(adapter, url, keepalive, use_ipv6) - websocket客户端创建\n传入值：\nint 适配器序号, 参考socket库的常量,默认为nil,会选择平台自带的方式\nstring 连接字符串,参考usage\nint 心跳间隔,默认60秒. 2024.4.28新增\nboolean 是否使用ipv6,默认false. 2024.6.17新增\n返回值：\nuserdata 若成功会返回websocket客户端实例,否则返回nil\n例子：\n-- 普通TCP链接\nwsc = websocket.create(nil,\"ws://air32.cn/abc\")\n-- 加密TCP链接\nwsc = websocket.create(nil,\"wss://air32.cn/abc\")\n"
            },
            {
                "name": "wsc:on",
                "snippet": "wsc:on(${1:cb})",
                "description": "wsc:on(cb) - 注册websocket回调\n传入值：\nfunction cb websocket回调,参数包括websocket_client, event, data, payload\n返回值：\nnil 无返回值\n例子：\nwsc:on(function(websocket_client, event, data, payload)\n    -- 打印各种事件\n    log.info(\"websocket\", \"event\", event, data, payload)\nend)\n--[[\nevent的值有:\n    conack 连接服务器成功,已经收到websocket协议头部信息,通信已建立\n    recv   收到服务器下发的信息, data, payload 不为nil\n    sent   send函数发送的消息,服务器在TCP协议层已确认收到\n    disconnect 服务器连接已断开\n\n其中 sent/disconnect 事件在 2023.04.01 新增\n]]\n"
            },
            {
                "name": "wsc:connect",
                "snippet": "wsc:connect()",
                "description": "wsc:connect() - 连接服务器\n返回值：\nboolean 发起成功返回true, 否则返回false\n例子：\n-- 开始建立连接\nwsc:connect()\n-- 本函数仅代表发起成功, 后续仍需根据ready函数判断websocket是否连接正常\n"
            },
            {
                "name": "wsc:autoreconn",
                "snippet": "wsc:autoreconn(${1:reconnect},${2:reconnect_time})",
                "description": "wsc:autoreconn(reconnect, reconnect_time) - 自动重连\n传入值：\nbool 是否自动重连\nint 自动重连周期 单位ms 默认3000ms\n例子：\nwsc:autoreconn(true)\n"
            },
            {
                "name": "wsc:send",
                "snippet": "wsc:send(${1:data},${2:fin},${3:opt})",
                "description": "wsc:send(data, fin, opt) - 发布消息\n传入值：\nstring 待发送的数据,必填\nint 是否为最后一帧,默认1,即马上设置为最后一帧, 也就是单帧发送\nint 操作码, 默认为字符串帧0, 可选1\n返回值：\nbool 成功返回true,否则为false或者nil\n例子：\n-- 简单发送数据\nwsc:send(\"123\")\n-- 分段发送数据, 最后要用1(即FIN帧结束)\nwsc:send(\"123\", 0)\nwsc:send(\"456\", 0)\nwsc:send(\"789\", 1)\n"
            },
            {
                "name": "wsc:close",
                "snippet": "wsc:close()",
                "description": "wsc:close() - websocket客户端关闭(关闭后资源释放无法再使用)\n例子：\nwsc:close()\n"
            },
            {
                "name": "wsc:ready",
                "snippet": "wsc:ready()",
                "description": "wsc:ready() - websocket客户端是否就绪\n返回值：\nbool 客户端是否就绪\n例子：\nlocal stat = wsc:ready()\n"
            },
            {
                "name": "wsc:headers",
                "snippet": "wsc:headers(${1:headers})",
                "description": "wsc:headers(headers) - 设置额外的headers\n传入值：\ntable/string 可以是table,也可以是字符串\n返回值：\nbool 客户端是否就绪\n例子：\n-- table形式\nwsc:headers({\n    Auth=\"Basic ABCDEFGG\"\n})\n-- 字符串形式\nwsc:headers(\"Auth: Basic ABCDERG\\r\\n\")\n"
            },
            {
                "name": "wlan.init",
                "snippet": "wlan.init()",
                "description": "wlan.init() - 初始化\n返回值：\nbool 成功返回true,否则返回false\n"
            },
            {
                "name": "wlan.setMode",
                "snippet": "wlan.setMode(${1:mode})",
                "description": "wlan.setMode(mode) - 设置wifi模式\n传入值：\nint wifi模式\n返回值：\nbool 成功返回true,否则返回false\n例子：\n-- 设置为AP模式, 广播ssid, 接收wifi客户端的链接\nwlan.setMode(wlan.AP)\n\n-- 设置为STATION模式, 也是初始化后的默认模式\nwlan.setMode(wlan.STATION)\n\n-- 混合模式, 做AP又做STATION\nwlan.setMode(wlan.APSTA)\n"
            },
            {
                "name": "wlan.ready",
                "snippet": "wlan.ready()",
                "description": "wlan.ready() - 作为STATION时,是否已经连接上AP,且获取IP成功\n返回值：\nbool 已经连接成功返回true,否则返回false\n"
            },
            {
                "name": "wlan.connect",
                "snippet": "wlan.connect(${1:ssid},${2:password},${3:auto_reconnect},${4:bssid})",
                "description": "wlan.connect(ssid, password, auto_reconnect, bssid) - 作为STATION时,连接到指定AP\n传入值：\nstring AP的ssid\nstring AP的password,可选\nint 0关闭自动重连,1开启自动重连.当前强制开启自动重连\nstring AP的bssid,可选,必须是6字节\n返回值：\nbool 发起连接成功返回true,否则返回false.注意,不代表连接AP成功!!\n例子：\n\n-- 普通模式,带密码\nwlan.connect(\"myap\", \"12345678\")\n-- 普通模式,不带密码\nwlan.connect(\"myap\")\n-- 特殊模式, 重用之前的ssid和密码,本次直接连接\n-- 注意, 前提是本次上电后已经传过ssid和或password,否则必失败\nwlan.connect()\n\n-- 特殊模式, 使用ssid和密码,本次连接指定bssid, 2024.5.7新增\nlocal bssid = string.fromHex(\"00182946365f\")\nwlan.connect(\"myap\", \"12345678\", 1, bssid)\n"
            },
            {
                "name": "wlan.disconnect",
                "snippet": "wlan.disconnect()",
                "description": "wlan.disconnect() - 作为STATION时,断开AP\n"
            },
            {
                "name": "wlan.scan",
                "snippet": "wlan.scan()",
                "description": "wlan.scan() - 扫描wifi频段\n例子：\n-- 注意, wlan.scan()是异步API,启动扫描后会马上返回\n\n-- wifi扫描成功后, 会有WLAN_SCAN_DONE消息, 读取即可\nsys.subscribe(\"WLAN_SCAN_DONE\", function ()\n    local results = wlan.scanResult()\n    log.info(\"scan\", \"results\", #results)\n    for k,v in pairs(results) do\n        log.info(\"scan\", v[\"ssid\"], v[\"rssi\"], (v[\"bssid\"]:toHex()))\n    end\nend)\n\n-- 下面演示的是初始化wifi后定时扫描,请按实际业务需求修改\nsys.taskInit(function()\n    sys.wait(1000)\n    wlan.init()\n    while 1 do\n        wlan.scan()\n        sys.wait(15000)\n    end\nend)\n"
            },
            {
                "name": "wlan.scanResult",
                "snippet": "wlan.scanResult()",
                "description": "wlan.scanResult() - 获取wifi扫描结果\n返回值：\ntable 扫描结果\n例子：\n-- 用法请查阅 wlan.scan() 函数\n"
            },
            {
                "name": "wlan.smartconfig",
                "snippet": "wlan.smartconfig(${1:mode})",
                "description": "wlan.smartconfig(mode) - 配网\n传入值：\nint 配网模式, 默认为esptouch, 若传0则主动停止配网\n返回值：\nbool 启动成功或停止成功, 返回true, 否则返回false\n例子：\nwlan.smartconfig()\nlocal ret, ssid, passwd = sys.waitUntil(\"SC_RESULT\", 180*1000) -- 最多等3分钟\nlog.info(\"sc\", ret, ssid, passwd)\n-- 详细用法请查看demo\n"
            },
            {
                "name": "wlan.getMac",
                "snippet": "wlan.getMac(${1:tp},${2:hexstr})",
                "description": "wlan.getMac(tp, hexstr) - 获取mac\n传入值：\nint 设置何种mac地址,对ESP32系列来说,只能设置STA的地址,即0,默认值也是0\nbool 是否转HEX字符, 默认是true,即输出hex字符串\n返回值：\nstring MAC地址,十六进制字符串形式 \"AABBCCDDEEFF\" 或原始数据\n"
            },
            {
                "name": "wlan.setMac",
                "snippet": "wlan.setMac(${1:tp},${2:mac})",
                "description": "wlan.setMac(tp, mac) - 设置mac\n传入值：\nint 设置何种mac地址,对ESP32系列来说,只能设置STA的地址,即0\nstring 待设置的MAC地址,长度6字节\n返回值：\nbool 成功返回true,否则返回false\n例子：\n-- 设置MAC地址, 2023-03-01之后编译的固件可用\nlocal mac = string.fromHex(\"F01122334455\")\nwlan.setMac(0, mac)\n\n-- 部分模块支持恢复默认MAC, 例如esp32系列\n-- 在2023-11-01 之后编译的固件可用\nlocal mac = string.fromHex(\"000000000000\")\nwlan.setMac(0, mac)\n"
            },
            {
                "name": "wlan.getIP",
                "snippet": "wlan.getIP()",
                "description": "wlan.getIP() - 获取ip,仅STATION或APSTA模式下有意义\n返回值：\nstring ip地址,当前仅返回ipv4地址,例如 \"192.168.1.25\"\n"
            },
            {
                "name": "wlan.createAP",
                "snippet": "wlan.createAP(${1:ssid},${2:passwd},${3:gateway},${4:netmask},${5:channel},${6:opts})",
                "description": "wlan.createAP(ssid, passwd, gateway, netmask, channel, opts) - 启动AP\n传入值：\nstring AP的SSID,必填\nstring AP的密码,可选\nstring AP的网关地址, 默认192.168.4.1\nstring AP的网关掩码, 默认255.255.255.0\nint AP建立的通道, 默认6\ntable AP的配置选项, 可选\n返回值：\nbool 成功创建返回true,否则返回false\n例子：\n-- 注意, 调用本AP时,若wifi模式为STATION,会自动切换成 APSTA\nwlan.createAP(\"luatos1234\", \"12341234\")\n-- 设置网关IP,掩码, 通道, 2023.7.13 新增, BSP未必支持\n-- wlan.createAP(\"luatos1234\", \"12341234\", \"192.168.4.1\", \"255.255.255.0\", 6)\n\n-- opts更多配置项, 2024.3.5新增\n--[[\n{\n    hidden = false, -- 是否隐藏SSID, 默认false,不隐藏\n    max_conn = 4 -- 最大客户端数量, 默认4\n}\n]]\n"
            },
            {
                "name": "wlan.stopAP",
                "snippet": "wlan.stopAP()",
                "description": "wlan.stopAP() - 关闭AP功能\n返回值：\nbool 成功创建返回true,否则返回false\n例子：\nwlan.stopAP()\n"
            },
            {
                "name": "wlan.getInfo",
                "snippet": "wlan.getInfo()",
                "description": "wlan.getInfo() - 获取信息,如AP的bssid,信号强度, STA联网后可获取\n返回值：\ntable 详情,键值对形式\n例子：\n\nlog.info(\"wlan\", \"info\", json.encode(wlan.getInfo()))\n--[[\n典型输出\n{\n    \"bssid\" : \"xxxxxx\",\n    \"rssi\"  : -89,\n    \"gw\" : \"192.168.1.1\"\n}\n]]\n"
            },
            {
                "name": "wlan.powerSave",
                "snippet": "wlan.powerSave(${1:mode})",
                "description": "wlan.powerSave(mode) - 读取或设置省电模式\n传入值：\nint 省电模式,可选, 传入就是设置, 例如wlan.PS_NONE\n返回值：\nint 当前省电模式/设置后的省电模式\n例子：\n-- 请查阅常量表  PS_NONE/PS_MIN_MODEM/PS_MAX_MODEM\nlog.info(\"wlan\", \"PS\", wlan.powerSave(wlan.PS_NONE))\n-- 本API于 2023.03.31 新增\n"
            },
            {
                "name": "wlan.hostname",
                "snippet": "wlan.hostname(${1:new_name})",
                "description": "wlan.hostname(new_name) - 读取或设置Hostname\n传入值：\nstring 新的hostname,可选, 传入就是设置\n返回值：\nstring 当前的hostname或者设置后的hostname\n例子：\n-- 本API于 2023.07.23 新增\n-- 本函数应该在wlan.init之前设置好, 最晚应早于wlan.connect\n-- hostname的默认值是  \"LUATOS_\" + 设备的MAC值\n-- 例如: LUATOS_0022EECC2399\n\nwlan.hostname(\"我的wifi物联网设备\")\n"
            },
            {
                "name": "wlan.staIp",
                "snippet": "wlan.staIp(${1:dhcp_enable},${2:ip},${3:netmask},${4:gateway})",
                "description": "wlan.staIp(dhcp_enable, ip, netmask, gateway) - 设置Station模式下的IP获取模式\n传入值：\nbool 是否启用DHCP,默认是true\nstring 本机IP地址,例如192.168.2.200, 禁用DHCP时必填\nstring 本机IP掩码,例如255.255.255.0, 禁用DHCP时必填\nstring 本机IP网关,例如192.168.2.1, 禁用DHCP时必填\n返回值：\nbool 成功返回true,否则返回false\n例子：\n-- 本API于 2023.10.06 新增\n-- 本函数需要在wlan.init之后才允许调用\n\n-- 启用DHCP, 默认也是启用DHCP,这里是演示API使用\nwlan.staIp(true)\n-- 禁用DHCP,自行设置IP/掩码/网关\nwlan.staIp(false, \"192.168.2.200\", \"255.255.255.0\", \"192.168.2.1\")\n"
            },
            {
                "name": "wlanraw.setup",
                "snippet": "wlanraw.setup(${1:opts},${2:cb})",
                "description": "wlanraw.setup(opts, cb) - 初始化WLAN的RAW层\n传入值：\ntable opts 配置参数\nfunction 回调函数,形式function(buff, size)\n返回值：\nboolean true表示成功,其他失败\n例子：\n-- 当前仅XT804系列支持, 例如 Air101/Air103/Air601/Air690\nwlanraw.setup({\n    buffsize = 1600, -- 缓冲区大小, 默认1600字节\n    buffcount = 10, -- 缓冲区数量, 默认8\n}, cb)\n"
            },
            {
                "name": "ws2812.create",
                "snippet": "ws2812.create(${1:mode},${2:count},${3:id})",
                "description": "ws2812.create(mode, count, id) - 创建上下文\n传入值：\nint 传输模式, 例如 ws2812.GPIO, ws2812.PWM, ws2812.SPI\nint RGB灯总个数\nint 主参数id, 对于不同的模式有不同的值\n返回值：\nuserdata 创建成功返回上下文,否则返回nil\n例子：\n-- GPIO模式, 64个灯, 使用GPIO9\nlocal leds = ws2812.create(ws2812.GPIO, 64, 9)\n-- SPI模式, 32个灯, 使用SPI1\nlocal leds = ws2812.create(ws2812.SPI, 32, 1)\n-- PWM模式, 16个灯, 使用PWM4\nlocal leds = ws2812.create(ws2812.PWM, 16, 4)\n-- HW模式, 64个灯, 使用硬件专用实现,具体id需要对照手册\nlocal leds = ws2812.create(ws2812.RMT, 64, 2)\n\n-- 注意: 并非所有模块都支持以上所有模式\n-- 而且, 固件需要开启对应的GPIO/SPI/PWM功能才能使用对应的模式\n\n"
            },
            {
                "name": "ws2812.set",
                "snippet": "ws2812.set(${1:leds},${2:index},${3:R},${4:G},${5:B})",
                "description": "ws2812.set(leds,index, R, G, B) - 设置灯的颜色\n传入值：\nuserdata 通过ws2812.create获取到的上下文\nint 灯的编号,从0开始\nint RGB值中的R值\nint RGB值中的G值\nint RGB值中的B值\n返回值：\nboolean 设置成功返回true,否则返回nil\n例子：\n-- RGB逐个颜色传递\nws2812.set(leds, 5, 0xFF, 0xAA, 0x11)\n-- 也支持一个参数传完, 与前一条等价\nws2812.set(leds, 5, 0xFFAA11)\n"
            },
            {
                "name": "ws2812.send",
                "snippet": "ws2812.send(${1:leds})",
                "description": "ws2812.send(leds) - 发送数据到设备\n传入值：\nuserdata 通过ws2812.create获取到的上下文\n返回值：\nboolean 设置成功返回true,否则返回nil\n例子：\n-- 没有更多参数, 发就完事了\nws2812.send(leds)\n"
            },
            {
                "name": "ws2812.args",
                "snippet": "ws2812.args(${1:leds},${2:arg0},${3:arg1},${4:arg2},${5:arg3},${6:arg4})",
                "description": "ws2812.args(leds, arg0, arg1, arg2, arg3, arg4) - 配置额外参数\n传入值：\nuserdata 通过ws2812.create获取到的上下文\nint 额外参数0\nint 额外参数1\nint 额外参数2\nint 额外参数3\nint 额外参数4\n返回值：\nboolean 设置成功返回true,否则返回nil\n例子：\n-- 本函数与具体模式有关\n\n--GPIO模式可调整T0H T0L, T1H T1L 的具体延时\nws2812.send(leds, t0h, t0l, t1h, t1l)\n"
            },
            {
                "name": "xxtea.encrypt",
                "snippet": "xxtea.encrypt(${1:data},${2:key})",
                "description": "xxtea.encrypt(data, key) - 加密\n传入值：\nstring data 待加密的数据\nstring key 加密用的密钥\n返回值：\nstring 加密后的数据, 失败返回nil\n"
            },
            {
                "name": "xxtea.decrypt",
                "snippet": "xxtea.decrypt(${1:data},${2:key})",
                "description": "xxtea.decrypt(data, key) - 解密\n传入值：\nstring data 待解密的数据\nstring key 解密用的密钥\n返回值：\nstring 解密后的数据, 失败返回nil\n"
            },
            {
                "name": "ymodem.create",
                "snippet": "ymodem.create(${1:dir_path},${2:file_path})",
                "description": "ymodem.create(dir_path,file_path) - 创建一个ymodem处理句柄\n传入值：\nstring 保存的文件夹路径，默认是\"/\"\nstring 强制保存的绝对文件路径，默认是空，如果设置了，就会直接保存在该文件中\n返回值：\nboolean 成功true, 失败false\n例子：\nlocal handler = ymodem.create(\"/\")\n"
            },
            {
                "name": "ymodem.receive",
                "snippet": "ymodem.receive(${1:handler},${2:data})",
                "description": "ymodem.receive(handler, data) - ymodem接收文件数据并保存\n传入值：\nuserdata ymodem处理句柄\nzbuff/string 输入的数据\n返回值：\nboolean 成功true，失败false\nint ack值，需要通过串口/网络等途径返回发送方\nint flag值，需要通过串口/网络等途径返回发送方，如果有ack值则不发送flag\nboolean, 一个文件接收完成true，传输中false\nboolean, 整个传输完成true 否则false\n例子：\n-- 注意, 数据来源不限, 通常是uart.read得到data\nno_error,ack,flag,file_done,all_done = ymodem.receive(handler, data)\n"
            },
            {
                "name": "ymodem.reset",
                "snippet": "ymodem.reset(${1:handler})",
                "description": "ymodem.reset(handler) - 重置ymodem处理过程\n传入值：\nuserdata ymodem处理句柄\n例子：\n-- 恢复到初始状态，一般用于接收出错后重置，从而进行下一次接收\nymodem.reset(handler)\n"
            },
            {
                "name": "ymodem.release",
                "snippet": "ymodem.release(${1:handler})",
                "description": "ymodem.release(handler) - 释放ymodem处理句柄\n传入值：\nuserdata handler\n例子：\nymodem.release(handler)\n"
            },
            {
                "name": "zbuff.create",
                "snippet": "zbuff.create(${1:length},${2:data},${3:type})",
                "description": "zbuff.create(length,data,type) - 创建zbuff\n传入值：\nint 字节数\nany 可选参数，number时为填充数据，string时为填充字符串\nnumber 可选参数，内存类型，可选：zbuff.HEAP_SRAM(内部sram,默认) zbuff.HEAP_PSRAM(外部psram) zbuff.HEAP_AUTO(自动申请,如存在psram则在psram进行申请,如不存在或失败则在sram进行申请) 注意:此项与硬件支持有关\n返回值：\nobject zbuff对象，如果创建失败会返回nil\n例子：\n-- 创建zbuff\nlocal buff = zbuff.create(1024) -- 空白的\nlocal buff = zbuff.create(1024, 0x33) --创建一个初值全为0x33的内存区域\nlocal buff = zbuff.create(1024, \"123321456654\") -- 创建，并填充一个已有字符串的内容\n\n-- 创建framebuff用的zbuff\n-- zbuff.create({width,height,bit},data,type)\n-- table 宽度、高度、色位深度\n@int 可选参数，填充数据\n@number 可选参数，内存类型，可选：zbuff.HEAP_SRAM(内部sram,默认) zbuff.HEAP_PSRAM(外部psram) zbuff.HEAP_AUTO(自动申请,如存在psram则在psram进行申请,如不存在或失败则在sram进行申请) 注意:此项与硬件支持有关\n@return object zbuff对象，如果创建失败会返回nil\n@usage\n-- 创建zbuff\nlocal buff = zbuff.create({128,160,16})--创建一个128*160的framebuff\nlocal buff = zbuff.create({128,160,16},0xf800)--创建一个128*160的framebuff，初始状态红色\n"
            },
            {
                "name": "buff:write",
                "snippet": "buff:write(${1:para},${2:...})",
                "description": "buff:write(para,...) - zbuff写数据（从当前指针位置开始；执行后指针会向后移动）\n传入值：\nany 写入buff的数据，string时为一个参数，number时可为多个参数\n返回值：\nnumber 数据成功写入的长度\n例子：\n-- 类file的读写操作\nlocal len = buff:write(\"123\") -- 写入数据, 指针相应地往后移动，返回写入的数据长度\nlocal len = buff:write(0x1a,0x30,0x31,0x32,0x00,0x01)  -- 按数值写入多个字节数据\n"
            },
            {
                "name": "buff:read",
                "snippet": "buff:read(${1:length})",
                "description": "buff:read(length) - zbuff读数据（从当前指针位置开始；执行后指针会向后移动）\n传入值：\nint 读取buff中的字节数\n返回值：\nstring 读取结果\n例子：\n-- 类file的读写操作\nlocal str = buff:read(3)\n"
            },
            {
                "name": "buff:clear",
                "snippet": "buff:clear(${1:num})",
                "description": "buff:clear(num) - zbuff清空数据（与当前指针位置无关；执行后指针位置不变）\n传入值：\nint 可选，默认为0。要设置为的值，不会改变buff指针位置\n例子：\n-- 全部初始化为0\nbuff:clear(0)\n"
            },
            {
                "name": "buff:seek",
                "snippet": "buff:seek(${1:base},${2:offset})",
                "description": "buff:seek(base,offset) - zbuff设置光标位置（可能与当前指针位置有关；执行后指针会被设置到指定位置）\n传入值：\nint 偏移长度\nint where, 基点，默认zbuff.SEEK_SET。zbuff.SEEK_SET: 基点为 0 （文件开头），zbuff.SEEK_CUR: 基点为当前位置，zbuff.SEEK_END: 基点为文件尾\n返回值：\nint 设置光标后从buff开头计算起的光标的位置\n例子：\nbuff:seek(0) -- 把光标设置到指定位置\nbuff:seek(5,zbuff.SEEK_CUR)\nbuff:seek(-3,zbuff.SEEK_END)\n"
            },
            {
                "name": "buff:pack",
                "snippet": "buff:pack(${1:format},${2:val1},${3:val2},${4:...})",
                "description": "buff:pack(format,val1, val2,...) - 将一系列数据按照格式字符转化，并写入（从当前指针位置开始；执行后指针会向后移动）\n传入值：\nstring 后面数据的格式（符号含义见下面的例子）\nval 传入的数据，可以为多个数据\n返回值：\nint 成功写入的数据长度\n例子：\nbuff:pack(\">IIHA\", 0x1234, 0x4567, 0x12,\"abcdefg\") -- 按格式写入几个数据\n-- A string\n-- f float\n-- d double\n-- n Lua number\n-- c char\n-- b byte / unsignen char\n-- h short\n-- H unsigned short\n-- i int\n-- I unsigned int\n-- l long\n-- L unsigned long\n-- < 小端\n-- > 大端\n-- = 默认大小端\n"
            },
            {
                "name": "buff:unpack",
                "snippet": "buff:unpack(${1:format})",
                "description": "buff:unpack(format) - 将一系列数据按照格式字符读取出来（从当前指针位置开始；执行后指针会向后移动）\n传入值：\nstring 数据的格式（符号含义见上面pack接口的例子）\n返回值：\nint 成功读取的数据字节长度\nany 按格式读出来的数据\n例子：\nlocal cnt,a,b,c,s = buff:unpack(\">IIHA10\") -- 按格式读取几个数据\n--如果全部成功读取，cnt就是4+4+2+10=20\n"
            },
            {
                "name": "buff:read类型",
                "snippet": "buff:read类型()",
                "description": "buff:read类型() - 读取一个指定类型的数据（从当前指针位置开始；执行后指针会向后移动）\n传入值：\n注释 读取类型可为：I8、U8、I16、U16、I32、U32、I64、U64、F32、F64\n返回值：\nnumber 读取的数据，如果越界则为nil\n例子：\nlocal data = buff:readI8()\nlocal data = buff:readU32()\n"
            },
            {
                "name": "buff:write类型",
                "snippet": "buff:write类型()",
                "description": "buff:write类型() - 写入一个指定类型的数据（从当前指针位置开始；执行后指针会向后移动）\n传入值：\nnumber 待写入的数据\n注释 写入类型可为：I8、U8、I16、U16、I32、U32、I64、U64、F32、F64\n返回值：\nnumber 成功写入的长度\n例子：\nlocal len = buff:writeI8(10)\nlocal len = buff:writeU32(1024)\n"
            },
            {
                "name": "buff:toStr",
                "snippet": "buff:toStr(${1:offset},${2:length})",
                "description": "buff:toStr(offset,length) - 按起始位置和长度取出数据（与当前指针位置无关；执行后指针位置不变）\n传入值：\nint 数据的起始位置（起始位置为0）,默认值也是0\nint 数据的长度,默认是全部数据\n返回值：\nstring 读出来的数据\n例子：\nlocal s = buff:toStr(0,5)--读取开头的五个字节数据\nlocal s = buff:toStr() -- 取出整个zbuff的数据\nlocal s = buff:toStr(0, buff:used()) -- 取出已使用的部分, 与buff:query()一样\n"
            },
            {
                "name": "buff:len",
                "snippet": "buff:len()",
                "description": "buff:len() - 获取zbuff对象的长度（与当前指针位置无关；执行后指针位置不变）\n返回值：\nint zbuff对象的长度\n例子：\nlen = buff:len()\nlen = #buff\n"
            },
            {
                "name": "buff:setFrameBuffer",
                "snippet": "buff:setFrameBuffer(${1:width},${2:height},${3:bit},${4:color})",
                "description": "buff:setFrameBuffer(width,height,bit,color) - 设置buff对象的FrameBuffer属性（与当前指针位置无关；执行后指针位置不变）\n传入值：\nint FrameBuffer的宽度\nint FrameBuffer的高度\nint FrameBuffer的色位深度\nint FrameBuffer的初始颜色\n返回值：\nbool 设置成功会返回true\n例子：\nresult = buff:setFrameBuffer(320,240,16,0xffff)\n"
            },
            {
                "name": "buff:pixel",
                "snippet": "buff:pixel(${1:x},${2:y},${3:color})",
                "description": "buff:pixel(x,y,color) - 设置或获取FrameBuffer某个像素点的颜色（与当前指针位置无关；执行后指针位置不变）\n传入值：\nint 与最左边的距离，范围是0~宽度-1\nint 与最上边的距离，范围是0~高度-1\nint 颜色，如果留空则表示获取该位置的颜色\n返回值：\nany 设置颜色时，设置成功会返回true；读取颜色时，返回颜色的值，读取失败返回nil\n例子：\nrerult = buff:pixel(0,3,0)\ncolor = buff:pixel(0,3)\n"
            },
            {
                "name": "buff:drawLine",
                "snippet": "buff:drawLine(${1:x1},${2:y1},${3:x2},${4:y2},${5:color})",
                "description": "buff:drawLine(x1,y1,x2,y2,color) - 画一条线（与当前指针位置无关；执行后指针位置不变）\n传入值：\nint 起始坐标点与最左边的距离，范围是0~宽度-1\nint 起始坐标点与最上边的距离，范围是0~高度-1\nint 结束坐标点与最左边的距离，范围是0~宽度-1\nint 结束坐标点与最上边的距离，范围是0~高度-1\nint 可选，颜色，默认为0\n返回值：\nbool 画成功会返回true\n例子：\nrerult = buff:drawLine(0,0,2,3,0xffff)\n"
            },
            {
                "name": "buff:drawRect",
                "snippet": "buff:drawRect(${1:x1},${2:y1},${3:x2},${4:y2},${5:color},${6:fill})",
                "description": "buff:drawRect(x1,y1,x2,y2,color,fill) - 画一个矩形（与当前指针位置无关；执行后指针位置不变）\n传入值：\nint 起始坐标点与最左边的距离，范围是0~宽度-1\nint 起始坐标点与最上边的距离，范围是0~高度-1\nint 结束坐标点与最左边的距离，范围是0~宽度-1\nint 结束坐标点与最上边的距离，范围是0~高度-1\nint 可选，颜色，默认为0\nbool 可选，是否在内部填充，默认nil\n返回值：\nbool 画成功会返回true\n例子：\nrerult = buff:drawRect(0,0,2,3,0xffff)\n"
            },
            {
                "name": "buff:drawCircle",
                "snippet": "buff:drawCircle(${1:x},${2:y},${3:r},${4:color},${5:fill})",
                "description": "buff:drawCircle(x,y,r,color,fill) - 画一个圆形（与当前指针位置无关；执行后指针位置不变）\n传入值：\nint **圆心**与最左边的距离，范围是0~宽度-1\nint **圆心**与最上边的距离，范围是0~高度-1\nint 圆的半径\nint 可选，圆的颜色，默认为0\nbool 可选，是否在内部填充，默认nil\n返回值：\nbool 画成功会返回true\n例子：\nrerult = buff:drawCircle(15,5,3,0xC)\nrerult = buff:drawCircle(15,5,3,0xC,true)\n"
            },
            {
                "name": "buff[n",
                "snippet": "buff[n]",
                "description": "buff[n] - 以下标形式进行数据读写（与当前指针位置无关；执行后指针位置不变）\n传入值：\nint 第几个数据，以0开始的下标（C标准）\n返回值：\nnumber 该位置的数据\n例子：\nbuff[0] = 0xc8\nlocal data = buff[0]\n"
            },
            {
                "name": "buff:free",
                "snippet": "buff:free()",
                "description": "buff:free() - 释放zbuff所申请内存 注意：gc时会自动释放zbuff以及zbuff所申请内存，所以通常无需调用此函数，调用前请确认您已清楚此函数用处！调用此函数并不会释放掉zbuff，仅会释放掉zbuff所申请的内存，zbuff需等gc时自动释放！！！\n例子：\nbuff:free()\n"
            },
            {
                "name": "buff:resize",
                "snippet": "buff:resize(${1:n})",
                "description": "buff:resize(n) - 调整zbuff实际分配空间的大小，类似于realloc的效果，new = realloc(old, n)，可以扩大或者缩小（如果缩小后len小于了used，那么used=新len）\n传入值：\nint 新空间大小\n例子：\nbuff:resize(20)\n"
            },
            {
                "name": "buff:copy",
                "snippet": "buff:copy(${1:start},${2:para},${3:...})",
                "description": "buff:copy(start, para,...) - zbuff动态写数据，类似于memcpy效果，当原有空间不足时动态扩大空间\n传入值：\nint 写入buff的起始位置，如果不为数字，则为buff的used，如果小于0，则从used往前数，-1 = used - 1\nany 写入buff的数据，string或zbuff者时为一个参数，number时可为多个参数\n返回值：\nnumber 数据成功写入的长度\n例子：\nlocal len = buff:copy(nil, \"123\") -- 类似于memcpy(&buff[used], \"123\", 3) used+= 3 从buff开始写入数据,指针相应地往后移动\nlocal len = buff:copy(0, \"123\") -- 类似于memcpy(&buff[0], \"123\", 3) if (used < 3) used = 3 从位置0写入数据,指针有可能会移动\nlocal len = buff:copy(2, 0x1a,0x30,0x31,0x32,0x00,0x01)  -- 类似于memcpy(&buff[2], [0x1a,0x30,0x31,0x32,0x00,0x01], 6) if (used < (2+6)) used = (2+6)从位置2开始，按数值写入多个字节数据\nlocal len = buff:copy(9, buff2)  -- 类似于memcpy(&buff[9], &buff2[0], buff2的used) if (used < (9+buff2的used)) used = (9+buff2的used) 从位置9开始，合并入buff2里0~used的内容\nlocal len = buff:copy(5, buff2, 10, 1024)  -- 类似于memcpy(&buff[5], &buff2[10], 1024) if (used < (5+1024)) used = (5+1024)\n"
            },
            {
                "name": "buff:used",
                "snippet": "buff:used()",
                "description": "buff:used() - 获取zbuff里最后一个数据位置指针到首地址的偏移量，来表示zbuff内已有有效数据量大小，注意这个不同于分配的空间大小，由于seek()会改变最后一个数据位置指针，因此也会影响到used()返回值。\n返回值：\nint 有效数据量大小\n例子：\nbuff:used()\n"
            },
            {
                "name": "buff:del",
                "snippet": "buff:del(${1:offset},${2:length})",
                "description": "buff:del(offset,length) - 删除zbuff 0~used范围内的一段数据，注意只是改变了used的值，并不是真的在ram里去清除掉数据\n传入值：\nint 起始位置start, 默认0，如果<0则从used往前数，比如 -1 那么start= used - 1\nint 长度del_len，默认为used，如果start + del_len数值大于used，会强制调整del_len = used - start\n例子：\nbuff:del(1,4)    --从位置1开始删除4个字节数据\nbuff:del(-1,4)    --从位置used-1开始删除4个字节数据，但是这肯定会超过used，所以del_len会调整为1，实际上就是删掉了最后一个字节\n"
            },
            {
                "name": "buff:query",
                "snippet": "buff:query(${1:offset},${2:length},${3:isbigend},${4:issigned},${5:isfloat})",
                "description": "buff:query(offset,length,isbigend,issigned,isfloat) - 按起始位置和长度0~used范围内取出数据，如果是1,2,4,8字节，根据后续参数转换成浮点或者整形\n传入值：\nint 数据的起始位置（起始位置为0）\nint 数据的长度\nboolean 是否是大端格式，如果为nil，则不会转换，直接字节流输出\nboolean 是否是有符号的，默认为false\nboolean 是否是浮点型，默认为false\n返回值：\nstring 读出来的数据\n例子：\nlocal s = buff:query(0,5)--读取开头的五个字节数据\n"
            },
            {
                "name": "buff:set",
                "snippet": "buff:set(${1:start},${2:num},${3:len})",
                "description": "buff:set(start, num, len) - zbuff的类似于memset操作，类似于memset(&buff[start], num, len)，当然有ram越界保护，会对len有一定的限制\n传入值：\nint 可选，开始位置，默认为0,\nint 可选，默认为0。要设置为的值\nint 可选，长度，默认为全部空间，如果超出范围了，会自动截断\n例子：\n-- 全部初始化为0\nbuff:set() --等同于 memset(buff, 0, sizeof(buff))\nbuff:set(8) --等同于 memset(&buff[8], 0, sizeof(buff) - 8)\nbuff:set(0, 0x55) --等同于 memset(buff, 0x55, sizeof(buff))\nbuff:set(4, 0xaa, 12) --等用于 memset(&buff[4], 0xaa, 12)\n"
            },
            {
                "name": "buff:isEqual",
                "snippet": "buff:isEqual(${1:start},${2:buff2},${3:start2},${4:len})",
                "description": "buff:isEqual(start, buff2, start2, len) - zbuff的类似于memcmp操作，类似于memcmp(&buff[start], &buff2[start2], len)\n传入值：\nint 可选，开始位置，默认为0,\nzbuff 比较的对象\nint 可选，比较的对象的开始位置，默认为0\nint 比较长度\n返回值：\nboolean true相等，false不相等\nint 相等返回0，不相等返回第一个不相等位置的序号\n例子：\nlocal result, offset = buff:isEqual(1, buff2, 2, 10) --等同于memcmp(&buff[1], &buff2[2], 10)\n"
            },
            {
                "name": "zlib.c",
                "snippet": "zlib.c(${1:input_file},${2:output_file})",
                "description": "zlib.c(input_file,output_file) - zlib压缩(需要大约270k内存，大部分mcu不支持)\n传入值：\nstring input_file  输入文件\nstring output_file 输出文件\n返回值：\nbool 正常返回 ture  失败返回 false\n例子：\nzlib.c(\"/sd/1.txt\",\"/sd/zlib\")\n"
            },
            {
                "name": "zlib.d",
                "snippet": "zlib.d(${1:input_file},${2:output_file})",
                "description": "zlib.d(input_file,output_file) - zlib解压缩(需要大约18k内存，大部分mcu都支持)\n传入值：\nstring input_file  输入文件\nstring output_file 输出文件\n返回值：\nbool 正常返回 ture  失败返回 false\n例子：\nzlib.d(\"/sd/zlib\",\"/sd/1.txt\")\n"
            },
            {
                "name": "piezo.play",
                "snippet": "piezo.play({freq=${1:3000}, play_duration=${2:1000}, pause_duration=${3:0}, times=${4:1}, blocking=${5:false}})",
                "description": "piezo.play(opts) - Play a tone with custom options\nParameters:\n- freq: frequency in Hz (e.g. 3000)\n- play_duration: duration in milliseconds (e.g. 1000)\n- pause_duration: pause between repetitions in ms (e.g. 0)\n- times: number of repetitions\n- blocking: wait until tone finishes (true/false)"
            },
            {
                "name": "piezo.stop",
                "snippet": "piezo.stop()",
                "description": "piezo.stop() - Stop any currently playing tone immediately"
            },
            {
                "name": "piezo.success",
                "snippet": "piezo.success({freq=${1:2700}, play_duration=${2:100}, pause_duration=${3:25}, times=${4:2}, blocking=${5:false}})",
                "description": "piezo.success(opts) - Play a success tone\nDefault: 2700Hz, short beep x2\nParameters:\n- Same as piezo.play"
            },
            {
                "name": "piezo.error",
                "snippet": "piezo.error({freq=${1:200}, play_duration=${2:1000}, times=${3:1}, blocking=${4:false}})",
                "description": "piezo.error(opts) - Play an error tone\nDefault: 200Hz, long beep\nParameters:\n- Same as piezo.play"
            },
            {
                "name": "piezo.play_music",
                "snippet": "piezo.play_music(\"${1:C41D42E43}\", ${2:false})",
                "description": "piezo.play_music(music_str, blocking) - Play a music string where each note is followed by a duration digit\nExample: \"C41D42E43\"\n- blocking: true or false"
            },
            {
                "name": "piezo.is_playing",
                "snippet": "piezo.is_playing()",
                "description": "piezo.is_playing() - Returns true if a tone or music is currently playing"
            },
            {
                "name": "piezo.set_callback",
                "snippet": "piezo.set_callback(\"${1:step|done}\", ${2:function(data) print(data.playing, data.freq) end})",
                "description": "piezo.set_callback(type, callback) - Set a callback for tone events\nTypes:\n- \"step\": called before/after each tone step with `{ playing, freq }`\n- \"done\": called when playback completes"
            },
            {
                "name": "piezo.set_speed",
                "snippet": "piezo.set_speed(${1:speed})",
                "description": "piezo.set_speed(speed) - Sets the note playback speed (used by play_music)\n- speed: Base unit in milliseconds (e.g. 80)"
            },
                {
        "name": "millis",
        "snippet": "millis()",
        "description": "millis() - Returns the number of milliseconds since the program started."
    },
    {
        "name": "micros",
        "snippet": "micros()",
        "description": "micros() - Returns the number of microseconds since the program started."
    },
    {
        "name": "delay",
        "snippet": "delay(${1:ms})",
        "description": "delay(ms) - Pause execution for a specified time in milliseconds."
    },
    {
        "name": "delayMicroseconds",
        "snippet": "delayMicroseconds(${1:us})",
        "description": "delayMicroseconds(us) - Pause execution for a specified time in microseconds."
    },
    {
        "name": "pinMode",
        "snippet": "pinMode(${1:pin}, ${2:mode})",
        "description": "pinMode(pin, mode) - Set the mode of a pin (INPUT, OUTPUT, etc.)."
    },
    {
        "name": "digitalWrite",
        "snippet": "digitalWrite(${1:pin}, ${2:value})",
        "description": "digitalWrite(pin, value) - Set a digital pin to HIGH or LOW."
    },
    {
        "name": "digitalRead",
        "snippet": "digitalRead(${1:pin})",
        "description": "digitalRead(pin) - Read the value from a digital pin."
    },
    {
        "name": "analogRead",
        "snippet": "analogRead(${1:pin})",
        "description": "analogRead(pin) - Read the value from an analog pin."
    },
    {
        "name": "analogWrite",
        "snippet": "analogWrite(${1:pin}, ${2:value})",
        "description": "analogWrite(pin, value) - Write a PWM value to a pin (not implemented on ESP32)."
    },
    {
        "name": "analogReadResolution",
        "snippet": "analogReadResolution(${1:bits})",
        "description": "analogReadResolution(bits) - Set the resolution for analogRead."
    },
    {
        "name": "analogWriteResolution",
        "snippet": "analogWriteResolution(${1:bits})",
        "description": "analogWriteResolution(bits) - Set the resolution for analogWrite."
    },
    {
        "name": "pulseIn",
        "snippet": "pulseIn(${1:pin}, ${2:value}, ${3:timeout})",
        "description": "pulseIn(pin, value, timeout) - Measures the length (in microseconds) of a pulse on the pin."
    },
    {
        "name": "pulseInLong",
        "snippet": "pulseInLong(${1:pin}, ${2:value}, ${3:timeout})",
        "description": "pulseInLong(pin, value, timeout) - Like pulseIn, but handles longer durations."
    },
    {
        "name": "random",
        "snippet": "random(${1:min}, ${2:max})",
        "description": "random(min, max) - Returns a random number between min and max-1."
    },
    {
        "name": "randomSeed",
        "snippet": "randomSeed(${1:seed})",
        "description": "randomSeed(seed) - Sets the seed for the random number generator."
    },
    {
        "name": "map",
        "snippet": "map(${1:value}, ${2:fromLow}, ${3:fromHigh}, ${4:toLow}, ${5:toHigh})",
        "description": "map(value, fromLow, fromHigh, toLow, toHigh) - Re-maps a number from one range to another."
    },
    {
        "name": "constrain",
        "snippet": "constrain(${1:value}, ${2:min}, ${3:max})",
        "description": "constrain(value, min, max) - Constrains a number to be within a range."
    },
    {
        "name": "print",
        "snippet": "print(${1:...})",
        "description": "print(...) - Print to Serial without newline."
    },
    {
        "name": "println",
        "snippet": "println(${1:...})",
        "description": "println(...) - Print to Serial with newline."
    },
    {
        "name": "typeof",
        "snippet": "typeof(${1:val})",
        "description": "typeof(val) - Returns the type of a value."
    },
    {
        "name": "tostring",
        "snippet": "tostring(${1:val})",
        "description": "tostring(val) - Converts a value to string."
    },
    {
        "name": "tonumber",
        "snippet": "tonumber(${1:val})",
        "description": "tonumber(val) - Converts a string to a number."
    },
    {
        "name": "len",
        "snippet": "len(${1:val})",
        "description": "len(val) - Gets length of string or table."
    },
    {
        "name": "keys",
        "snippet": "keys(${1:table})",
        "description": "keys(table) - Returns a list of all keys in a table."
    },
    {
        "name": "values",
        "snippet": "values(${1:table})",
        "description": "values(table) - Returns a list of all values in a table."
    },
    {
        "name": "dump",
        "snippet": "dump(${1:...})",
        "description": "dump(...) - Debug print of one or more Lua values."
    }
    ,
        {
        "name": "ble_print",
        "snippet": "ble_print(${1:...})",
        "description": "ble_print(...) - Print to BLE without newline. Useful for debugging BLE applications."
    }
        ]
    }
}